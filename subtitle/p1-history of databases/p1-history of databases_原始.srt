1
00:00:04,670 --> 00:00:05,740
Hey, yo, yo,

2
00:00:05,750 --> 00:00:07,540
pack the chrome sounds by like mrs. 

3
00:00:07,550 --> 00:00:09,220
Jones, liverpool mathematics.

4
00:00:09,230 --> 00:00:10,780
We have the devil spoken stone. 

5
00:00:10,890 --> 00:00:11,440
Up one heads, 

6
00:00:11,450 --> 00:00:14,480
the bed make shot some little when we get started for chat up, 

7
00:00:14,490 --> 00:00:16,640
everyone can down with us this beginning. 

8
00:00:17,200 --> 00:00:19,610
I'll get two people in new york city easy, evan,

9
00:00:19,620 --> 00:00:23,630
and then brooklyn dva is the finest jail in seattle and they put the greek. 

10
00:00:23,930 --> 00:00:26,650
These people that are helping us out and staying true to us. 

11
00:00:26,660 --> 00:00:27,280
Since the beginning. 

12
00:00:27,910 --> 00:00:30,980
I want to thank carnegie mellon for not firing me for another year. 

13
00:00:31,310 --> 00:00:31,880
That's always important. 

14
00:00:32,680 --> 00:00:36,110
The core sponsor for this semester is going to be amazon. 

15
00:00:36,580 --> 00:00:41,410
Amazon is the largest database vendor in the world in terms of market cap, 

16
00:00:41,420 --> 00:00:42,250
how much money they're making. 

17
00:00:42,890 --> 00:00:43,250
Right? 

18
00:00:43,480 --> 00:00:45,090
They make all the money on the store, 

19
00:00:45,410 --> 00:00:48,400
make a lot of money aws but they make a ton of money on databases. 

20
00:00:48,800 --> 00:00:53,170
Redshift aurora or the dynamo db they have a ton of stuff. 

21
00:00:54,600 --> 00:00:55,920
Usually oracle was number one. 

22
00:00:55,930 --> 00:00:58,160
Actually, maybe microsoft is number one for a while, too.

23
00:00:58,800 --> 00:01:04,530
Amazon is officially number one as of which microsoft might be number 100, 

24
00:01:04,540 --> 00:01:05,770
whatever they're making a ton of money. 

25
00:01:07,290 --> 00:01:10,190
Anyway, they're helping us with the course logistics and sponsor goes.

26
00:01:11,850 --> 00:01:12,840
We're really appreciative of that. 

27
00:01:13,200 --> 00:01:14,240
And then the end of the semester, 

28
00:01:15,800 --> 00:01:18,480
somebody will come give from the redshift team come and give a tech talk

29
00:01:18,490 --> 00:01:19,640
about the system that they're building. 

30
00:01:19,650 --> 00:01:21,920
We will discuss redshift throughout the semester. 

31
00:01:23,360 --> 00:01:25,550
A lot of the techniques that will describe during the semester

32
00:01:26,230 --> 00:01:28,580
they're actually implementing in their system. 

33
00:01:30,280 --> 00:01:33,470
I quickly want to go over the course logistics and what the expected

34
00:01:33,480 --> 00:01:34,030
for the semester, 

35
00:01:34,040 --> 00:01:36,350
but I must have had most of the time on the history of databases, 

36
00:01:36,360 --> 00:01:37,930
because I find that part more interesting. 

37
00:01:37,940 --> 00:01:40,680
And then as I sent the email out over the weekend, 

38
00:01:41,430 --> 00:01:42,940
it would be based on the two readings. 

39
00:01:44,250 --> 00:01:48,530
Again, it's not meant to be like deep into the internal of data systems.

40
00:01:48,910 --> 00:01:51,330
Just to give you perspective of what the landscape looks like, 

41
00:01:51,630 --> 00:01:53,160
why we're spending all the time talking

42
00:01:53,170 --> 00:01:55,000
about relational databases and not other things. 

43
00:01:56,450 --> 00:01:59,370
So a lot of you guys are here for obvious reasons you want to take this course. 

44
00:02:00,200 --> 00:02:01,470
But just as the final pitch, 

45
00:02:01,480 --> 00:02:07,070
i'll say the things that we talk about this semester for database systems

46
00:02:07,080 --> 00:02:08,950
and particularly for analytical database systems, 

47
00:02:10,050 --> 00:02:12,120
these are hard problems not ever can do it. 

48
00:02:12,680 --> 00:02:15,910
And companies pay a lot of money for students, 

49
00:02:16,420 --> 00:02:19,790
not coming to this class from other places as well that have experience

50
00:02:19,800 --> 00:02:20,830
in working database systems. 

51
00:02:22,550 --> 00:02:24,180
If you're just a random javascript programmer, 

52
00:02:25,030 --> 00:02:27,070
they're not going to be touching davis and turtles same way. 

53
00:02:27,080 --> 00:02:30,030
They're not going to be touching the kernel in an operating system, right?

54
00:02:30,360 --> 00:02:32,220
They don't want people off the street. 

55
00:02:32,230 --> 00:02:35,350
They want people to understand fundamentally how these systems are working. 

56
00:02:35,720 --> 00:02:37,130
These are the things that we're going to cover. 

57
00:02:38,200 --> 00:02:39,740
This is not the full list, 

58
00:02:39,750 --> 00:02:42,700
but these are just some of the former students that have worked with us

59
00:02:43,410 --> 00:02:46,000
in taking this class and places that they've gone. 

60
00:02:47,580 --> 00:02:50,540
These are the ones I have photos a there's way more than i'm missing, 

61
00:02:51,720 --> 00:02:53,370
but these are the ones that I I could quickly find. 

62
00:02:54,730 --> 00:02:56,810
Three of them are with me at my startup at autogen, 

63
00:02:57,280 --> 00:02:58,390
some of the best ones as well. 

64
00:02:59,380 --> 00:02:59,590
All right. 

65
00:02:59,600 --> 00:03:03,410
So the unlike in previous years where you try to cover

66
00:03:03,420 --> 00:03:05,050
maybe in memory database systems, 

67
00:03:05,550 --> 00:03:08,640
and spend a little time discussing transaction systems, 

68
00:03:09,940 --> 00:03:13,690
this semester, we're only going to focus on analytical database systems,

69
00:03:15,580 --> 00:03:18,160
just because this is sort of what the hot thing is right now. 

70
00:03:18,490 --> 00:03:21,010
And there's a lot of money sloshing around a lot of systems being built. 

71
00:03:21,980 --> 00:03:24,770
And to sort of understand we want to understand what the state of the art

72
00:03:24,780 --> 00:03:27,090
is and how we got to the point where we are today. 

73
00:03:28,120 --> 00:03:30,750
The goal for you guys is that not only we become aware of what

74
00:03:30,760 --> 00:03:31,830
these systems actually are. 

75
00:03:32,130 --> 00:03:35,030
What are the key features about them and help you to sort of understand

76
00:03:35,040 --> 00:03:37,900
the trade offs between one system design or implementation versus

77
00:03:37,910 --> 00:03:38,420
another? 

78
00:03:39,460 --> 00:03:42,730
You'll hopefully also become proficient in writing high quality systems code, 

79
00:03:43,120 --> 00:03:43,260
right? 

80
00:03:43,270 --> 00:03:45,300
Doing documentation and testing and doing code reviews. 

81
00:03:45,560 --> 00:03:45,580
Right? 

82
00:03:45,590 --> 00:03:48,580
These are soft skills that can be important when you go out in the real world, 

83
00:03:48,590 --> 00:03:49,540
new systems development, 

84
00:03:49,940 --> 00:03:52,630
that it's not something like there's any class to say, 

85
00:03:52,640 --> 00:03:53,730
here's how to write documentation. 

86
00:03:54,080 --> 00:03:55,020
Here's how to write test code. 

87
00:03:55,550 --> 00:03:57,840
It's just things you sort of have to pick up as you go along. 

88
00:03:58,200 --> 00:04:00,830
The projects will be designed such that you'll get exposure to these sort

89
00:04:00,840 --> 00:04:04,140
of best practices on how to do these to work on data systems. 

90
00:04:05,450 --> 00:04:07,820
This course, also, too, is only going to cover state of the art topics.

91
00:04:08,360 --> 00:04:10,030
I'm assuming everyone has taken a database class, 

92
00:04:10,040 --> 00:04:12,130
either last semester or four forty five six, 45.

93
00:04:12,560 --> 00:04:13,080
What you're undergrad like, 

94
00:04:13,090 --> 00:04:16,080
we're not going to go over to the basic of what a join is, right?

95
00:04:16,580 --> 00:04:16,910
Talk, 

96
00:04:17,480 --> 00:04:18,990
we assume how to do a hash join. 

97
00:04:19,380 --> 00:04:21,850
We'll talk about how to do it parallel and do it, make it run fast.

98
00:04:23,850 --> 00:04:25,000
The topics that we're going to cover. 

99
00:04:26,140 --> 00:04:28,690
First start off talking about storage models and compression. 

100
00:04:28,700 --> 00:04:32,780
And actually, how do you represent data in files on disk?

101
00:04:33,240 --> 00:04:35,930
Then we'll talk about how to do query execution using sort

102
00:04:35,940 --> 00:04:38,450
of modern techniques like vectorization and compilation. 

103
00:04:38,850 --> 00:04:40,890
Then we'll talk about modern join algorithms. 

104
00:04:41,520 --> 00:04:45,110
Networking protocols are getting things out of the data in and out of the database. 

105
00:04:45,550 --> 00:04:47,910
Then we'll spend a little time talking about how to do query optimization, 

106
00:04:48,700 --> 00:04:51,400
go much deeper than we were able to cover in the inter class. 

107
00:04:51,920 --> 00:04:52,910
If you look at the schedule, 

108
00:04:52,920 --> 00:04:57,810
the last four or five lectures are actually targeting single database systems. 

109
00:04:58,420 --> 00:05:00,520
There's a whole lecture on snowflake, a whole lecture on data bricks,

110
00:05:00,530 --> 00:05:03,990
a whole lecture on big query of drama. 

111
00:05:04,480 --> 00:05:07,070
The idea is that we want to take all the things we discussed

112
00:05:07,080 --> 00:05:07,950
throughout the semester, 

113
00:05:09,470 --> 00:05:10,460
understand the basics of them, 

114
00:05:10,470 --> 00:05:13,060
and then look at a real system that implements all these things. 

115
00:05:13,520 --> 00:05:16,120
And try to understand like, why are they doing this a certain way?

116
00:05:16,130 --> 00:05:17,960
Or what are the benefits? 

117
00:05:17,970 --> 00:05:20,840
Or what are the disadvantages of the approaches that they're taking? 

118
00:05:25,840 --> 00:05:29,600
Again, i'm assuming you've taken an intro davis class.

119
00:05:30,080 --> 00:05:33,530
We're not going to cover sort of the basics of sql and other things. 

120
00:05:35,130 --> 00:05:37,330
So all the website is up to date. 

121
00:05:37,340 --> 00:05:40,310
I I haven't updated the homepage because I try to get, 

122
00:05:41,070 --> 00:05:46,170
I try to use dolly to have like the last supper and in the middle, 

123
00:05:47,050 --> 00:05:48,520
it didn't work out very well. 

124
00:05:48,810 --> 00:05:49,890
I've got to work on it anyway. 

125
00:05:49,900 --> 00:05:51,490
So the website is up to date. 

126
00:05:51,500 --> 00:05:54,070
So the syllabus and the schedule is all there. 

127
00:05:54,510 --> 00:05:56,530
For the most part, it's stable.

128
00:05:57,570 --> 00:06:00,040
So if you understand what's expected for you in the course, 

129
00:06:00,050 --> 00:06:00,960
please go look at that. 

130
00:06:01,590 --> 00:06:04,580
I'll say this throughout a couple of times in the beginning, right?

131
00:06:05,090 --> 00:06:06,200
For academic honesty, 

132
00:06:06,430 --> 00:06:08,200
again, this is the advanced level class.

133
00:06:08,210 --> 00:06:09,640
I assume everyone here is smart. 

134
00:06:09,990 --> 00:06:11,010
Therefore, you don't need to cheat.

135
00:06:11,350 --> 00:06:15,570
If you do cheat, we will take you over to warner hall and deal with that.

136
00:06:17,470 --> 00:06:18,130
If you went in doubt, 

137
00:06:18,140 --> 00:06:19,690
if you're not sure about doing something like I have

138
00:06:19,700 --> 00:06:21,450
this little stupid code that somebody wrote in get hub, 

139
00:06:21,460 --> 00:06:22,570
can I use it in my project? 

140
00:06:22,580 --> 00:06:23,980
If you're not sure, 

141
00:06:24,320 --> 00:06:31,120
then just ask myself at the ta my office hours to be mondays and wednesdays, 

142
00:06:31,170 --> 00:06:32,520
the hour before class, 

143
00:06:32,960 --> 00:06:34,160
upstairs on the line floor. 

144
00:06:34,530 --> 00:06:35,790
And then we can talk about anything you want, 

145
00:06:35,800 --> 00:06:37,510
any of the projects and papers. 

146
00:06:37,920 --> 00:06:38,800
How to get a database job? 

147
00:06:38,810 --> 00:06:39,920
I have a bunch of database shirts. 

148
00:06:39,930 --> 00:06:41,200
My office, the company send me.

149
00:06:41,590 --> 00:06:43,370
Please come and get some, 

150
00:06:43,750 --> 00:06:46,060
because i'm kind of getting a little hoarder level because they send

151
00:06:46,070 --> 00:06:47,220
a bunch of me during the pandemic. 

152
00:06:47,230 --> 00:06:48,340
I have a bunch of boxes. 

153
00:06:48,350 --> 00:06:49,620
I've got to start getting rid of them. 

154
00:06:49,630 --> 00:06:51,070
So come and talk to me. 

155
00:06:52,010 --> 00:06:54,910
We have one ta when he's awesome. 

156
00:06:55,690 --> 00:06:57,280
So he's my third year ph student. 

157
00:06:57,620 --> 00:06:58,300
This is true. 

158
00:06:58,310 --> 00:07:00,830
He is a former paralegal for like the sketchy law firm. 

159
00:07:01,050 --> 00:07:02,510
He is a certified chicken farmer. 

160
00:07:03,230 --> 00:07:06,740
He is the number of ranked phd student at carnegie mellon for data

161
00:07:06,750 --> 00:07:08,060
for databases to be very clear. 

162
00:07:08,460 --> 00:07:10,500
So, again, he'll help me with the projects.

163
00:07:10,510 --> 00:07:12,940
He'll be a part of the conversations as we go along the semester. 

164
00:07:14,280 --> 00:07:15,630
So by all means, leverage him.

165
00:07:15,640 --> 00:07:16,270
If you have questions. 

166
00:07:18,420 --> 00:07:20,530
The expectations are 33 things. 

167
00:07:20,540 --> 00:07:22,730
There's reading assignments, projects, and the final exam.

168
00:07:23,710 --> 00:07:25,350
Every class will have one assigned reading, 

169
00:07:25,360 --> 00:07:26,430
except for today's class. 

170
00:07:26,820 --> 00:07:29,190
And they'll be indicated by the icon here. 

171
00:07:30,490 --> 00:07:37,990
I'll post on piazza what's actually expected in in these in these reading reviews. 

172
00:07:38,000 --> 00:07:41,520
But the main ideas ii want you to get out of is like, read the paper,

173
00:07:41,530 --> 00:07:42,400
understand what they're doing, 

174
00:07:43,180 --> 00:07:45,120
understand all the things that we talked about, 

175
00:07:45,350 --> 00:07:47,230
how to put, how would it fit together in a higher system,

176
00:07:47,240 --> 00:07:48,630
a higher level system. 

177
00:07:48,640 --> 00:07:48,750
Then. 

178
00:07:49,440 --> 00:07:49,930
I'm also curious. 

179
00:07:49,940 --> 00:07:52,450
I don't understand what are the workloads that you to evaluate

180
00:07:52,460 --> 00:07:56,620
the the implementation for analytical databases. 

181
00:07:56,630 --> 00:07:59,620
It's most likely going to be tpch and tpcds over and over again. 

182
00:08:00,040 --> 00:08:01,500
It's good just to know what these things are, 

183
00:08:01,510 --> 00:08:05,470
so that when we go into project one, project two, actually, or project three,

184
00:08:05,840 --> 00:08:08,150
you'll have an idea of what workloads you can use based

185
00:08:08,160 --> 00:08:08,950
on the papers you've read. 

186
00:08:09,590 --> 00:08:11,350
And there's a google form here that is live, 

187
00:08:11,360 --> 00:08:12,550
and then there will be a drop down. 

188
00:08:12,560 --> 00:08:13,110
You fill that out. 

189
00:08:13,120 --> 00:08:13,510
Yes? 

190
00:08:15,600 --> 00:08:16,230
It should be three. 

191
00:08:16,510 --> 00:08:17,460
You can skip three readings. 

192
00:08:17,770 --> 00:08:18,500
Sorry, i'll fix that.

193
00:08:18,990 --> 00:08:19,280
Thank you. 

194
00:08:20,210 --> 00:08:23,220
Again, all these reviews have to be your own writing.

195
00:08:23,950 --> 00:08:25,060
Some of these papers are pretty stated. 

196
00:08:25,070 --> 00:08:26,220
They are like they came out last week, 

197
00:08:26,230 --> 00:08:28,260
and so they're probably not going to be a review on the internet. 

198
00:08:28,270 --> 00:08:28,860
You can use. 

199
00:08:31,220 --> 00:08:33,140
You could try chat gpt see what happens. 

200
00:08:37,260 --> 00:08:39,010
Project one, we'll post next week.

201
00:08:39,320 --> 00:08:42,090
But you'd be basically writing a foreign data wrapper for post graphs, 

202
00:08:42,600 --> 00:08:44,910
process, columnar data format, like a parquet file.

203
00:08:45,200 --> 00:08:49,030
The idea here is just to expose you to how to do vectors execution

204
00:08:49,570 --> 00:08:50,710
in the context of post graphs. 

205
00:08:50,720 --> 00:08:52,230
So we don't worry about do sql parsing. 

206
00:08:52,240 --> 00:08:53,970
We don't worry about doing query planning. 

207
00:08:53,980 --> 00:08:55,330
Let postcards handle all that. 

208
00:08:55,750 --> 00:08:58,880
And the idea here would be that you'd be able to trade see the tradeoffs

209
00:08:58,890 --> 00:09:01,520
between your sort of custom engine on the column and our data

210
00:09:01,530 --> 00:09:03,200
versus post stresses, 

211
00:09:03,210 --> 00:09:05,000
row based iterator model. 

212
00:09:05,890 --> 00:09:07,170
Again, what i'm saying, does it make sense?

213
00:09:07,180 --> 00:09:10,530
Then that's not good because we cover these things in the interclass, 

214
00:09:11,320 --> 00:09:14,670
but make sure at least go back and look at them and understand what

215
00:09:14,680 --> 00:09:15,230
i'm talking about. 

216
00:09:15,920 --> 00:09:17,120
Again, we'll post this next week.

217
00:09:17,800 --> 00:09:21,360
Project two is going to be writing an article for encyclopedia, 

218
00:09:21,810 --> 00:09:23,300
so we have an encyclopedia of databases. 

219
00:09:23,310 --> 00:09:26,760
So every single database that i'm aware of the idea would be, 

220
00:09:26,770 --> 00:09:28,640
you go look at the documentation, go read,

221
00:09:28,650 --> 00:09:29,760
maybe even run these systems, 

222
00:09:29,770 --> 00:09:30,880
go talk to the developers, 

223
00:09:31,230 --> 00:09:34,310
understand how they're implementing these different parts of the system

224
00:09:34,320 --> 00:09:35,270
that we care about. 

225
00:09:35,770 --> 00:09:38,080
And you'll be writing article for this. 

226
00:09:38,090 --> 00:09:38,640
Ok? 

227
00:09:39,380 --> 00:09:40,490
Don't plagiarize with this, 

228
00:09:40,540 --> 00:09:42,530
avoid marketing language. 

229
00:09:43,020 --> 00:09:45,130
Sometimes I give the company's access to the website, 

230
00:09:45,430 --> 00:09:49,080
and they'll say, like my database is the fastest whatever, right?

231
00:09:49,090 --> 00:09:50,040
And we have to remove all that. 

232
00:09:51,150 --> 00:09:53,650
Only say things that you can back up by specific claims. 

233
00:09:54,970 --> 00:09:55,080
Right? 

234
00:09:55,290 --> 00:09:57,910
We more care about the internal and not like how people feel

235
00:09:57,920 --> 00:09:59,230
about the database if that makes sense. 

236
00:10:01,090 --> 00:10:02,760
Project three will be a group project. 

237
00:10:03,010 --> 00:10:07,890
And the idea here would be some larger topic that you're interested in. 

238
00:10:07,900 --> 00:10:09,990
That's based on the things we're discussing throughout the semester. 

239
00:10:10,460 --> 00:10:12,430
It doesn't have to be in postgres, but if you want,

240
00:10:12,980 --> 00:10:13,510
it can be. 

241
00:10:14,870 --> 00:10:18,840
The idea here is that you just want to build something that exhibits

242
00:10:18,850 --> 00:10:22,250
some understanding of mastery of the materials we discussed

243
00:10:22,260 --> 00:10:22,970
throughout those masters. 

244
00:10:24,690 --> 00:10:27,010
Again, i'll post some topics as we get closer.

245
00:10:27,020 --> 00:10:28,370
You want to decide later until march. 

246
00:10:28,380 --> 00:10:29,490
What do you exactly want to do? 

247
00:10:30,990 --> 00:10:32,390
I have some ideas of things that I want to do. 

248
00:10:32,400 --> 00:10:34,110
That could potentially turn into a short paper, 

249
00:10:34,600 --> 00:10:35,770
or like a capturing project. 

250
00:10:36,180 --> 00:10:38,210
Again, we can discuss these as we go along.

251
00:10:39,410 --> 00:10:40,610
Again, don't plagiarize.

252
00:10:40,620 --> 00:10:43,130
And all your code has to be your code you submit to us has to be

253
00:10:43,140 --> 00:10:47,800
yours unless you discuss and attributed same thing for the encyclopedia. 

254
00:10:47,810 --> 00:10:53,260
Please don't just copy from the from random things on internet. 

255
00:10:53,270 --> 00:10:55,980
1 year somebody copied from wiki pda and they had like a little

256
00:10:55,990 --> 00:10:58,920
like there's the text and then the square bracket and then the number

257
00:10:58,930 --> 00:10:59,550
for the citation. 

258
00:10:59,560 --> 00:11:04,010
So we had to go deal with that again. 

259
00:11:04,220 --> 00:11:07,030
So the reason why i'm keep showing this because this is on video now. 

260
00:11:07,320 --> 00:11:09,270
Because then if you guys do plagiarize, 

261
00:11:09,770 --> 00:11:11,330
and then I go to turn you in. 

262
00:11:11,340 --> 00:11:15,470
I show them the video link on youtube, or like, here's me discussing this.

263
00:11:16,030 --> 00:11:16,680
And you're screwed. 

264
00:11:18,430 --> 00:11:20,220
There'll be a final exam, but it'll be take home.

265
00:11:20,490 --> 00:11:21,310
Long form questions. 

266
00:11:21,320 --> 00:11:24,150
I did try chat gbt and it was not able to answer them. 

267
00:11:25,420 --> 00:11:29,010
So who knows whether how much better that will get? 

268
00:11:29,020 --> 00:11:30,410
So it's either that like, 

269
00:11:31,730 --> 00:11:35,610
I wonder if it's a limitation of chat gbt or whether my questions are just terrible. 

270
00:11:36,200 --> 00:11:41,080
And it can't parse them acting with you is like really bad at like kind

271
00:11:41,090 --> 00:11:43,240
of like specialized questions like you can answer

272
00:11:43,250 --> 00:11:44,920
basic computer science questions really well, 

273
00:11:44,930 --> 00:11:48,570
but once you dealt with the specialist you kind of like drops the ball

274
00:11:48,580 --> 00:11:50,570
but like terribly but it phrases an amber. 

275
00:11:50,580 --> 00:11:51,530
So you think it's right, 

276
00:11:51,620 --> 00:11:54,090
it's like multi version current control is important because it

277
00:11:54,100 --> 00:11:55,370
does multiversioning like thanks. 

278
00:11:56,220 --> 00:11:57,710
That's what it told me. 

279
00:11:59,860 --> 00:11:59,970
Right? 

280
00:11:59,980 --> 00:12:01,170
Grey breakdown is like this. 

281
00:12:01,180 --> 00:12:02,330
Again, this is on the syllabus,

282
00:12:03,340 --> 00:12:04,650
no big surprises here. 

283
00:12:05,050 --> 00:12:07,140
And then the chorus mailing list, everything will be on piazza.

284
00:12:07,150 --> 00:12:09,760
If you have any technical questions as about project

285
00:12:09,770 --> 00:12:11,490
one and potentially project three, 

286
00:12:11,500 --> 00:12:12,570
as we go along. 

287
00:12:13,430 --> 00:12:14,540
Please post on piazza. 

288
00:12:14,550 --> 00:12:16,580
Don't email one of myself directly. 

289
00:12:17,230 --> 00:12:19,910
And if anything else like your health issues, 

290
00:12:19,920 --> 00:12:21,260
whatever you have going on, 

291
00:12:21,810 --> 00:12:22,540
please email directly. 

292
00:12:24,040 --> 00:12:24,750
Any questions about this? 

293
00:12:27,770 --> 00:12:28,840
Let's get to this databases. 

294
00:12:30,080 --> 00:12:30,090
Yeah. 

295
00:12:30,100 --> 00:12:31,480
1 year somebody complained on youtube. 

296
00:12:31,490 --> 00:12:34,320
I you spent 25 minutes discussing logistics of the course, 

297
00:12:34,330 --> 00:12:35,160
get to the good stuff. 

298
00:12:35,170 --> 00:12:36,460
So here we are. 

299
00:12:37,300 --> 00:12:38,010
As I said, 

300
00:12:38,540 --> 00:12:41,060
this is sort of my bridge history of the last 50, 

301
00:12:41,070 --> 00:12:42,260
60 years of databases. 

302
00:12:43,090 --> 00:12:45,040
So we're not going to go too deep into any one topic, 

303
00:12:45,050 --> 00:12:50,240
but it's a going to an overview of the lay of the land that like, 

304
00:12:50,790 --> 00:12:54,610
I think what's actually really interesting about this is that databases are

305
00:12:54,620 --> 00:12:59,520
a hot area right now in both research and in in industry. 

306
00:12:59,530 --> 00:13:02,280
And yet they're 60 years old. 

307
00:13:02,290 --> 00:13:04,240
First one is going to be from the 1960s. 

308
00:13:05,330 --> 00:13:05,750
Right? 

309
00:13:06,070 --> 00:13:09,040
It just shows you how important they are and how hard the problem is. 

310
00:13:09,050 --> 00:13:09,480
If like, 

311
00:13:10,090 --> 00:13:12,280
it's clearly not a solved problem. 

312
00:13:13,560 --> 00:13:16,950
It's gonna this lecture sort of derived from two papers. 

313
00:13:16,960 --> 00:13:19,740
The first one was called what goes around comes around and is written

314
00:13:19,750 --> 00:13:23,180
by mike stern bakker and joe hellers stein in 2006. 

315
00:13:23,740 --> 00:13:31,700
And it's basically mikes assessment of the database industry and how he

316
00:13:31,710 --> 00:13:33,780
was right for the last 40 years. 

317
00:13:34,800 --> 00:13:36,390
Mike won the touring award in 2014, 

318
00:13:36,400 --> 00:13:38,630
so I would agree with him. 

319
00:13:38,960 --> 00:13:40,850
Then the paper, this other one draft I sent you.

320
00:13:40,860 --> 00:13:41,420
This is mike. 

321
00:13:41,430 --> 00:13:46,950
And I wrote this last year where we basically looked at where this paper

322
00:13:46,960 --> 00:13:49,750
left off and said what's the next sixteen seventeen years

323
00:13:50,110 --> 00:13:51,430
And this was actually triggered by me, 

324
00:13:51,800 --> 00:13:54,350
because there was some like postman hacker news or somebody's like, 

325
00:13:54,360 --> 00:13:56,560
I don't know why people keep using relational databases. 

326
00:13:56,570 --> 00:13:57,760
Graph database is the way to go. 

327
00:13:57,770 --> 00:13:59,160
And I was like, all right,

328
00:13:59,250 --> 00:14:01,400
I said that the mic, let's write the new ones.

329
00:14:05,450 --> 00:14:06,120
The major take away. 

330
00:14:06,130 --> 00:14:08,880
What you guys get from this is that again, 

331
00:14:08,890 --> 00:14:10,480
even though databases are really old, 

332
00:14:10,490 --> 00:14:11,800
the concept is really old. 

333
00:14:12,190 --> 00:14:14,080
They are highly relevant today, 

334
00:14:14,090 --> 00:14:16,690
because the other day, every application,

335
00:14:17,200 --> 00:14:18,070
what are they essentially doing? 

336
00:14:19,380 --> 00:14:19,450
Right? 

337
00:14:20,060 --> 00:14:24,270
They're exposing some user interface for for either a human

338
00:14:24,280 --> 00:14:27,910
or another machine or something to interact with a database. 

339
00:14:29,370 --> 00:14:29,830
Right? 

340
00:14:30,850 --> 00:14:34,600
What's going to be interesting is a lot of the things that will cover this semester. 

341
00:14:34,940 --> 00:14:36,180
These are not new ideas. 

342
00:14:36,190 --> 00:14:37,380
They're not new concepts. 

343
00:14:37,950 --> 00:14:39,430
I'm going to see, I said this in andrew class.

344
00:14:39,440 --> 00:14:42,470
I'll keep saying this over and over again throughout the semester. 

345
00:14:42,820 --> 00:14:45,630
Ibm did a lot of this stuff in the 1970s. 

346
00:14:46,500 --> 00:14:48,340
Just obviously, the harbor was much different.

347
00:14:48,730 --> 00:14:49,770
The landscape was much different, 

348
00:14:49,780 --> 00:14:53,390
but a lot of the things we'll talk about will be just modern incarnations

349
00:14:53,400 --> 00:14:54,550
of what ibm invented. 

350
00:14:55,520 --> 00:14:56,110
The years ago, 

351
00:14:56,760 --> 00:14:58,550
we're going to spend a whole lecture on query compilation, 

352
00:14:58,960 --> 00:14:59,910
how to take a segal query, 

353
00:14:59,920 --> 00:15:04,070
turn into a query plan and then converted that query plan into machine code. 

354
00:15:04,960 --> 00:15:06,520
Ibm did that in the 1970s. 

355
00:15:06,530 --> 00:15:08,550
It was system r they did it in an assembly. 

356
00:15:09,300 --> 00:15:13,460
Now we use lbm but again, the techniques are not new.

357
00:15:13,470 --> 00:15:16,910
The other big thing is going to happen and you'll see this the rest

358
00:15:16,920 --> 00:15:22,130
of your life is that every 10 years somebody's gonna come along and say, 

359
00:15:22,140 --> 00:15:23,210
hey, sequel is stupid.

360
00:15:23,550 --> 00:15:25,440
Relational model that's slow, right?

361
00:15:25,980 --> 00:15:26,690
We can do it better. 

362
00:15:26,700 --> 00:15:30,890
Here's my new data system that doesn't use, at least the model is equal.

363
00:15:31,620 --> 00:15:31,730
Right? 

364
00:15:32,260 --> 00:15:33,535
Everyone's gonna go excited like this is the future sql

365
00:15:33,535 --> 00:15:34,810


366
00:15:34,810 --> 00:15:35,050
 is old, 

367
00:15:35,060 --> 00:15:36,530
sequel is busted, we don't want to use that.

368
00:15:37,040 --> 00:15:40,270
And then low and behold people realize the relational model was

369
00:15:40,280 --> 00:15:40,715
a good idea or sql

370
00:15:40,715 --> 00:15:41,150


371
00:15:41,150 --> 00:15:42,070
 is a good idea. 

372
00:15:43,380 --> 00:15:45,970
Either that thing that the new invention that comes along, 

373
00:15:46,290 --> 00:15:47,270
either that fails, 

374
00:15:48,400 --> 00:15:52,650
or the whatever ideas that this new idea, 

375
00:15:52,660 --> 00:15:56,220
this new concept or new data system has letters get adopted

376
00:15:57,230 --> 00:15:58,900
by the sequel standard and by the racial model. 

377
00:15:59,550 --> 00:16:00,480
Then that thing goes away. 

378
00:16:00,490 --> 00:16:01,900
All right? 

379
00:16:02,460 --> 00:16:04,100
So I think i've seen this in my own life, 

380
00:16:04,470 --> 00:16:05,760
like no sequel is a hot thing. 

381
00:16:06,380 --> 00:16:08,350
People said sequel slow, sequel, stupid,

382
00:16:08,590 --> 00:16:10,130
relation models too, but you want to do documents,

383
00:16:10,140 --> 00:16:11,860
you need jason and everybody built all these jason databases. 

384
00:16:11,860 --> 00:16:13,580


385
00:16:14,110 --> 00:16:14,290
Right? 

386
00:16:14,300 --> 00:16:18,120
And then now we're at the point where maybe that's a bad idea for everything. 

387
00:16:18,960 --> 00:16:20,260
Json is good for some things. 

388
00:16:20,430 --> 00:16:22,250
The relation model now supports json. 

389
00:16:23,880 --> 00:16:27,080
And then all the no sql systems that said sql is a bad idea. 

390
00:16:27,680 --> 00:16:29,970
Every one of them except for redis supports sql, 

391
00:16:30,570 --> 00:16:30,650
right? 

392
00:16:30,660 --> 00:16:32,170
Mongo support to see last year. 

393
00:16:33,630 --> 00:16:33,980
Right? 

394
00:16:33,990 --> 00:16:35,940
So you're going to see this throughout the theme, 

395
00:16:35,950 --> 00:16:39,530
as we go along is that at least once we get past and once the racial model

396
00:16:39,540 --> 00:16:39,910
gets invented, 

397
00:16:40,530 --> 00:16:42,540
people will say every 10 years it's stupid. 

398
00:16:43,040 --> 00:16:48,100
And then it turns out it was mark my board and you'll see this the rest

399
00:16:48,110 --> 00:16:48,460
of your life. 

400
00:16:48,770 --> 00:16:49,220
I guarantee you, 

401
00:16:51,120 --> 00:16:52,670
let's start at the very beginning, 

402
00:16:54,170 --> 00:16:55,050
1960s. 

403
00:16:55,910 --> 00:16:57,470
So to the best of my knowledge, 

404
00:16:57,960 --> 00:16:59,830
at least what is considered conventional wisdom, 

405
00:17:00,320 --> 00:17:02,050
the very first database system, 

406
00:17:03,290 --> 00:17:05,010
our sort of general purpose database system, 

407
00:17:05,560 --> 00:17:11,170
was this thing called integrated data store or iids and I say general purpose, 

408
00:17:11,180 --> 00:17:15,570
what I mean is that it was a database system that was designed to support

409
00:17:16,310 --> 00:17:18,460
arbitrary data sets or databases. 

410
00:17:19,040 --> 00:17:19,270
Right? 

411
00:17:19,400 --> 00:17:19,790
Obviously, 

412
00:17:19,800 --> 00:17:22,870
you can write a little python application yourself and read and write files. 

413
00:17:22,880 --> 00:17:25,190
That's just for exactly that one database. 

414
00:17:25,540 --> 00:17:27,610
That's not what I mean by this, like those things sort of existed.

415
00:17:28,050 --> 00:17:31,270
But this was specifically to say we could then reuse the system

416
00:17:31,280 --> 00:17:34,700
for another application or another customer. 

417
00:17:36,170 --> 00:17:37,480
Ge got this for. 

418
00:17:38,730 --> 00:17:41,830
It was like some timber company out of seattle that had

419
00:17:41,840 --> 00:17:46,860
a huge inventory tracking problem that they need to deal with. 

420
00:17:47,170 --> 00:17:49,160
And said they built this thing called ids to handle that. 

421
00:17:51,140 --> 00:17:55,490
They end up spinning it out of that custom solution for the timber company

422
00:17:55,800 --> 00:17:58,100
and try to sell it a as a standalone product. 

423
00:17:58,350 --> 00:17:58,360
Right? 

424
00:17:58,370 --> 00:17:59,950
Like ge was trying to be a software vendor. 

425
00:18:01,280 --> 00:18:05,580
Is ge the hot thing in computers right now? 

426
00:18:05,590 --> 00:18:05,740
No. 

427
00:18:06,090 --> 00:18:06,470
Right. 

428
00:18:06,990 --> 00:18:13,050
So what the huge mistake they did is that they had this company policy

429
00:18:13,060 --> 00:18:15,580
at the time where ge said, 

430
00:18:16,330 --> 00:18:18,340
if we're not number one in some industry, 

431
00:18:18,680 --> 00:18:19,840
we don't want to be in it at all. 

432
00:18:20,090 --> 00:18:22,990
So they were like the number three computer seller that wasn't good

433
00:18:23,000 --> 00:18:23,510
enough for them. 

434
00:18:23,520 --> 00:18:26,230
And so they sold off their computing division to honeywell. 

435
00:18:27,430 --> 00:18:27,610
Right? 

436
00:18:27,780 --> 00:18:33,100
Then honeywell owned own owned ids and then they were sort of selling it

437
00:18:33,650 --> 00:18:34,110
for a while. 

438
00:18:35,340 --> 00:18:41,210
So there could be two key things about ids that are going to be bad ideas

439
00:18:41,220 --> 00:18:44,990
that are going to then get fixed in their relation to model. 

440
00:18:45,630 --> 00:18:47,350
The first is to meet this network data model, 

441
00:18:47,360 --> 00:18:48,710
and i'll explain what that is in a second. 

442
00:18:49,120 --> 00:18:52,030
And then the other one's going to be this notion of the tuple at a time query, 

443
00:18:52,700 --> 00:18:54,020
meaning like i'm going to write, 

444
00:18:54,530 --> 00:18:56,580
basically for loops in my program, 

445
00:18:57,020 --> 00:18:59,310
iterate over one tuple at a time and do something. 

446
00:19:00,470 --> 00:19:01,630
But as we know, in sql, though,

447
00:19:01,640 --> 00:19:03,430
we're an operator or bags or sets, 

448
00:19:04,440 --> 00:19:06,630
we declare what the thing we actually want to do. 

449
00:19:06,980 --> 00:19:09,450
That then could apply to multiple tuples. 

450
00:19:10,390 --> 00:19:11,400
And that's me way more efficient. 

451
00:19:13,670 --> 00:19:18,300
So ids didn't really take off as far as I know. 

452
00:19:19,160 --> 00:19:21,750
But what actually came out of the project was this thing called codacil. 

453
00:19:21,760 --> 00:19:24,470
I I should do a survey before the class starts. 

454
00:19:24,480 --> 00:19:25,550
Who's ever heard of coda still? 

455
00:19:27,090 --> 00:19:29,110
Well, who not from the previous class?

456
00:19:30,570 --> 00:19:34,250
One of you code is always going to be the hot thing of databases. 

457
00:19:34,540 --> 00:19:37,090
This was the thing that everyone's going to build for their database. 

458
00:19:37,640 --> 00:19:39,080
And obviously, we don't.

459
00:19:39,730 --> 00:19:41,510
So there was this guy, charles bachman,

460
00:19:41,920 --> 00:19:45,550
who worked in ids and he saw, 

461
00:19:45,850 --> 00:19:49,730
she saw the need for having a standard way for cobalt programmers

462
00:19:49,740 --> 00:19:51,490
to interact with the database system. 

463
00:19:52,750 --> 00:20:00,570
They proposed this data model and this query api called codes film

464
00:20:01,480 --> 00:20:03,870
that incorporated the network data model from and the tube

465
00:20:03,880 --> 00:20:08,570
out of time query model from the previous slide from ids and they said

466
00:20:08,980 --> 00:20:09,370
this is

467
00:20:09,380 --> 00:20:10,770
going to be the standard going forward. 

468
00:20:12,010 --> 00:20:16,210
So then bachmann left ids and he worked at this thing called que lane, 

469
00:20:16,760 --> 00:20:19,150
which has been bought and sold over many years. 

470
00:20:19,460 --> 00:20:22,320
And he helped build a new version of a network data model based

471
00:20:22,330 --> 00:20:26,100
on code cell called idms and this thing is actually still around today. 

472
00:20:26,440 --> 00:20:28,510
You're obviously, if you're a brand new startup, you wouldn't use this,

473
00:20:28,520 --> 00:20:28,700
right? 

474
00:20:28,710 --> 00:20:29,840
This is for like legacy applications. 

475
00:20:31,230 --> 00:20:33,250
So the networking model is going to look like this. 

476
00:20:33,260 --> 00:20:38,360
So say I have this example where i'm say i'm nasa. 

477
00:20:38,370 --> 00:20:40,200
This is actually a real example. 

478
00:20:40,660 --> 00:20:44,370
I'm nasa and i'm building a rocket for the go to the moon

479
00:20:44,380 --> 00:20:45,330
by the apollo moon mission. 

480
00:20:46,900 --> 00:20:48,370
A it's a huge engineering project. 

481
00:20:48,380 --> 00:20:51,640
I need to keep track of all the parts that are going to my rocket

482
00:20:52,340 --> 00:20:55,210
and what manufacturer or what company can provide them for me. 

483
00:20:56,350 --> 00:20:56,500
Right? 

484
00:20:56,510 --> 00:20:59,660
So they would have this database where you have suppliers and the parts. 

485
00:21:00,130 --> 00:21:02,400
Then you keep track of what supplier can provide certain parts

486
00:21:02,410 --> 00:21:03,800
and what price and what size and so forth. 

487
00:21:05,510 --> 00:21:06,820
Under the network data model, 

488
00:21:06,830 --> 00:21:09,300
you would have the high level entities like you would have a supplier, 

489
00:21:09,310 --> 00:21:13,570
the name of the company that could provide the part or provide parts. 

490
00:21:13,910 --> 00:21:15,070
You have the part that you need. 

491
00:21:15,420 --> 00:21:17,050
And then you have this other set that says, 

492
00:21:17,060 --> 00:21:19,290
here's the for this supplier, 

493
00:21:19,300 --> 00:21:21,450
they will supply this part, this price.

494
00:21:21,460 --> 00:21:24,080
So you could have these high level entities. 

495
00:21:25,640 --> 00:21:28,180
But then you would have to implicitly have these sets. 

496
00:21:29,180 --> 00:21:30,630
Here what i'm showing in italics, right?

497
00:21:30,640 --> 00:21:32,550
You would have the supplies and the supplied by, 

498
00:21:33,080 --> 00:21:37,660
you would say I have a supplier and there will be a supply

499
00:21:37,670 --> 00:21:39,300
that's in the set of supplies. 

500
00:21:40,690 --> 00:21:47,420
Now if I want to find find me all the parts that a supplier supplies, 

501
00:21:47,850 --> 00:21:49,490
I would have to do a bunch of nest of four lips. 

502
00:21:49,500 --> 00:21:51,050
Go look over every supplier here, 

503
00:21:51,450 --> 00:21:53,190
look over all their supply sets, 

504
00:21:53,700 --> 00:21:56,390
get the supply types, and then reverse go back up there, right?

505
00:21:57,410 --> 00:21:59,200
You basically write a bunch of these nets of four lips, 

506
00:21:59,210 --> 00:22:00,700
and you're doing this over one tube at a time. 

507
00:22:03,220 --> 00:22:06,400
Another problem is going to be is that actually, 

508
00:22:06,410 --> 00:22:07,920
the way you sort of look like this, 

509
00:22:07,930 --> 00:22:10,800
if you actually have an instance of this, 

510
00:22:11,490 --> 00:22:11,530
right? 

511
00:22:11,540 --> 00:22:13,170
You have supplier supplies of parts, 

512
00:22:13,690 --> 00:22:16,750
and then you would have these auxiliary tables

513
00:22:16,760 --> 00:22:18,510
and basically cross reference tables you would have, 

514
00:22:19,160 --> 00:22:24,540
or you keep pointers to the actual objects. 

515
00:22:25,070 --> 00:22:26,520
And so these red lines i'm drawing here. 

516
00:22:26,530 --> 00:22:29,540
These are actually pointers like physical pointers to like, 

517
00:22:29,550 --> 00:22:32,880
here's the location of this record on disk or in memory. 

518
00:22:34,140 --> 00:22:34,540
Right? 

519
00:22:35,230 --> 00:22:35,730
Again. 

520
00:22:35,740 --> 00:22:37,770
So now, when you get your looping through,

521
00:22:39,100 --> 00:22:41,170
try to find all the suppliers apply a certain part. 

522
00:22:41,700 --> 00:22:42,940
You'd have to look at the first one, 

523
00:22:42,950 --> 00:22:47,040
and then you do a look up to find the record in this entity. 

524
00:22:47,050 --> 00:22:48,720
And i'm going to call it a table because it's not. 

525
00:22:49,740 --> 00:22:51,700
And then you would follow the pointer to jump here. 

526
00:22:52,140 --> 00:22:52,740
And then potentially, 

527
00:22:52,750 --> 00:22:54,620
you could have a pointer to go back in the other direction. 

528
00:22:55,740 --> 00:22:56,060
Right? 

529
00:22:57,530 --> 00:23:00,430
So the queries are very complex, right?

530
00:23:00,440 --> 00:23:01,910
This is all written in cobalt. 

531
00:23:03,350 --> 00:23:06,850
And it was less efficient because again, 

532
00:23:06,980 --> 00:23:08,690
you're operating over a single tuple at a time. 

533
00:23:09,690 --> 00:23:10,600
It was easily corruptible. 

534
00:23:10,610 --> 00:23:13,680
So if this thing gets if this the harbor is crappy back, 

535
00:23:13,690 --> 00:23:18,010
then this supplies or supplied by these collections of data, 

536
00:23:18,020 --> 00:23:18,690
these pointers. 

537
00:23:19,020 --> 00:23:20,400
If this thing gets corrupted, 

538
00:23:20,410 --> 00:23:21,560
your whole database is host, 

539
00:23:21,570 --> 00:23:24,660
because now you have no way to to traverse and find things, 

540
00:23:25,670 --> 00:23:28,340
understand the relationships between these objects. 

541
00:23:28,350 --> 00:23:31,660
All right. 

542
00:23:31,670 --> 00:23:35,850
So the next big system that was in the 1960s was this thing called ims

543
00:23:36,390 --> 00:23:38,400
and this actually was built for the apollo moon mission. 

544
00:23:38,570 --> 00:23:42,260
Ibm was responsible for the building out of database to keep track

545
00:23:42,270 --> 00:23:44,340
of all the parts they were. 

546
00:23:44,350 --> 00:23:46,480
Nasa was buying to build the rockets. 

547
00:23:47,330 --> 00:23:47,680
And again, 

548
00:23:47,690 --> 00:23:51,870
just like for ge and is they built a sort of custom database system

549
00:23:51,880 --> 00:23:55,110
for the project and then realized it was useful for other customers, 

550
00:23:55,630 --> 00:23:57,090
and they spun it out as a separate product. 

551
00:23:57,620 --> 00:23:58,940
This thing still exists today. 

552
00:23:59,170 --> 00:24:02,230
And ibm makes a ton of money on these things. 

553
00:24:02,240 --> 00:24:03,470
And this data has been till today. 

554
00:24:04,970 --> 00:24:07,350
If you ever used an atm machine or anything in the bank, 

555
00:24:07,360 --> 00:24:10,760
a lot of them are still using ims as they set up in the 70s. 

556
00:24:11,200 --> 00:24:11,880
If it's not broken, 

557
00:24:12,410 --> 00:24:12,960
don't fix it. 

558
00:24:15,770 --> 00:24:18,190
Ims is going to use what's called a hierarchical data model. 

559
00:24:19,880 --> 00:24:23,420
And just like the network data model is going to use a tube out of time queries. 

560
00:24:23,970 --> 00:24:27,210
Then another big thing is that it's going to support a programmer to find

561
00:24:27,800 --> 00:24:28,900
physical data structures, 

562
00:24:30,010 --> 00:24:32,270
meaning like if I have a collection of data like a table, 

563
00:24:32,960 --> 00:24:34,550
I don't use your table because they wouldn't call it that, 

564
00:24:34,560 --> 00:24:35,390
but assume it's a table. 

565
00:24:36,250 --> 00:24:37,640
I would actually tell the database system. 

566
00:24:37,650 --> 00:24:38,840
I want to store it as a hash table, 

567
00:24:38,850 --> 00:24:40,280
or I want to store it as ab plus tree. 

568
00:24:41,360 --> 00:24:42,870
Then based on what I told it, 

569
00:24:42,880 --> 00:24:45,350
I wanted to store it as you then got a different api that allowed you

570
00:24:45,360 --> 00:24:46,190
traversing the data, 

571
00:24:47,000 --> 00:24:48,780
because you can't do range queries and hash tables, 

572
00:24:48,790 --> 00:24:50,140
but you can't do it on b plus trees. 

573
00:24:52,460 --> 00:24:53,530
Go back to our example here. 

574
00:24:54,760 --> 00:24:55,810
We have a supplier now. 

575
00:24:57,600 --> 00:24:59,790
I'm an idiot because this i'm leaving plug of a clicker in. 

576
00:25:01,280 --> 00:25:01,870
That's pathetic. 

577
00:25:02,760 --> 00:25:02,870
Right? 

578
00:25:02,880 --> 00:25:04,070
So I have a supplier. 

579
00:25:04,590 --> 00:25:08,680
And now they have parts that looks a little bit better, right?

580
00:25:08,690 --> 00:25:10,400
Because now I don't have to have all this extra stuff. 

581
00:25:12,340 --> 00:25:12,570
Now, 

582
00:25:12,580 --> 00:25:16,390
but I do have an implicit relationship between explicit relation

583
00:25:16,400 --> 00:25:17,890
between the supplier and the part. 

584
00:25:18,550 --> 00:25:21,880
A part can only supply by one particular supplier. 

585
00:25:23,480 --> 00:25:24,720
Right now, if I go to my instance,

586
00:25:26,090 --> 00:25:26,440
right? 

587
00:25:26,810 --> 00:25:29,450
Say this first vendor, 

588
00:25:29,980 --> 00:25:31,040
they supply batteries. 

589
00:25:31,050 --> 00:25:32,680
I would have to have another whole record for that. 

590
00:25:33,300 --> 00:25:36,410
And then I would have to have another record for the second vendor

591
00:25:36,420 --> 00:25:37,730
who's playing maybe the same batteries, 

592
00:25:37,740 --> 00:25:38,570
but a different price. 

593
00:25:39,990 --> 00:25:47,000
So let's say now if I change the name of the of the part from batteries to

594
00:25:47,330 --> 00:25:49,200
on a brand name battery, 

595
00:25:49,210 --> 00:25:51,510
whatever I want to change this field here, 

596
00:25:51,850 --> 00:25:55,930
i've got to go through and change every single record instance

597
00:25:55,940 --> 00:25:59,210
of where the batteries exist. 

598
00:26:00,440 --> 00:26:03,030
Because you were basically repeating information because you couldn't have

599
00:26:03,440 --> 00:26:07,020
one part be supplied by multiple suppliers in this model. 

600
00:26:10,140 --> 00:26:11,960
The other problem you're going to have, also, too, is,

601
00:26:11,970 --> 00:26:13,010
as I said about the, 

602
00:26:13,860 --> 00:26:17,200
since the system exposes the the ability to tell how you

603
00:26:17,210 --> 00:26:18,360
actually want to store data, 

604
00:26:18,370 --> 00:26:20,000
a hash table versus b cluster or whatever, 

605
00:26:20,710 --> 00:26:23,860
then if I changed my mind and I said I sorted the hash table, 

606
00:26:24,050 --> 00:26:25,300
but I want to do range queries. 

607
00:26:25,490 --> 00:26:27,860
Let me switch it to ab plus tree. 

608
00:26:28,930 --> 00:26:30,690
You had no way of easily changing that. 

609
00:26:30,700 --> 00:26:32,770
You had to actually dump the data out, 

610
00:26:33,230 --> 00:26:36,050
then load it back under the new data structure. 

611
00:26:36,940 --> 00:26:40,300
Then you actually have to go update your application code, 

612
00:26:40,740 --> 00:26:43,690
because now it expose the hash the b plus gapi instead of the hash table

613
00:26:43,700 --> 00:26:46,890
api there's no independence between the physical layer

614
00:26:46,900 --> 00:26:49,050
and the logical layer what the data actually was. 

615
00:26:53,280 --> 00:26:54,780
All this is sort of the, yes,

616
00:27:02,480 --> 00:27:09,140
the system didn't support it with ims now in like twenty, 2003.

617
00:27:09,560 --> 00:27:14,230
I I ai think they have asql veneer on top of it. 

618
00:27:15,350 --> 00:27:15,580
Right? 

619
00:27:15,590 --> 00:27:19,260
And ii think it still is a hard come on an e there was attempts to convert

620
00:27:19,270 --> 00:27:23,870
it to racial model in the 80s rented pin out. 

621
00:27:24,310 --> 00:27:25,950
But I this is like 1960s. 

622
00:27:25,960 --> 00:27:26,390
This is the way. 

623
00:27:26,880 --> 00:27:32,030
So this is the motivation for the relational model. 

624
00:27:34,540 --> 00:27:35,580
In the late 1960s, 

625
00:27:36,040 --> 00:27:39,780
there's this guy ted cod, who just finished his phd in math.

626
00:27:40,430 --> 00:27:42,200
He was working in ibm research, 

627
00:27:42,210 --> 00:27:46,480
and he saw all of these ims programmers spending a lot of time rewriting

628
00:27:46,490 --> 00:27:48,120
for application code over and over again, 

629
00:27:48,400 --> 00:27:50,090
because of this tight coupling between, 

630
00:27:50,890 --> 00:27:52,750
again, the physical layer and the logical layer.

631
00:27:54,930 --> 00:27:56,950
And so then he realized that, 

632
00:27:57,610 --> 00:28:00,810
which is actually quite prescient that this is not scalable. 

633
00:28:01,440 --> 00:28:03,930
Humans at some point, it could be way more expensive than computers.

634
00:28:04,460 --> 00:28:06,550
At the time computers are super expensive, humans are cheap.

635
00:28:07,190 --> 00:28:08,170
The opposite now, right?

636
00:28:08,180 --> 00:28:09,450
I can get an amazon instance, 

637
00:28:09,460 --> 00:28:11,950
a fraction of a penny an hour, 

638
00:28:12,720 --> 00:28:18,520
but a program is going to cost me 200 k how happens? 

639
00:28:19,630 --> 00:28:21,360
Just continue lecture, 

640
00:28:21,370 --> 00:28:23,100
not that one. 

641
00:28:23,110 --> 00:28:23,680
What? 

642
00:28:23,690 --> 00:28:25,360
Now i'm curious, 

643
00:28:28,380 --> 00:28:28,970
I don't know. 

644
00:28:30,980 --> 00:28:34,810
Are you laughing at the 200 k for database programmer? 

645
00:28:34,820 --> 00:28:35,370
That's a bit low? 

646
00:28:42,150 --> 00:28:43,920
Anyway, data programs aren't cheap,

647
00:28:46,290 --> 00:28:47,590
but at the time it was slept, 

648
00:28:47,970 --> 00:28:50,360
he saw all these people wasting their time over again, 

649
00:28:50,370 --> 00:28:51,640
rewriting the application. 

650
00:28:52,740 --> 00:28:55,570
They saw the inefficiency of having this sort of two po at a time

651
00:28:55,580 --> 00:29:02,270
programming api the relational model has sort of three key parts to it, 

652
00:29:03,390 --> 00:29:03,860
that again, 

653
00:29:03,870 --> 00:29:07,620
it serves as the background for all the racial modern racial data systems today. 

654
00:29:08,740 --> 00:29:09,490
The first of that, 

655
00:29:09,500 --> 00:29:11,590
we're going to store the database in simple data structures

656
00:29:11,810 --> 00:29:15,180
instead of this graph in the coder cell network model, 

657
00:29:15,520 --> 00:29:20,280
or this hierarchy under ims we're going to store tables relations. 

658
00:29:20,290 --> 00:29:22,050
So these single heap things. 

659
00:29:22,870 --> 00:29:29,440
And if they have relations or if there are references to other tables, 

660
00:29:29,450 --> 00:29:32,360
we just store that as again as another attribute in their relations. 

661
00:29:32,770 --> 00:29:32,920
Right? 

662
00:29:32,930 --> 00:29:34,880
No need to have explicit pointers to anything. 

663
00:29:36,320 --> 00:29:39,600
The program is the way we're going to access the database

664
00:29:39,610 --> 00:29:40,680
through a high level language. 

665
00:29:41,520 --> 00:29:42,820
Instead of writing these nested for loops, 

666
00:29:42,830 --> 00:29:46,420
they'll be able to say he didn't vent sequel at the time, 

667
00:29:46,430 --> 00:29:47,490
but I sorry, 

668
00:29:47,500 --> 00:29:49,290
there was not a programming language like siegel at the time, 

669
00:29:49,300 --> 00:29:50,850
but he had this idea like, ok,

670
00:29:51,210 --> 00:29:55,830
there's a way to abstract what the actual physical materialization

671
00:29:55,840 --> 00:29:57,470
of the physical structure of the database system. 

672
00:29:57,480 --> 00:29:59,030
And to say this is the answer I want. 

673
00:29:59,550 --> 00:30:01,140
And then a data system could figure it out for you. 

674
00:30:02,390 --> 00:30:02,710
Right? 

675
00:30:02,720 --> 00:30:05,350
And then this also now means that because I have this abstraction

676
00:30:05,360 --> 00:30:06,830
between the physical layer and the logical layer, 

677
00:30:07,320 --> 00:30:11,210
the the strategy just stored the data physically on disk or in memory, 

678
00:30:11,640 --> 00:30:13,450
we left entirely up to the implementation. 

679
00:30:14,410 --> 00:30:16,480
Because based on what the queries wanted to do, 

680
00:30:16,990 --> 00:30:19,310
it could decide here's the best way to store your data. 

681
00:30:21,020 --> 00:30:21,170
Right? 

682
00:30:21,340 --> 00:30:24,570
The first paper on the racial model came out in 1969. 

683
00:30:25,590 --> 00:30:27,140
This is the very first one. 

684
00:30:28,200 --> 00:30:31,010
This is usually the one everyone cites as the

685
00:30:31,540 --> 00:30:35,570
as the de facto relational model paper that this came out in the cacm

686
00:30:35,580 --> 00:30:36,450
in 1970. 

687
00:30:36,810 --> 00:30:37,990
But this was the very first one. 

688
00:30:39,410 --> 00:30:42,750
We go back to our example before suppliers and supplies and parts. 

689
00:30:43,430 --> 00:30:43,690
Right? 

690
00:30:43,700 --> 00:30:44,730
It looks like this. 

691
00:30:45,280 --> 00:30:47,200
It's essentially what the network model was, 

692
00:30:47,210 --> 00:30:50,570
but now I don't have these explicit membership sets. 

693
00:30:52,140 --> 00:30:55,450
Then now if I want to sort of in a table or in tables in a relational database, 

694
00:30:56,370 --> 00:30:56,620
right now, 

695
00:30:56,630 --> 00:31:01,340
I have these foreign key references that are just attributes in the object. 

696
00:31:01,870 --> 00:31:08,000
And the data system can understand that this supplier number corresponds

697
00:31:08,010 --> 00:31:11,010
to some supplier number in this other table here. 

698
00:31:14,840 --> 00:31:15,870
We'll get to c equal to second, 

699
00:31:15,880 --> 00:31:17,150
but this was a radical idea. 

700
00:31:17,540 --> 00:31:18,740
A sequel is a radical idea. 

701
00:31:20,410 --> 00:31:24,830
Now we take it for granted because it's so prevalent, 

702
00:31:24,840 --> 00:31:32,290
but back then the criticism of the relational model was there's no way

703
00:31:32,300 --> 00:31:34,810
a database of no way a piece of software. 

704
00:31:34,820 --> 00:31:38,500
It's going to write queries as efficient as what a human can write. 

705
00:31:40,030 --> 00:31:41,660
This seems sort of strange, 

706
00:31:41,670 --> 00:31:44,020
but it's sort of the same argument that people made back in the day, 

707
00:31:44,480 --> 00:31:47,790
that there's no way a compiler could generate program code that is

708
00:31:47,800 --> 00:31:49,520
more efficient than what a human could write. 

709
00:31:49,530 --> 00:31:54,470
Sure that's potentially true for like highly skilled and embedded systems programmers. 

710
00:31:54,710 --> 00:31:55,950
But nobody writes assembly today. 

711
00:31:56,480 --> 00:31:56,800
Right? 

712
00:31:57,570 --> 00:32:02,050
Everybody writes in higher level languages and even higher like up in python. 

713
00:32:02,490 --> 00:32:02,860
Right? 

714
00:32:05,730 --> 00:32:08,370
But back then, again, this is like the sea compiler came out in 1970.

715
00:32:08,660 --> 00:32:12,920
This was an insane idea and turned out it was correct. 

716
00:32:13,850 --> 00:32:17,400
The depends on the implementation of the query optimizer, how good it is.

717
00:32:17,730 --> 00:32:20,570
And we'll see some papers that show how things go wrong. 

718
00:32:21,570 --> 00:32:23,490
And that's certainly a hard problem. 

719
00:32:23,500 --> 00:32:24,370
But in general, 

720
00:32:24,380 --> 00:32:27,600
like a database system is going to generate a more efficient query plan

721
00:32:27,610 --> 00:32:29,000
than an average programmer could actually write. 

722
00:32:29,590 --> 00:32:29,880
And also, 

723
00:32:29,890 --> 00:32:32,680
now it exposes the data system to people that are maybe art programmers, 

724
00:32:33,320 --> 00:32:36,600
like business analysts or people doing accounting reporting, right?

725
00:32:36,610 --> 00:32:38,120
But they are not hardcore programmers. 

726
00:32:38,560 --> 00:32:41,840
They can write sql, but maybe not can't write any cc plus.

727
00:32:44,830 --> 00:32:47,790
So ted cod put out the paper in 1970. 

728
00:32:48,820 --> 00:32:49,810
He was a mathematician, 

729
00:32:53,300 --> 00:32:55,990
this paper here, it's actually not the hard to read.

730
00:32:57,270 --> 00:33:00,160
But when you read the criticisms of it or people talk about it at the time

731
00:33:00,630 --> 00:33:01,950
contemporary conversations about it, 

732
00:33:02,310 --> 00:33:03,770
people say it was inscrutable. 

733
00:33:04,020 --> 00:33:05,690
It was told was heavy on math, 

734
00:33:06,790 --> 00:33:07,180
not. 

735
00:33:07,570 --> 00:33:09,650
But again, maybe 1970s, I don't know, maybe it was.

736
00:33:11,160 --> 00:33:14,460
He didn't propose a programming language in that paper. 

737
00:33:14,470 --> 00:33:16,530
He later did in 1974, 75,

738
00:33:16,540 --> 00:33:19,320
this thing called alpha didn't go anywhere. 

739
00:33:19,640 --> 00:33:20,810
But it was all math at the time. 

740
00:33:21,750 --> 00:33:25,350
And he didn't actually build a system to prove that his idea was working

741
00:33:25,830 --> 00:33:26,240
could work. 

742
00:33:27,310 --> 00:33:30,040
What happened was there was a bunch of people saw his paper, 

743
00:33:30,460 --> 00:33:30,720
said, hey,

744
00:33:30,730 --> 00:33:33,210
I think this is a good idea and actually started building

745
00:33:33,220 --> 00:33:34,930
experimental systems to test that out. 

746
00:33:36,380 --> 00:33:39,570
The very first system that i'm aware of that did was this thing called

747
00:33:39,580 --> 00:33:41,330
the peter lee relational test vehicle, 

748
00:33:41,720 --> 00:33:43,470
which sounds like a 1970s, like druggie ban.

749
00:33:44,740 --> 00:33:47,990
But these are like people in the uk that basically read his paper, like,

750
00:33:48,040 --> 00:33:48,910
I think it's a good idea. 

751
00:33:49,210 --> 00:33:52,250
And they built sort of early prototypes from four sequel. 

752
00:33:52,570 --> 00:33:53,280
It they talk about, 

753
00:33:53,290 --> 00:33:56,340
it could store massive data sets of like 1,002 poles like that was mind

754
00:33:56,350 --> 00:33:57,300
blowing for them back of them. 

755
00:33:59,260 --> 00:34:00,410
That one usually people forget about. 

756
00:34:00,420 --> 00:34:01,930
That's far as I know, that's the very first one.

757
00:34:02,610 --> 00:34:09,000
But there's two other projects that came1 or 2 years after system are at

758
00:34:09,010 --> 00:34:10,800
ibm and then ingress at berkeley. 

759
00:34:11,300 --> 00:34:15,880
These are considered the very first to relational data systems that

760
00:34:15,890 --> 00:34:19,160
like try to or try to build something based on ted cards work

761
00:34:19,170 --> 00:34:20,760
and actually build a real system. 

762
00:34:21,270 --> 00:34:23,420
I think mimer sequel came out at a sweden, 

763
00:34:23,850 --> 00:34:25,380
maybe a 1 or 2 years later, 

764
00:34:25,990 --> 00:34:27,530
but this is an act on a project. 

765
00:34:27,540 --> 00:34:28,610
This still exists today. 

766
00:34:29,410 --> 00:34:31,240
Oracle with larry ellison, we know about that.

767
00:34:31,930 --> 00:34:33,700
And we'll cover that throughout the semester. 

768
00:34:34,440 --> 00:34:35,150
Basically, 

769
00:34:36,810 --> 00:34:40,620
the it's all happening in silicon valley. 

770
00:34:40,630 --> 00:34:42,510
Larry elsin basically copy what ibm did. 

771
00:34:42,880 --> 00:34:44,910
He would literally call them on the phone and ask about like, 

772
00:34:45,400 --> 00:34:45,910
how does this work? 

773
00:34:45,920 --> 00:34:47,910
And they would tell them because they were researchers didn't know, 

774
00:34:48,130 --> 00:34:49,300
and he went and copied it. 

775
00:34:50,950 --> 00:34:55,100
And then ingress eventually got commercialized at the university

776
00:34:55,580 --> 00:34:56,250
in the late 70s, 

777
00:34:56,260 --> 00:34:58,690
because people actually started really using it because they understood

778
00:34:58,700 --> 00:35:00,750
the the certificates of the racial model. 

779
00:35:02,220 --> 00:35:05,440
But again, 1970s, it was not clear that it could have been coda, still,

780
00:35:05,450 --> 00:35:06,770
it could have been a relational model. 

781
00:35:07,870 --> 00:35:10,320
Eventually in the 1980s, relational model, one,

782
00:35:13,330 --> 00:35:14,510
two things happened, three things happened.

783
00:35:15,210 --> 00:35:20,570
First is that ibm never commercialized system are they could have been

784
00:35:20,580 --> 00:35:23,490
a dominant player in the and they do this marketplace, 

785
00:35:23,500 --> 00:35:27,660
but they drop the baldness because they were making so much money on ims like, 

786
00:35:27,670 --> 00:35:30,530
why would you kill the golden goose with this other new data system that

787
00:35:30,540 --> 00:35:34,170
may not work when you're making so much money on ims but eventually they

788
00:35:34,180 --> 00:35:35,370
saw the light and they put out their

789
00:35:35,380 --> 00:35:39,510
first relational database system called segal ds in 1981, 

790
00:35:39,790 --> 00:35:43,840
this had remnants of system r but a lot of it was written from scratch. 

791
00:35:44,940 --> 00:35:45,730
Sequel. 

792
00:35:45,740 --> 00:35:46,610
Ds is still around. 

793
00:35:46,620 --> 00:35:48,090
They renamed it to db two, 

794
00:35:48,420 --> 00:35:57,370
just like dv two for vse there's some like mainframe system that they wrote

795
00:35:57,380 --> 00:35:58,210
sql ds four. 

796
00:35:58,650 --> 00:36:00,120
There's five versions of db two. 

797
00:36:00,130 --> 00:36:01,840
It's hard to track of them. 

798
00:36:02,680 --> 00:36:06,670
But then what we know about what we consider db two today, 

799
00:36:07,090 --> 00:36:08,720
that first came out in 1983. 

800
00:36:09,280 --> 00:36:10,670
When this came out 83, 

801
00:36:11,040 --> 00:36:13,790
this is sort of the shot across the bow in the database industry to say, 

802
00:36:14,160 --> 00:36:15,550
now ibm series by the relational model. 

803
00:36:15,560 --> 00:36:17,310
These is a real idea. 

804
00:36:17,870 --> 00:36:20,090
Ingress and oracle are already still in the marketplace. 

805
00:36:20,510 --> 00:36:22,920
But it basically showed that the relation model is the way forward. 

806
00:36:23,520 --> 00:36:29,140
And sequel became the defective standard when this came out in 83. 

807
00:36:29,990 --> 00:36:31,600
And oracle was at the right place at the right time, 

808
00:36:31,610 --> 00:36:35,930
because I when ibm ibm was not going to say they were the juggernaut

809
00:36:35,940 --> 00:36:36,810
in the commuting industry. 

810
00:36:36,820 --> 00:36:38,370
So they said, hey, this is the way it's going to be.

811
00:36:38,950 --> 00:36:39,950
This is the language we're going to use. 

812
00:36:39,960 --> 00:36:42,390
Everyone said that ibm says that's what I do. 

813
00:36:42,810 --> 00:36:44,750
When oracle was there, we say, hey, we already support sequel.

814
00:36:44,760 --> 00:36:45,630
We're going to go. 

815
00:36:46,080 --> 00:36:48,120
Ingress had its own programming language called quell. 

816
00:36:48,690 --> 00:36:52,010
That strong breaker still claims is better than sql. 

817
00:36:52,830 --> 00:36:54,090
They eventually supported sequel, 

818
00:36:54,100 --> 00:36:57,180
but it was by the time they added it, it was too late.

819
00:36:58,640 --> 00:37:03,760
So sequel reasonably spelled as seqeul because it's supposed to be

820
00:37:03,770 --> 00:37:04,480
the sequel to quell. 

821
00:37:05,000 --> 00:37:05,380
Right? 

822
00:37:05,660 --> 00:37:06,750
To play on words, 

823
00:37:07,090 --> 00:37:09,080
then they got sued for trademark enrichment, 

824
00:37:09,090 --> 00:37:14,500
so then they renamed it to sql and then there was a standard body to figure

825
00:37:14,510 --> 00:37:17,020
out what should be the programming language we use

826
00:37:19,080 --> 00:37:20,270
for relational databases. 

827
00:37:21,920 --> 00:37:24,020
And supposedly they were going to use quell, 

828
00:37:24,730 --> 00:37:25,430
set a sequel, 

829
00:37:26,170 --> 00:37:30,830
but dome breaker didn't like standards bodies and decided not to submit

830
00:37:30,840 --> 00:37:31,990
any paperwork for quell. 

831
00:37:32,900 --> 00:37:35,970
So there's this paragraph here from the larry ellison. 

832
00:37:36,930 --> 00:37:37,850
Unauthorized biography. 

833
00:37:37,860 --> 00:37:38,970
I don't want you to recall it, 

834
00:37:39,460 --> 00:37:41,750
but it came out in the late 90s where they basically talked about how they

835
00:37:41,760 --> 00:37:43,600
thought quell was better than sql, 

836
00:37:43,770 --> 00:37:45,930
but mike hated standards body. 

837
00:37:45,940 --> 00:37:46,970
So he didn't submit anything. 

838
00:37:48,040 --> 00:37:48,230
Anyway. 

839
00:37:48,940 --> 00:37:50,950
So that's why we end up with a sequel instead of quell. 

840
00:37:52,570 --> 00:37:56,950
Does this one on hacker news occasionally see like people say, hey,

841
00:37:56,960 --> 00:37:59,460
i've better the new version of sequel or better version of a sequel. 

842
00:37:59,970 --> 00:38:03,670
And they a lot of the things they end up fixing the problems with in sequel

843
00:38:03,680 --> 00:38:07,070
like having the front claws after the select clause like quell. 

844
00:38:07,470 --> 00:38:08,540
Already did that in the 70s. 

845
00:38:10,020 --> 00:38:11,090
But we ended up with a sequel. 

846
00:38:11,890 --> 00:38:12,170
Sorry. 

847
00:38:15,670 --> 00:38:15,890
Right? 

848
00:38:15,900 --> 00:38:19,730
So oracle basically wins the crown during the 1980s. 

849
00:38:19,930 --> 00:38:23,480
There's a bunch of other startups that come along that do relation databases. 

850
00:38:23,870 --> 00:38:25,450
Psi based on formics interface, 

851
00:38:25,780 --> 00:38:28,090
terror data was a data warehouse tandem got bought by deck. 

852
00:38:29,050 --> 00:38:32,510
Basically, the only one that's still thriving today, I would say,

853
00:38:32,520 --> 00:38:36,600
is oracle and db two and thriving is not the right word I all these

854
00:38:36,610 --> 00:38:38,320
like psi based still makes a ton of money. 

855
00:38:38,630 --> 00:38:40,220
But again, if you're a new start up a new company,

856
00:38:40,230 --> 00:38:43,360
you wouldn't use it a lot of these systems are still arrayed maintenance mode, 

857
00:38:45,780 --> 00:38:47,300
but oracle is being actively loved, 

858
00:38:47,310 --> 00:38:56,430
and then same with db two tear data is they're getting crushed by snowflake. 

859
00:38:57,980 --> 00:38:59,510
So stone breaker, 

860
00:39:00,160 --> 00:39:01,550
he commercialized his ingress, 

861
00:39:01,870 --> 00:39:04,140
goes back to berkeley, starts a new day system called postgress.

862
00:39:04,150 --> 00:39:07,470
If you're the one I postgress is called postgres because it's post ingress. 

863
00:39:07,990 --> 00:39:09,400
It's the sense that he built after ingress. 

864
00:39:11,280 --> 00:39:13,370
And instead of being a relational data system, 

865
00:39:13,860 --> 00:39:15,850
he called this thing as an object relational database system. 

866
00:39:16,800 --> 00:39:18,960
Because object oriented program was the hot thing in the 1980s. 

867
00:39:19,650 --> 00:39:22,800
And this is why they postcards were designed for the very

868
00:39:22,810 --> 00:39:24,160
beginning to be very extensible. 

869
00:39:24,700 --> 00:39:27,180
You can have user defined types, user defined functions, and so forth,

870
00:39:27,580 --> 00:39:32,780
because they wanted to borrow some of the ideas of object oriented databases, 

871
00:39:32,790 --> 00:39:36,200
which would be the next slide and be able to extend postcards very easily. 

872
00:39:38,290 --> 00:39:39,480
Even today, technically,

873
00:39:39,490 --> 00:39:41,480
postcards is an object based on database system. 

874
00:39:42,470 --> 00:39:43,860
People mostly ignore this part, 

875
00:39:43,870 --> 00:39:45,010
the object part. 

876
00:39:47,590 --> 00:39:48,390
Where are we at so far? 

877
00:39:48,740 --> 00:39:49,780
1970s, kodaso?

878
00:39:50,720 --> 00:39:55,180
Is there cobalt that the cobalt way to program davis is their glacial model

879
00:39:55,190 --> 00:39:55,700
comes out? 

880
00:39:55,990 --> 00:39:57,420
People say hit is the bad idea. 

881
00:39:57,790 --> 00:39:59,060
Coda cell is the right way to do it, 

882
00:39:59,310 --> 00:40:00,570
especially where some model wins. 

883
00:40:01,350 --> 00:40:04,110
And there's all these ways from davis has come out in the 1980s, 

884
00:40:04,840 --> 00:40:05,630
early 1980s, 

885
00:40:06,410 --> 00:40:07,450
10 years later after that, 

886
00:40:07,460 --> 00:40:09,450
then we end up with these object, ordinary databases.

887
00:40:10,080 --> 00:40:12,150
And what i'm saying where people come along every 10 years and say, 

888
00:40:12,550 --> 00:40:13,350
I have a better idea. 

889
00:40:14,320 --> 00:40:15,310
In the 1980s, 

890
00:40:15,920 --> 00:40:19,030
people recognize that if application available is going to use

891
00:40:19,040 --> 00:40:20,630
an object oriented programming language. 

892
00:40:21,120 --> 00:40:23,690
Like c plus is the hot thing in the late 1980s, 

893
00:40:25,680 --> 00:40:28,100
that there was this impedance mismatch, 

894
00:40:28,110 --> 00:40:33,490
where the way the database system represented data as relations did not map

895
00:40:33,500 --> 00:40:37,090
cleanly into how objects or object oriented programming represented data. 

896
00:40:38,260 --> 00:40:41,790
So you'd have to write these sql queries that would basically convert rows

897
00:40:41,800 --> 00:40:42,870
into now objects, 

898
00:40:43,490 --> 00:40:44,270
sort of nested hierarchies. 

899
00:40:45,220 --> 00:40:47,420
And so a bunch of companies said this is kind of stupid. 

900
00:40:47,430 --> 00:40:50,630
Would it be distorted the objects directly in the database as objects? 

901
00:40:52,370 --> 00:40:54,880
There's a couple of systems, versant objects or 02.

902
00:40:54,890 --> 00:40:58,590
I think mark logic you actually just got bought a few weeks ago, 

903
00:40:59,890 --> 00:41:02,280
but they were late 90s. 

904
00:41:03,890 --> 00:41:07,210
And so a bunch of these systems don't exist anymore again. 

905
00:41:07,220 --> 00:41:08,210
Are there a maintenance mode? 

906
00:41:08,760 --> 00:41:13,940
The what killed him was that there was no standard query language you

907
00:41:13,950 --> 00:41:16,240
could use for object oriented databases. 

908
00:41:16,500 --> 00:41:19,210
Eventually, they propose oql the object query language,

909
00:41:19,220 --> 00:41:20,450
but nobody supported that. 

910
00:41:20,460 --> 00:41:21,250
It was too late. 

911
00:41:22,340 --> 00:41:22,650
Basically, 

912
00:41:22,660 --> 00:41:24,570
the problem was because you had this tight coupling

913
00:41:24,580 --> 00:41:26,490
between the database system and the programming language. 

914
00:41:28,360 --> 00:41:29,520
It made your application less portable. 

915
00:41:29,530 --> 00:41:32,880
It wasn't very easy for you to switch to another object oriented database system, 

916
00:41:32,890 --> 00:41:37,320
because you were writing to their proprietary api similar to how ims

917
00:41:37,330 --> 00:41:40,980
exposed a proprietor api to their internal data structures. 

918
00:41:43,150 --> 00:41:48,480
So now sequel is supposed to be a standard course for basic queries. 

919
00:41:48,730 --> 00:41:50,640
You can easily switch them from monday to such another. 

920
00:41:52,300 --> 00:41:54,210
Every bidder has the realm of proprietary extensions. 

921
00:41:54,750 --> 00:41:55,810
So even though there is a standard, 

922
00:41:57,910 --> 00:41:58,430
it isn't, 

923
00:42:00,350 --> 00:42:02,340
there isn't a universal standard that everyone follows. 

924
00:42:04,200 --> 00:42:06,690
So you can make the same argument about sequel today. 

925
00:42:07,210 --> 00:42:08,650
Or m's hide a lot of this. 

926
00:42:12,140 --> 00:42:12,760
Here's what it looks like. 

927
00:42:12,890 --> 00:42:13,200
Say. 

928
00:42:13,210 --> 00:42:15,240
We have a application code. 

929
00:42:15,250 --> 00:42:16,680
We want to store student information. 

930
00:42:17,240 --> 00:42:20,150
The student has an ida name, an email address,

931
00:42:20,600 --> 00:42:22,930
and then a potential list of phone numbers. 

932
00:42:24,340 --> 00:42:27,690
The way you would represent potentially represent this

933
00:42:28,340 --> 00:42:29,730
in a pure relational model, 

934
00:42:30,350 --> 00:42:32,080
meaning where there's only scalar values. 

935
00:42:32,350 --> 00:42:35,320
You'd have to have a student table, 

936
00:42:35,640 --> 00:42:37,030
and then a student phone table. 

937
00:42:38,700 --> 00:42:40,610
So that now, if I want in my programming language,

938
00:42:40,620 --> 00:42:42,210
if I want to instantiate this object, 

939
00:42:42,850 --> 00:42:48,860
I would have to do a look up where I either first query the the student

940
00:42:48,870 --> 00:42:50,460
and then do a second query to go get all the phone

941
00:42:50,470 --> 00:42:53,610
numbers or do a join and then make sure I throw

942
00:42:53,620 --> 00:42:56,730
away the the redundant student information. 

943
00:42:56,900 --> 00:42:58,170
I when I give the result back. 

944
00:43:00,350 --> 00:43:02,860
Again, the object oriented basis guy would say this is stupid,

945
00:43:02,870 --> 00:43:03,620
object oriented. 

946
00:43:03,630 --> 00:43:04,700
People say this is stupid. 

947
00:43:05,240 --> 00:43:10,840
Just store the the nested objects together in a single record. 

948
00:43:11,360 --> 00:43:15,310
And now it's only one fetch to the davis as one read call to go bring

949
00:43:15,320 --> 00:43:15,910
this data in. 

950
00:43:18,940 --> 00:43:20,190
So the problem with this, though,

951
00:43:20,200 --> 00:43:22,970
is for a simple example, 

952
00:43:22,980 --> 00:43:24,650
there's like a 1 to 1 correspondence routine, 

953
00:43:25,150 --> 00:43:28,340
a student phone number, and the student sure this is probably fine.

954
00:43:29,040 --> 00:43:29,400
In fact, 

955
00:43:29,970 --> 00:43:31,440
in modern relations data systems, 

956
00:43:31,450 --> 00:43:33,400
you could store the phone number as an array of strings. 

957
00:43:34,230 --> 00:43:35,440
Most systems will support that. 

958
00:43:36,440 --> 00:43:39,570
The trouble is now when you go back to that part supplier issue, 

959
00:43:39,580 --> 00:43:45,540
if you now start embedding or de normalizing the all the parts

960
00:43:45,550 --> 00:43:48,380
that a supplier supplies and put them into the supplier record, 

961
00:43:49,000 --> 00:43:49,710
then I have that problem. 

962
00:43:49,720 --> 00:43:50,790
Or if I need an updated field, 

963
00:43:50,800 --> 00:43:51,990
I have duplicate information. 

964
00:43:52,330 --> 00:43:54,720
My application code needs to make sure all that's in sync. 

965
00:43:55,620 --> 00:43:59,050
I I I don't update some of the records, but not all of them.

966
00:44:01,650 --> 00:44:02,880
Doing complex joins, 

967
00:44:03,890 --> 00:44:06,340
make sure you have data integrity, 

968
00:44:06,780 --> 00:44:09,290
becomes problematic in in this approach. 

969
00:44:10,180 --> 00:44:12,150
And i'm saying there's some cases where you do want to store jason. 

970
00:44:12,160 --> 00:44:12,710
And again, 

971
00:44:12,720 --> 00:44:15,600
there are progress other day systems that will have a jason type. 

972
00:44:16,690 --> 00:44:22,840
And the the methods to store jason data in a binary form

973
00:44:22,850 --> 00:44:24,200
efficiently instead of just text. 

974
00:44:26,470 --> 00:44:29,380
Mogadi does this, they have their own base on data type.

975
00:44:29,890 --> 00:44:30,980
Postcards have something similar. 

976
00:44:32,430 --> 00:44:35,420
Again, a lot of the ideas that were done in these specialized systems.

977
00:44:35,430 --> 00:44:40,090
So these non relational systems have now found their way into relational systems. 

978
00:44:43,380 --> 00:44:43,680
All right. 

979
00:44:43,980 --> 00:44:47,090
Then the 1990s I called the boring days, 

980
00:44:47,810 --> 00:44:52,870
there wasn't any sort of radical change to the harvard landscape

981
00:44:52,880 --> 00:44:54,470
or the workload landscape. 

982
00:44:55,070 --> 00:44:55,180
Right? 

983
00:44:55,190 --> 00:44:59,270
There wasn't it wasn't like the advent of the cloud or or microcomputers

984
00:44:59,280 --> 00:45:00,110
in the 1980s, 

985
00:45:00,120 --> 00:45:02,680
which is like things are going along, things are getting better.

986
00:45:03,160 --> 00:45:05,230
Harbor is getting better, the data sets are getting bigger,

987
00:45:05,680 --> 00:45:08,750
but it wasn't dramatic change. 

988
00:45:10,360 --> 00:45:10,700
Right? 

989
00:45:11,390 --> 00:45:13,560
So I think the sort of four major events would be

990
00:45:14,040 --> 00:45:18,780
microsoft bought aa copy or license to the sigh of a source code, 

991
00:45:19,190 --> 00:45:20,940
forks it, and then they create sql server.

992
00:45:22,050 --> 00:45:23,560
Segal server supports t sequel, 

993
00:45:23,990 --> 00:45:26,110
which is their variance sequel that comes from side base, 

994
00:45:26,120 --> 00:45:27,350
side base invented t sequel. 

995
00:45:28,180 --> 00:45:29,130
At this point again, 

996
00:45:29,140 --> 00:45:31,530
segal server is state of the art side base is in maintenance mode. 

997
00:45:32,480 --> 00:45:34,070
I don't know how much of the original sideways code is

998
00:45:34,080 --> 00:45:35,470
still a sequel celebrity these days. 

999
00:45:35,480 --> 00:45:37,550
They did major rewrites in 2000. 

1000
00:45:38,530 --> 00:45:41,760
They did major rereads in 1998 and in 2006. 

1001
00:45:43,370 --> 00:45:47,650
My sequel sort of get there's a guy in these finland

1002
00:45:48,040 --> 00:45:51,240
started rewriting or started writing his own data system to replace

1003
00:45:51,250 --> 00:45:52,720
m sequel and called it my sequel. 

1004
00:45:53,300 --> 00:45:54,670
My is the name of his daughter. 

1005
00:45:56,030 --> 00:45:58,420
He also did marie db that's his other daughter. 

1006
00:45:58,920 --> 00:46:01,550
Then a a he has a son named max, 

1007
00:46:01,560 --> 00:46:04,310
and there is max db like he names all his davis after his kids. 

1008
00:46:05,420 --> 00:46:07,740
Postgres get recently started as an academic project. 

1009
00:46:08,260 --> 00:46:11,310
Strawburger loved quell in the 1980s when they first started writing it. 

1010
00:46:12,090 --> 00:46:13,280
It was used 12. 

1011
00:46:14,350 --> 00:46:15,830
But then in 95, 

1012
00:46:15,840 --> 00:46:18,750
90 62 grad students took the original academic source code, 

1013
00:46:19,370 --> 00:46:21,850
and then convert it to make it actually support sql. 

1014
00:46:22,350 --> 00:46:26,350
And that's why it's called progress ql they might know what

1015
00:46:26,360 --> 00:46:29,640
the original programming language process was written in the 1980s. 

1016
00:46:29,650 --> 00:46:32,710
Let me take a guess. 

1017
00:46:34,010 --> 00:46:34,490
This is cobalt. 

1018
00:46:34,500 --> 00:46:34,730
No. 

1019
00:46:37,570 --> 00:46:38,260
Abby can close it. 

1020
00:46:40,170 --> 00:46:45,120
Did you take a lisp? 

1021
00:46:48,550 --> 00:46:49,550
It was the 80s, right?

1022
00:46:49,600 --> 00:46:50,550
Cocaine or whatever like. 

1023
00:46:52,060 --> 00:46:53,530
And then they realized that was a bad idea. 

1024
00:46:53,540 --> 00:46:58,020
So then they had a compiler convert the lisp into c and compile that. 

1025
00:46:58,030 --> 00:46:58,980
And then that was a bad idea. 

1026
00:46:59,110 --> 00:47:04,330
They rewrote everything in c and then sequel light started early 2000. 

1027
00:47:04,600 --> 00:47:07,190
It's one dude invented this down in north carolina, 

1028
00:47:07,690 --> 00:47:08,230
richard hip. 

1029
00:47:09,070 --> 00:47:10,460
He still looked the main program on the senate. 

1030
00:47:11,280 --> 00:47:12,500
The one thing that did change, 

1031
00:47:12,510 --> 00:47:14,420
I would say, was not a dramatic change,

1032
00:47:14,430 --> 00:47:16,390
is that people started to realize, 

1033
00:47:16,720 --> 00:47:20,850
I don't just want to use my data system to transactions and ingest new data. 

1034
00:47:21,220 --> 00:47:22,890
Someone want to start doing analytics, 

1035
00:47:22,900 --> 00:47:26,170
start extrapolate new information business. 

1036
00:47:26,180 --> 00:47:28,770
Intelligent decision support has a bunch of different names. 

1037
00:47:30,240 --> 00:47:32,230
All these systems at the time are all row stores. 

1038
00:47:33,230 --> 00:47:33,970
And as we know, 

1039
00:47:33,980 --> 00:47:37,130
running analytical queries on a row store is highly inefficient. 

1040
00:47:38,070 --> 00:47:42,550
There was this optimization technique called data cubes where you

1041
00:47:42,560 --> 00:47:44,470
basically figure like materialized view, 

1042
00:47:44,750 --> 00:47:46,990
where you pre computed these multi conventional arrays

1043
00:47:47,980 --> 00:47:51,600
of different group i's and aggregation and so forth. 

1044
00:47:51,950 --> 00:47:53,910
And you would pre compete and you run your analytics on those. 

1045
00:47:54,800 --> 00:47:58,700
Nobody uses data cubes today because column stores so much faster. 

1046
00:47:59,130 --> 00:48:01,730
But this is how people got by in the 1990s. 

1047
00:48:04,260 --> 00:48:05,370
So the big game changer, though,

1048
00:48:05,380 --> 00:48:07,910
was in 2000s when the internet comes along. 

1049
00:48:09,120 --> 00:48:10,790
So again, prior to this,

1050
00:48:10,800 --> 00:48:12,590
when you think about it who had big databases, 

1051
00:48:13,790 --> 00:48:16,030
the big bangs, walmart's, right?

1052
00:48:16,040 --> 00:48:19,800
The only like the fortune 500 companies had big data as problems. 

1053
00:48:20,880 --> 00:48:22,160
But when the internet comes along, 

1054
00:48:23,730 --> 00:48:26,430
it doesn't take that much for a small number of people to put something

1055
00:48:26,440 --> 00:48:29,900
on the internet and have a lot of people start using the application

1056
00:48:29,910 --> 00:48:30,500
of the website. 

1057
00:48:31,010 --> 00:48:33,470
And you start generating a lot of traffic and a lot of data, 

1058
00:48:33,480 --> 00:48:34,270
a lot of users. 

1059
00:48:35,430 --> 00:48:35,840
Right? 

1060
00:48:36,860 --> 00:48:40,800
So this was a big change in how people approach databases in the 2000. 

1061
00:48:42,470 --> 00:48:43,340
But at the time, 

1062
00:48:43,350 --> 00:48:46,970
all of the sort of the commercial enterprise databases were very heavyweight, 

1063
00:48:47,800 --> 00:48:50,750
oracle, db two, cyprus, they were very expensive.

1064
00:48:52,710 --> 00:48:54,950
And then the open source databases that we think about today, 

1065
00:48:55,340 --> 00:48:56,820
postcards and my sql, 

1066
00:48:57,300 --> 00:48:58,730
they were pretty primitive back in the day. 

1067
00:48:59,900 --> 00:49:04,360
My sequel to support transactions until inter db came along, 

1068
00:49:05,090 --> 00:49:06,360
2003 2004. 

1069
00:49:07,890 --> 00:49:11,550
So what people ended up doing was writing out their own sort

1070
00:49:11,560 --> 00:49:16,500
of custom middleware to route queries to these single node database

1071
00:49:16,510 --> 00:49:16,780
indices. 

1072
00:49:17,350 --> 00:49:20,040
So they would sort of treat my sql as like a dumb key value store, 

1073
00:49:20,630 --> 00:49:24,200
and then have something in front of it to route queries to different shards

1074
00:49:24,210 --> 00:49:27,410
that the idea is still widely used today, 

1075
00:49:27,420 --> 00:49:29,730
but the people were wrong on their own back. 

1076
00:49:29,740 --> 00:49:29,970
Then. 

1077
00:49:29,980 --> 00:49:33,290
The other thing that happened was, 

1078
00:49:33,550 --> 00:49:34,100
again, as I say,

1079
00:49:34,110 --> 00:49:36,260
it doesn't take that much to start collecting a lot of data. 

1080
00:49:36,730 --> 00:49:38,860
More people started wanting to analyze this data. 

1081
00:49:39,780 --> 00:49:43,350
Then we realize or they realize that the sort

1082
00:49:43,360 --> 00:49:46,600
of general purpose data systems at a row store that tries to do

1083
00:49:47,030 --> 00:49:47,650
transactions and analytics. 

1084
00:49:48,120 --> 00:49:48,900
Was that bad idea? 

1085
00:49:48,910 --> 00:49:51,960
And people started building these custom analytical data systems, 

1086
00:49:52,450 --> 00:49:52,800
which again, 

1087
00:49:52,810 --> 00:49:57,150
will be the the sort of key idea that we're focusing on this semester. 

1088
00:49:58,120 --> 00:50:00,460
A lot of these were distributed and shared nothing of us. 

1089
00:50:00,470 --> 00:50:02,220
All of these were going to be actually all

1090
00:50:02,230 --> 00:50:07,600
of these were relational and sql most of them are forks of post graphs. 

1091
00:50:09,210 --> 00:50:13,670
And they're going to store the database as column stores. 

1092
00:50:14,580 --> 00:50:16,660
Again, seems like an obvious idea now.

1093
00:50:17,340 --> 00:50:19,870
And because the wind you get from are so significant, 

1094
00:50:20,420 --> 00:50:21,630
back then this was unheard of, 

1095
00:50:22,030 --> 00:50:23,770
It's not unheard of it, because the ideas from the 70s,

1096
00:50:23,780 --> 00:50:26,000
but like having these explicitly stored, 

1097
00:50:26,010 --> 00:50:28,080
the ideas columns that was novel, 

1098
00:50:28,970 --> 00:50:29,810
that was a game changer. 

1099
00:50:31,540 --> 00:50:35,630
So the sort of the main systems at this time are listed here. 

1100
00:50:35,970 --> 00:50:37,620
So natzisa was a fork a postgrasse, 

1101
00:50:37,630 --> 00:50:42,280
but they put a fpga down to the storage layer to make it run filters faster. 

1102
00:50:43,170 --> 00:50:44,480
Park sells a fork of postcards, 

1103
00:50:44,490 --> 00:50:45,640
distributed version postgres. 

1104
00:50:46,590 --> 00:50:48,390
This is actually what redshift is redshift. 

1105
00:50:48,400 --> 00:50:50,230
They bought a license to park cell. 

1106
00:50:50,870 --> 00:50:53,570
Didn't really make any changes, just slapped it up and called it redshift.

1107
00:50:54,580 --> 00:50:58,400
Was that this is not a secret. 

1108
00:50:58,410 --> 00:50:59,720
I was telling you, all right, this is public.

1109
00:51:01,720 --> 00:51:03,090
And so just threw it up. 

1110
00:51:03,570 --> 00:51:04,410
It made so much money. 

1111
00:51:04,740 --> 00:51:06,130
Now we've got to start making this real. 

1112
00:51:07,250 --> 00:51:07,420
Right? 

1113
00:51:07,430 --> 00:51:11,040
And it's been written many times over vertica. 

1114
00:51:11,050 --> 00:51:13,240
That's a company that started by my advisers, 

1115
00:51:13,250 --> 00:51:15,820
mike stone breaker, and then santa zonatic.

1116
00:51:15,830 --> 00:51:17,180
That's a fork, a postgres.

1117
00:51:17,720 --> 00:51:20,540
Data leg row was a shorter version of ingress. 

1118
00:51:20,550 --> 00:51:24,130
And the green plum is a fork and postgres mode adb was

1119
00:51:24,140 --> 00:51:26,130
exactly the other one here that was written from scratch. 

1120
00:51:27,190 --> 00:51:28,700
And that came out of cwi the same. 

1121
00:51:28,710 --> 00:51:33,490
Have you ever heard of ducky b it's the same research group that made

1122
00:51:33,500 --> 00:51:36,490
mode adb dot db was originally called mode db light. 

1123
00:51:36,500 --> 00:51:40,740
It was a fork mode db to run embedded in like our programs. 

1124
00:51:41,250 --> 00:51:46,850
And then they rewrote it and ended up being doug db i'm not sure I

1125
00:51:46,860 --> 00:51:47,750
may have to bleed this. 

1126
00:51:47,760 --> 00:51:48,590
I'm not sure this is public. 

1127
00:51:49,220 --> 00:51:51,570
Microsoft bought data, microsoft bought data, leg grow,

1128
00:51:51,580 --> 00:51:53,510
ibm bought the teaser park sell. 

1129
00:51:53,520 --> 00:51:54,830
They can never get bought that. 

1130
00:51:54,840 --> 00:51:56,150
He's got and i'm getting licensed. 

1131
00:51:56,160 --> 00:52:00,630
I think the company's dead vertica got acquired by hp any of you

1132
00:52:00,640 --> 00:52:02,990
got never bought and then green palm got bought by

1133
00:52:04,940 --> 00:52:10,290
no emc hold on. 

1134
00:52:11,920 --> 00:52:14,630
At some point, there were miemc it's hard to keep track of this.

1135
00:52:15,670 --> 00:52:16,400
They got bought. 

1136
00:52:18,070 --> 00:52:21,220
And then they divested it off to an emc in order to take back. 

1137
00:52:21,510 --> 00:52:23,570
Emc had a database piece. 

1138
00:52:24,310 --> 00:52:25,400
Vmr had a database piece. 

1139
00:52:25,740 --> 00:52:27,900
They took it out, and they formed a new company called pivotal.

1140
00:52:29,420 --> 00:52:33,250
It was green palm and then sequel fire or gem fire, 

1141
00:52:35,290 --> 00:52:37,870
which I think that notes emc bought them, 

1142
00:52:37,880 --> 00:52:39,150
vm ware bought sql file. 

1143
00:52:39,900 --> 00:52:41,270
They took them out, made pivotal,

1144
00:52:41,280 --> 00:52:42,880
and then bmr bought pivotal. 

1145
00:52:44,110 --> 00:52:49,920
It's so data leg row got up with microsoft. 

1146
00:52:50,360 --> 00:52:53,180
It was a hacked up version of charted ingress. 

1147
00:52:54,130 --> 00:52:55,950
And I think they paid money for it. 

1148
00:52:56,270 --> 00:52:57,400
And then after they bought it, 

1149
00:52:57,410 --> 00:52:58,780
so after they wrote the check, 

1150
00:52:59,310 --> 00:53:01,660
then they had their technical people actually look at it and say this is

1151
00:53:01,670 --> 00:53:02,100
all crap. 

1152
00:53:02,110 --> 00:53:03,860
We can't use any of this and they threw it all away. 

1153
00:53:05,140 --> 00:53:08,170
They made them they end up running the sequel server data warehouse

1154
00:53:08,940 --> 00:53:10,760
from scratch the parallel data warehouse instead of using any

1155
00:53:10,770 --> 00:53:11,240
of these garbage. 

1156
00:53:13,270 --> 00:53:13,930
There's another one too. 

1157
00:53:14,060 --> 00:53:16,450
I'm missing astor data they were bought by. 

1158
00:53:17,950 --> 00:53:19,540
They were bought, I think by terror data.

1159
00:53:26,820 --> 00:53:30,780
The while all this work is happening on these parallel column store data warehouses, 

1160
00:53:31,680 --> 00:53:35,580
there was this other big trend of these matte reduced systems. 

1161
00:53:36,320 --> 00:53:36,570
Again, 

1162
00:53:36,580 --> 00:53:39,290
so what it's been 10 years now since the object ordinary databases were

1163
00:53:39,300 --> 00:53:40,050
a bad idea, 

1164
00:53:40,660 --> 00:53:43,850
now we're 10 years later, so this thing comes along from google.

1165
00:53:45,890 --> 00:53:48,200
They built a custom execution engine with this map, 

1166
00:53:48,210 --> 00:53:53,320
reduce programming model that to help them crawl their to build the index

1167
00:53:53,330 --> 00:53:54,080
for the web crawl. 

1168
00:53:54,880 --> 00:53:57,810
And they end up using for a bunch of other data processing tasks

1169
00:53:57,820 --> 00:53:58,440
or analytical tasks. 

1170
00:53:59,430 --> 00:54:00,720
So google put out the paper, 

1171
00:54:01,040 --> 00:54:02,350
say, hey, that's what we're using.

1172
00:54:03,490 --> 00:54:04,620
The pi still happens now, 

1173
00:54:04,630 --> 00:54:08,860
but google was really the super hot thing in the 2000s. 

1174
00:54:09,360 --> 00:54:09,470
Right? 

1175
00:54:10,000 --> 00:54:11,990
Anything they did, any paper they put out,

1176
00:54:12,000 --> 00:54:13,750
people did end up go and re implement themselves, 

1177
00:54:13,760 --> 00:54:15,510
because they thought google is making a ton of money, 

1178
00:54:16,110 --> 00:54:17,230
because they have all these custom systems. 

1179
00:54:17,240 --> 00:54:18,830
Let's go build our own custom system too. 

1180
00:54:19,500 --> 00:54:19,750
Right? 

1181
00:54:20,460 --> 00:54:22,830
Like h base is a clone a big table, 

1182
00:54:23,220 --> 00:54:29,830
cause cassandra is a clone a big table and dynamo db that's the acfs dude

1183
00:54:29,840 --> 00:54:32,550
was the clone of matt reduce. 

1184
00:54:34,030 --> 00:54:36,990
So google put that map reduce paper. 

1185
00:54:37,550 --> 00:54:39,540
Yahoo says, see, that says a good idea.

1186
00:54:39,550 --> 00:54:40,420
We can use it too. 

1187
00:54:40,810 --> 00:54:43,050
They wrote their own open source version called duke. 

1188
00:54:44,650 --> 00:54:47,430
And the basic idea was that you'd write these user defined functions

1189
00:54:47,440 --> 00:54:52,610
like a map and reduce a shuffle phase cover later on next class. 

1190
00:54:54,720 --> 00:54:57,100
Instead of using a sequel, you'd write these custom functions.

1191
00:54:57,110 --> 00:55:00,620
And you just submit them to the davis to the map reduce or do framework

1192
00:55:00,950 --> 00:55:01,690
and run them for you. 

1193
00:55:03,070 --> 00:55:07,630
It takes us back to the 1970s where the programmer had to define what

1194
00:55:07,640 --> 00:55:09,830
the data model actually was or the data they were processing. 

1195
00:55:10,680 --> 00:55:12,980
There's no sequel at the time of these systems. 

1196
00:55:13,270 --> 00:55:15,080
You had to literally write all parts, 

1197
00:55:15,350 --> 00:55:17,380
the i'm going to parse this csv file, 

1198
00:55:17,390 --> 00:55:18,740
and I expect them to have these columns. 

1199
00:55:18,750 --> 00:55:23,510
And you would write that explicit citations in your in the program encoder

1200
00:55:23,960 --> 00:55:24,910
in these functions. 

1201
00:55:26,440 --> 00:55:28,500
So this was the hot thing in the late 2000. 

1202
00:55:28,510 --> 00:55:29,940
That was like this is the way to do this. 

1203
00:55:29,950 --> 00:55:30,540
You ought to add up. 

1204
00:55:31,720 --> 00:55:32,860
And then stone breaker, 

1205
00:55:32,870 --> 00:55:36,990
and then this other guy who does invented a lot of the first pillow databases, 

1206
00:55:37,800 --> 00:55:39,520
put out an article that said this is a bad idea. 

1207
00:55:39,830 --> 00:55:41,930
Then ii wrote a paper at them and showed it was. 

1208
00:55:43,590 --> 00:55:46,190
And then people eventually realize it, turns out the old guys are right.

1209
00:55:46,200 --> 00:55:47,150
This is a bad idea. 

1210
00:55:47,820 --> 00:55:50,420
So then they try to put sequel on top of map, 

1211
00:55:50,430 --> 00:55:52,700
reduce facebook invented hive. 

1212
00:55:52,710 --> 00:55:56,490
And there's a thing called map rdb at a map r which I I think they're dead now. 

1213
00:55:57,660 --> 00:55:59,700
But then it turned out that was super inefficient and super slow, 

1214
00:55:59,710 --> 00:56:05,470
because the way just sort of the way her dude was actually implemented, 

1215
00:56:05,480 --> 00:56:09,570
or I don't know exactly how the map arts framework actually worked, 

1216
00:56:09,580 --> 00:56:13,190
but the way they were sort of storing these checkpoints

1217
00:56:13,200 --> 00:56:15,310
at every single stage of the query was super inefficient. 

1218
00:56:16,990 --> 00:56:19,200
And so all this got thrown away. 

1219
00:56:19,210 --> 00:56:20,120
I i've still exists. 

1220
00:56:20,130 --> 00:56:23,830
But like people realize a this is actually a bad idea. 

1221
00:56:24,810 --> 00:56:27,240
As a you want a parallel to the warehouse, 

1222
00:56:27,250 --> 00:56:28,800
you want the thing that we were shown before. 

1223
00:56:29,920 --> 00:56:31,920
But it again took 10 years for people to realize this. 

1224
00:56:31,930 --> 00:56:32,720
This was a bad idea. 

1225
00:56:34,680 --> 00:56:37,050
Also related to, I won't say bad ideas here too,

1226
00:56:37,060 --> 00:56:40,620
but there was this no sequel movement again, 

1227
00:56:40,630 --> 00:56:45,020
I think brought upon by google and the big table paper basically said, 

1228
00:56:45,400 --> 00:56:48,390
hey, the the racial model is bad.

1229
00:56:48,560 --> 00:56:52,220
The sequel is too slow for modern web application. 

1230
00:56:53,170 --> 00:56:54,600
We don't need transactions, we don't need joints.

1231
00:56:55,130 --> 00:56:56,330
We want to build these systems from scratch, 

1232
00:56:57,240 --> 00:56:57,280
right? 

1233
00:56:57,290 --> 00:56:59,630
Because you have to understand like if you're building a website, 

1234
00:56:59,640 --> 00:57:06,250
you want to think up 2047 a in a database systems transactions that

1235
00:57:06,260 --> 00:57:07,170
maybe didn't have

1236
00:57:07,990 --> 00:57:11,470
backups or replicas for high availability. 

1237
00:57:12,080 --> 00:57:13,560
That means if no goes down, 

1238
00:57:13,570 --> 00:57:15,980
if your whole website goes down, that's bad, you lose money.

1239
00:57:17,950 --> 00:57:19,850
So the no sequel guys facing said, well,

1240
00:57:20,690 --> 00:57:25,370
maybe you were to let the system maybe have corrupt data

1241
00:57:25,380 --> 00:57:28,690
or not strictly follow transaction semantics, 

1242
00:57:28,700 --> 00:57:31,910
transport in exchange for always being up, always being online.

1243
00:57:31,920 --> 00:57:35,110
So there's a bunch of these systems that got built. 

1244
00:57:35,470 --> 00:57:36,540
Under this model, 

1245
00:57:36,550 --> 00:57:39,540
some things sometimes is dynamite. 

1246
00:57:39,550 --> 00:57:41,500
Db was built by amazon for the shopping cart. 

1247
00:57:42,950 --> 00:57:45,060
If I put some in my shopping cart, it maybe disappears.

1248
00:57:45,070 --> 00:57:46,960
This is the end of the world, 

1249
00:57:48,090 --> 00:57:48,540
probably not. 

1250
00:57:49,720 --> 00:57:52,520
If I put something in my bank account and disappears, that's a big problem.

1251
00:57:53,050 --> 00:57:53,400
Right? 

1252
00:57:54,150 --> 00:57:58,180
So all these systems basically follow different looser semantics over what

1253
00:57:58,190 --> 00:58:01,390
the traditional relational transaction, 

1254
00:58:01,400 --> 00:58:05,930
strongly consistent daily systems would follow to varying degrees of success. 

1255
00:58:06,830 --> 00:58:07,860
And as I said before, 

1256
00:58:07,870 --> 00:58:10,890
basically everybody supports segal now, except for retis,

1257
00:58:11,540 --> 00:58:14,730
I think raven db they all have their own version of sql

1258
00:58:14,740 --> 00:58:19,120
but it's basically sql without wanting to say it react as dead. 

1259
00:58:19,130 --> 00:58:22,730
So there I don't I don't think we have any and then oracle new sequel I

1260
00:58:22,740 --> 00:58:28,850
think it's just perfectly to be under the covers at the same time. 

1261
00:58:28,860 --> 00:58:32,530
All right, so soon after the no sequel databases got popular,

1262
00:58:33,060 --> 00:58:34,460
there was another movement called new sequel. 

1263
00:58:34,470 --> 00:58:38,740
This one I was involved in where the idea was that you wouldn't have

1264
00:58:38,750 --> 00:58:42,160
the same high scalability and performance of a no sql database system. 

1265
00:58:42,620 --> 00:58:44,010
But without giving up transactions, 

1266
00:58:45,560 --> 00:58:47,010
obviously, you can't,

1267
00:58:49,440 --> 00:58:50,750
you can't go faster than the speed of light. 

1268
00:58:50,760 --> 00:58:53,150
So if you have machines in different areas of the world, 

1269
00:58:53,370 --> 00:58:54,610
you can't make that go faster, 

1270
00:58:55,070 --> 00:58:56,550
but you at least make sure that things are correct. 

1271
00:58:57,990 --> 00:59:01,550
So all the systems that came out under this no segal movement, 

1272
00:59:01,990 --> 00:59:06,930
with maybe the exception of of odb map c will get renamed to a sequel store, 

1273
00:59:06,940 --> 00:59:09,850
and they wouldn't necessarily call themselves a new sql system now. 

1274
00:59:10,240 --> 00:59:11,520
And then spanner did detail. 

1275
00:59:11,530 --> 00:59:12,400
Spanner is still here. 

1276
00:59:12,410 --> 00:59:13,360
Spanner is legit. 

1277
00:59:13,810 --> 00:59:14,600
But for the most part, 

1278
00:59:14,610 --> 00:59:16,360
bunch of things you've never heard of before the trans lattice, 

1279
00:59:16,370 --> 00:59:20,310
i'm sure nobody's heard of gddb they all pretty much failed. 

1280
00:59:21,610 --> 00:59:23,920
Foundation db had a sequel there that was kind of crap. 

1281
00:59:24,530 --> 00:59:26,010
Apple bought down, threw that away.

1282
00:59:26,410 --> 00:59:27,750
And they since open source it, 

1283
00:59:27,760 --> 00:59:31,990
but it's not used as a relational data system with sequel. 

1284
00:59:32,000 --> 00:59:32,150
Now. 

1285
00:59:33,110 --> 00:59:34,620
What did happen though? 

1286
00:59:34,630 --> 00:59:36,740
All a bunch of these systems didn't pan out. 

1287
00:59:37,240 --> 00:59:41,800
The new transaction data systems aren't actually getting some traction, 

1288
00:59:41,810 --> 00:59:44,920
and these sort of fall under the umbrella of distributed sequel. 

1289
00:59:45,530 --> 00:59:47,040
Instead of calling new sql was sort of vague, 

1290
00:59:47,050 --> 00:59:48,760
you say it's a derivative sql system. 

1291
00:59:49,610 --> 00:59:51,440
Tide eb is out of china. 

1292
00:59:51,450 --> 00:59:54,960
Cochrane eb is probably raised the most money of all these. 

1293
00:59:55,510 --> 00:59:58,590
And then you go by as another startup that's based on postgraduate. 

1294
00:59:58,950 --> 01:00:01,170
The com, db two was built by, I think, bloomberg.

1295
01:00:01,980 --> 01:00:04,890
I've never heard anybody use the com db two outside of bloomberg, 

1296
01:00:05,670 --> 01:00:07,100
but it is absurd, so it doesn't exist.

1297
01:00:08,760 --> 01:00:11,870
So the main take away here is that these systems, 

1298
01:00:13,170 --> 01:00:15,520
these systems are going against the conventional wisdom that like you want

1299
01:00:15,530 --> 01:00:16,160
an original model, 

1300
01:00:16,170 --> 01:00:17,520
you want to sequel one in transactions. 

1301
01:00:17,860 --> 01:00:19,330
Because all the new sequel systems are hot. 

1302
01:00:19,880 --> 01:00:23,040
By the time that people realized I do want sequel, I do want transactions,

1303
01:00:24,270 --> 01:00:26,780
they failed or didn't pan out. 

1304
01:00:27,100 --> 01:00:29,370
Then these systems were the right place at the right time building

1305
01:00:29,380 --> 01:00:34,600
off the things that the earlier systems had done finishing up. 

1306
01:00:34,690 --> 01:00:35,960
We have cloud systems. 

1307
01:00:36,850 --> 01:00:38,410
Again, we'll cover this a lot throughout the semester.

1308
01:00:38,850 --> 01:00:41,210
Basically, now the harbor that escape has changed.

1309
01:00:41,690 --> 01:00:43,210
People are no longer running on pram. 

1310
01:00:43,860 --> 01:00:45,220
You're now running in a cloud, 

1311
01:00:46,380 --> 01:00:46,670
right? 

1312
01:00:46,680 --> 01:00:48,870
And that means your resources can be elastic. 

1313
01:00:48,880 --> 01:00:51,150
You don't have to go through this long provisioning cycle of like, 

1314
01:00:51,420 --> 01:00:52,670
I want to buy these machines and procurement, 

1315
01:00:52,680 --> 01:00:54,270
and it takes a long time to actually get them. 

1316
01:00:54,770 --> 01:00:55,360
With a credit card. 

1317
01:00:55,370 --> 01:00:57,000
You can spit up a new instance very, very quickly.

1318
01:00:58,140 --> 01:01:00,980
So every initially there was a bunch of these databases

1319
01:01:00,990 --> 01:01:05,840
of service products or offerings where it would just take

1320
01:01:05,850 --> 01:01:08,830
like off the shelf I sequel rather than avm for you. 

1321
01:01:08,840 --> 01:01:10,710
It's before containers rather than avm for you, 

1322
01:01:11,060 --> 01:01:12,000
and they charge you for that. 

1323
01:01:12,280 --> 01:01:12,840
But it didn't. 

1324
01:01:13,270 --> 01:01:14,990
My sequel wasn't really aware that it's running in the cloud. 

1325
01:01:15,000 --> 01:01:18,690
It's just running on some vm but since then, 

1326
01:01:18,700 --> 01:01:22,660
there's now assessments designed from scratch explicitly for running a a

1327
01:01:22,670 --> 01:01:23,700
in a cloud system. 

1328
01:01:24,000 --> 01:01:25,960
But we would call these cloud native snowflakes, 

1329
01:01:25,970 --> 01:01:28,480
probably the most fame in one of all these like they designed

1330
01:01:28,490 --> 01:01:29,560
explicitly in the beginning, 

1331
01:01:29,910 --> 01:01:32,370
not to run on pram, only to run in the cloud.

1332
01:01:32,680 --> 01:01:33,110
Then therefore, 

1333
01:01:33,120 --> 01:01:35,700
you can make certain design choices which will cover next week. 

1334
01:01:36,070 --> 01:01:37,540
That can take advantage of that. 

1335
01:01:39,760 --> 01:01:41,250
Want to make things also to that. 

1336
01:01:41,570 --> 01:01:44,190
Came out of the map produced world plus now with the cloud. 

1337
01:01:44,730 --> 01:01:46,360
Are these shared disk systems? 

1338
01:01:47,480 --> 01:01:48,350
Prior to this, 

1339
01:01:48,720 --> 01:01:52,580
the the conventional wisdom of how you would build it and tribute

1340
01:01:52,590 --> 01:01:53,980
a daily system is would be shared nothing. 

1341
01:01:54,990 --> 01:01:57,610
Now with the cloud where amazon or whoever is taking care

1342
01:01:57,620 --> 01:01:59,170
of the storage layer for you, 

1343
01:02:01,020 --> 01:02:02,640
you don't want to be able to share nothing system. 

1344
01:02:02,650 --> 01:02:06,620
You want to use a shared disk system and let the cloud vendor handle

1345
01:02:06,630 --> 01:02:07,300
the storage for you. 

1346
01:02:08,550 --> 01:02:13,390
So there's a bunch of systems now built on top of this shared disk approach. 

1347
01:02:13,730 --> 01:02:14,510
This is the fact, 

1348
01:02:14,520 --> 01:02:17,670
this is how everyone's building modern data systems today. 

1349
01:02:18,670 --> 01:02:20,090
People talk about I have a data lake, 

1350
01:02:20,980 --> 01:02:21,190
right? 

1351
01:02:21,200 --> 01:02:22,510
Or we'll see this. 

1352
01:02:23,310 --> 01:02:24,260
When we talk about data bricks, 

1353
01:02:25,920 --> 01:02:28,450
they're talking about basically serving on s three, right?

1354
01:02:28,580 --> 01:02:30,370
Something with a shared disk model. 

1355
01:02:32,980 --> 01:02:35,350
Every year I I got to complain about this. 

1356
01:02:37,910 --> 01:02:40,570
We're at the sort of phase now where it's, again, no sql,

1357
01:02:41,280 --> 01:02:42,320
the no sequel women died out. 

1358
01:02:42,330 --> 01:02:49,910
People realize sequel is the way to go still coming along. 

1359
01:02:50,320 --> 01:02:52,760
I wouldn't necessarily maybe not necessarily call these new sequel systems, 

1360
01:02:53,540 --> 01:02:56,820
but they've definitely become more prominent in the last 5 or 6 years

1361
01:02:57,270 --> 01:02:58,440
Or these graph database systems. 

1362
01:02:58,770 --> 01:03:03,740
But the idea is that instead of storing your database as relations, 

1363
01:03:04,910 --> 01:03:06,470
it's intrinsically, it's a graph.

1364
01:03:06,480 --> 01:03:09,780
Let me sort it as a graph structure between relations and so forth. 

1365
01:03:09,790 --> 01:03:12,460
And this can be either rdf or triple store or property graphs. 

1366
01:03:12,470 --> 01:03:13,940
It has a bunch of different names. 

1367
01:03:14,780 --> 01:03:17,500
But it's essentially the same thing that they were doing back in the 70s

1368
01:03:17,670 --> 01:03:19,830
with the kodaso network model. 

1369
01:03:21,420 --> 01:03:24,930
So the big claim is that because you're starting a database

1370
01:03:24,940 --> 01:03:26,490
as negatively as graphs. 

1371
01:03:27,090 --> 01:03:30,520
And because you're now exposing a nato graph api you can be

1372
01:03:30,530 --> 01:03:32,040
much better than a relational data system. 

1373
01:03:33,290 --> 01:03:33,960
We've heard that before. 

1374
01:03:34,130 --> 01:03:36,200
That was the argument for the object oriented databases. 

1375
01:03:36,930 --> 01:03:37,600
It's the object, 

1376
01:03:39,270 --> 01:03:40,840
the jason databases, 

1377
01:03:40,850 --> 01:03:42,120
all these people make the same argument. 

1378
01:03:43,150 --> 01:03:47,980
And so sure there are some times what you do want to traverse your database

1379
01:03:50,730 --> 01:03:52,720
in a sort of native graph way. 

1380
01:03:54,330 --> 01:03:57,940
But the segal standard is actually adding support for graph queries this year. 

1381
01:03:59,870 --> 01:04:00,760
And it's based on cipher, 

1382
01:04:00,770 --> 01:04:06,570
which was invented by by neo for j so they lose that advantage. 

1383
01:04:07,440 --> 01:04:10,300
Then now what about the argument that if i'm starting things

1384
01:04:10,310 --> 01:04:13,470
negatively as a graph is not going to be better than a relational database? 

1385
01:04:13,600 --> 01:04:13,710
No, 

1386
01:04:13,720 --> 01:04:17,120
because the paper that came out last week shows that if you built up db you

1387
01:04:17,510 --> 01:04:21,860
incorporate some techniques that will help explicitly for graph

1388
01:04:21,870 --> 01:04:22,380
workloads. 

1389
01:04:22,790 --> 01:04:23,470
Like multi wave joins, 

1390
01:04:23,480 --> 01:04:28,710
which we will cover a later the semester you cannot perform mu for j

1391
01:04:28,720 --> 01:04:33,100
by ten x dfoj has raised hundreds of millions of dollars. 

1392
01:04:33,690 --> 01:04:38,900
Doctor b's like aa small team of people in the netherlands. 

1393
01:04:40,190 --> 01:04:43,270
They beat them at 10:00X and it's a real system. 

1394
01:04:43,280 --> 01:04:44,470
It's not just a toy. 

1395
01:04:49,150 --> 01:04:50,470
I think graph databases. 

1396
01:04:51,480 --> 01:04:54,910
We've already see this racial model is absorbing ideas from it. 

1397
01:04:55,970 --> 01:05:00,930
I don't see these systems really replacing the the relation of davis is

1398
01:05:01,770 --> 01:05:02,380
in my lifetime. 

1399
01:05:02,820 --> 01:05:03,820
I should have put a speech on. 

1400
01:05:03,830 --> 01:05:09,780
Ii made a public bet where in I I made a public bet, 

1401
01:05:09,790 --> 01:05:13,090
they said in 2020 by 2030, 

1402
01:05:13,100 --> 01:05:16,350
the graph database market exceeds the racial database market. 

1403
01:05:16,700 --> 01:05:19,210
I will change my official cmu directory photo to be like so. 

1404
01:05:19,500 --> 01:05:23,140
I'm sure when he says I love graph databases and I will use that until I

1405
01:05:23,150 --> 01:05:24,660
die or get fired from seeing you. 

1406
01:05:25,120 --> 01:05:26,610
Ii don't see it happening. 

1407
01:05:28,450 --> 01:05:28,650
All right. 

1408
01:05:28,740 --> 01:05:30,810
So quickly finish up time series databases. 

1409
01:05:30,820 --> 01:05:34,740
So these are now newer databases that are designed to store, 

1410
01:05:35,050 --> 01:05:39,030
telemetry you're collecting or metrics you're collecting from other services, 

1411
01:05:39,040 --> 01:05:40,310
other devices, and so forth.

1412
01:05:40,830 --> 01:05:41,780
It's relational. 

1413
01:05:42,270 --> 01:05:47,110
There's this notion of explicit time ordering and the data you're generating. 

1414
01:05:47,510 --> 01:05:47,770
Therefore, 

1415
01:05:47,780 --> 01:05:52,420
you can design the system to officially take advantage of the domain

1416
01:05:52,430 --> 01:05:53,180
you're working in. 

1417
01:05:53,990 --> 01:05:56,740
You wouldn't want to use these for storing arbitrary data. 

1418
01:05:57,210 --> 01:05:59,320
If you have this notion of like ticks or events are showing

1419
01:05:59,330 --> 01:06:02,040
up with some notion of time, 

1420
01:06:02,520 --> 01:06:04,510
anyone do range queries based on those times, 

1421
01:06:05,120 --> 01:06:07,140
you could design a system to be more efficient to do this. 

1422
01:06:07,850 --> 01:06:10,200
So probably the three main ones would be time scale, 

1423
01:06:10,210 --> 01:06:13,950
which is using extensions on top of post graphs, which is super cool,

1424
01:06:14,260 --> 01:06:17,440
because you get regular tables and post graphs plus the time series ones. 

1425
01:06:17,970 --> 01:06:20,440
Influx eb is written from scratch. 

1426
01:06:21,150 --> 01:06:22,980
I think they're third rewrite, 

1427
01:06:24,480 --> 01:06:25,820
but again, 

1428
01:06:25,830 --> 01:06:27,100
they're targeting time series of this. 

1429
01:06:29,710 --> 01:06:31,350
Click house is out of russia. 

1430
01:06:32,690 --> 01:06:37,540
This is probably when I first learned about click as when you read

1431
01:06:37,550 --> 01:06:38,980
the website and all the things that they supported. 

1432
01:06:39,150 --> 01:06:40,740
It's a lot of techniques we discussed in the class. 

1433
01:06:41,000 --> 01:06:41,620
It seemed unreal. 

1434
01:06:41,630 --> 01:06:43,090
This is super state of the art. 

1435
01:06:44,370 --> 01:06:45,680
The performer summers look amazing. 

1436
01:06:45,940 --> 01:06:46,870
My impression, though,

1437
01:06:46,880 --> 01:06:53,750
is that it is it's not easy to get up and running a there's still a lot

1438
01:06:53,760 --> 01:06:54,710
of manual work you have to do, 

1439
01:06:54,720 --> 01:06:56,590
but ii think this one's going to be aa big player. 

1440
01:06:56,920 --> 01:07:00,930
And then prometheus is another big effort in this space. 

1441
01:07:03,370 --> 01:07:03,930
Last one, 

1442
01:07:05,150 --> 01:07:05,780
block chain devices. 

1443
01:07:12,810 --> 01:07:13,190
Yes, bit coin.

1444
01:07:13,640 --> 01:07:15,830
If you bought bit coin in 2010. 

1445
01:07:15,840 --> 01:07:16,050
Great. 

1446
01:07:16,060 --> 01:07:16,270
Thanks. 

1447
01:07:16,650 --> 01:07:17,030
Congrats. 

1448
01:07:18,730 --> 01:07:22,770
But like people had made claims that like block chain databases are

1449
01:07:24,100 --> 01:07:25,850
under web three or what everyone call it. 

1450
01:07:25,860 --> 01:07:29,560
This is a radical different way of how you want to build modern applications. 

1451
01:07:29,570 --> 01:07:33,120
The old way of having these provisioning servers over relational databases

1452
01:07:33,130 --> 01:07:36,350
and sequel and whatever all that stupid you want to build on top

1453
01:07:36,360 --> 01:07:38,680
of a block chain database to solve all the world's problems. 

1454
01:07:40,020 --> 01:07:41,060
At the end of the day, what is a block chain?

1455
01:07:42,220 --> 01:07:43,210
It's just a log. 

1456
01:07:43,620 --> 01:07:44,310
They would call a ledger. 

1457
01:07:44,320 --> 01:07:48,110
It's like, I write ahead log or the pack says log, the state log.

1458
01:07:48,640 --> 01:07:51,030
Here's all the events or things that are happening to this day of the deeds. 

1459
01:07:52,270 --> 01:07:54,660
Then they had these incremental check sums where the check sum

1460
01:07:54,790 --> 01:07:59,110
of a new entry in the log depends on the previous entry of the logs

1461
01:07:59,120 --> 01:07:59,390
that way. 

1462
01:07:59,400 --> 01:08:00,910
If you fudge anything below that. 

1463
01:08:01,410 --> 01:08:03,470
At a previous entry, the check sum doesn't match,

1464
01:08:03,480 --> 01:08:05,230
and you don't have the full data. 

1465
01:08:05,980 --> 01:08:07,970
The technique was invented on merkel treats. 

1466
01:08:08,820 --> 01:08:09,160
Then now, 

1467
01:08:09,170 --> 01:08:11,800
since you're assuming you're running in a decentralized distributed environment, 

1468
01:08:12,240 --> 01:08:15,110
we don't trust the people that are reading right into the database. 

1469
01:08:15,730 --> 01:08:19,540
You have to use some visiting fault tolerant or bft protocol to come

1470
01:08:19,550 --> 01:08:20,260
to consensus to say, 

1471
01:08:20,270 --> 01:08:26,630
what's the next entry which put in a log I it's it's a lot of cool ideas

1472
01:08:27,000 --> 01:08:28,920
and put together an interesting way, 

1473
01:08:29,380 --> 01:08:31,270
but is this game changer now? 

1474
01:08:32,660 --> 01:08:32,740
Right? 

1475
01:08:32,750 --> 01:08:38,560
I've yet to see a use case that everybody has proposed where a block chain

1476
01:08:38,570 --> 01:08:40,810
would solve a problem that you could not solve

1477
01:08:40,820 --> 01:08:42,560
with a traditional sql database like postgres, 

1478
01:08:44,090 --> 01:08:49,540
or you have some external external issues you have to resolve through like law, 

1479
01:08:50,370 --> 01:08:50,570
right? 

1480
01:08:50,580 --> 01:08:51,610
Or legal matters. 

1481
01:08:52,770 --> 01:08:53,260
Right? 

1482
01:08:54,460 --> 01:08:58,390
So I think there's all garbage. 

1483
01:09:00,290 --> 01:09:04,040
These systems here are explicitly doing block chain with a

1484
01:09:04,760 --> 01:09:06,270
in our decentralized model. 

1485
01:09:07,700 --> 01:09:10,960
This is the logo for podb amazon has the worst logos because it's like, 

1486
01:09:11,230 --> 01:09:13,000
unless what is it right? 

1487
01:09:13,010 --> 01:09:14,190
Like it. 

1488
01:09:14,560 --> 01:09:16,860
Qlqldb is our quantum ledger database. 

1489
01:09:17,160 --> 01:09:19,930
It's not a block chain database where it's like decentralized, 

1490
01:09:20,130 --> 01:09:21,500
like amazon, the trust of authority,

1491
01:09:22,030 --> 01:09:23,340
like you authenticate amazon, 

1492
01:09:23,760 --> 01:09:26,890
you don't have to do bfti think they just do two base commit, 

1493
01:09:28,450 --> 01:09:32,280
but you still get that verifiable ledger with the check sums. 

1494
01:09:32,290 --> 01:09:33,810
As far as they know, 

1495
01:09:33,820 --> 01:09:39,040
this is not going anywhere they make way more money on selling, 

1496
01:09:39,990 --> 01:09:43,100
reselling my sequel and postcards as rds or under aurora. 

1497
01:09:44,720 --> 01:09:47,970
Again, I at this point when I first saw these devices,

1498
01:09:47,980 --> 01:09:50,640
but maybe there's something I convinced this is all crap. 

1499
01:09:52,630 --> 01:09:56,060
I was able to say there's no inherent data model to a a block chain database. 

1500
01:09:56,070 --> 01:09:57,580
It's just entries in the log just bytes. 

1501
01:09:58,110 --> 01:10:00,750
There's some engine above it that has to interpret what those bytes are. 

1502
01:10:00,760 --> 01:10:01,950
So it could be a key value store, 

1503
01:10:02,450 --> 01:10:03,170
relationship database. 

1504
01:10:03,710 --> 01:10:04,300
It doesn't matter. 

1505
01:10:08,300 --> 01:10:10,420
There's a bunch of other stuff that should be 2020. 

1506
01:10:10,430 --> 01:10:11,260
So there's a typo. 

1507
01:10:11,270 --> 01:10:12,460
There's a bunch of other systems, 

1508
01:10:12,870 --> 01:10:15,560
categories of things we could talk about embedded databases

1509
01:10:15,570 --> 01:10:20,420
like sequel light and rock cb and duck

1510
01:10:20,430 --> 01:10:24,560
tb those multi modal or multi model databases where like orangu

1511
01:10:24,570 --> 01:10:27,480
tv where you try to support graphs and relations and documents

1512
01:10:27,490 --> 01:10:28,360
all in a single one. 

1513
01:10:29,150 --> 01:10:31,820
In the paper you guys read, we talked about harbor acceleration.

1514
01:10:32,420 --> 01:10:36,000
Basically people like the the search for like eldorado, 

1515
01:10:36,490 --> 01:10:38,080
the golden city in south america. 

1516
01:10:38,710 --> 01:10:41,640
There's been a search for some kind of hardware for databases for the last 40, 

1517
01:10:41,650 --> 01:10:42,200
50 years. 

1518
01:10:42,780 --> 01:10:43,700
It never pans out. 

1519
01:10:44,440 --> 01:10:46,440
People keep trying, but it never works,

1520
01:10:46,950 --> 01:10:47,770
but not that it doesn't work. 

1521
01:10:47,780 --> 01:10:52,420
It's just you it never gets the adoption in the market. 

1522
01:10:53,250 --> 01:10:54,630
Commodity harbor was always going to win. 

1523
01:10:55,410 --> 01:10:59,250
I don't think fpg as or gp us are aa big game changer in the space. 

1524
01:10:59,830 --> 01:11:01,830
Risk five, potentially some interesting stuff.

1525
01:11:02,140 --> 01:11:03,880
But where you're going to see hardware accelerates or databases

1526
01:11:03,890 --> 01:11:07,090
is only going to be from the cloud vendors like google, 

1527
01:11:07,410 --> 01:11:10,190
amazon, and microsoft, because it at their scale,

1528
01:11:10,200 --> 01:11:13,950
they can justify paying $50 million in development to build up new custom hardware, 

1529
01:11:13,960 --> 01:11:17,200
because they're going to make so much money and be more efficient for. 

1530
01:11:17,680 --> 01:11:18,520
There are millions of customers. 

1531
01:11:19,560 --> 01:11:20,120
It's very hard to be. 

1532
01:11:20,130 --> 01:11:22,000
I think it'd be very hard for independent software vendor, 

1533
01:11:22,010 --> 01:11:24,690
independent hardware vendor to break into that market, 

1534
01:11:24,700 --> 01:11:27,970
because either because not only had the design to chip or whatever

1535
01:11:27,980 --> 01:11:28,810
the hardware accelerator is, 

1536
01:11:28,820 --> 01:11:31,700
they didn't got to go convince some other software company to put it

1537
01:11:31,710 --> 01:11:32,220
in their database. 

1538
01:11:32,230 --> 01:11:33,840
And it never happens. 

1539
01:11:35,000 --> 01:11:36,540
We didn't really talk about array matrix, 

1540
01:11:36,550 --> 01:11:39,500
and the vector data sets the new buzzword now. 

1541
01:11:39,510 --> 01:11:40,260
Because of machine learning, 

1542
01:11:40,350 --> 01:11:44,400
there's much of these new nearest neighbor search on vector vectors in new database. 

1543
01:11:45,930 --> 01:11:47,020
These have been around for a while, 

1544
01:11:47,370 --> 01:11:48,730
but the vector ones are new. 

1545
01:11:49,070 --> 01:11:50,860
I would say this is the only, 

1546
01:11:51,230 --> 01:11:52,410
as far as I know for now, 

1547
01:11:52,840 --> 01:11:55,250
this is the only type of data you wouldn't actually want to use

1548
01:11:55,260 --> 01:11:57,890
a relational database system for where you want to use

1549
01:11:57,900 --> 01:11:59,730
a specialized system explicitly designed for vectors. 

1550
01:12:00,900 --> 01:12:04,070
Because when you think about it, what if it's a multinational array,

1551
01:12:04,440 --> 01:12:05,480
you've got to go traverse it, 

1552
01:12:05,490 --> 01:12:08,600
maybe row wise and column wise and in different dimensions, 

1553
01:12:09,030 --> 01:12:12,490
and storing that in a table with index columns is a bad idea. 

1554
01:12:14,240 --> 01:12:19,120
So I think we'll see whether the market is big enough to justify needing

1555
01:12:19,130 --> 01:12:20,240
a specialized system. 

1556
01:12:20,690 --> 01:12:22,490
At this point, the answer is no, as I say, in the paper,

1557
01:12:22,500 --> 01:12:26,430
because is there does amazon or microsoft or google offer a vector database

1558
01:12:26,440 --> 01:12:27,030
as a service? 

1559
01:12:27,370 --> 01:12:27,730
No. 

1560
01:12:28,540 --> 01:12:29,060
They could build one. 

1561
01:12:29,070 --> 01:12:30,740
They have unlimited money, 

1562
01:12:30,750 --> 01:12:33,710
but they don't see there being aa large market yet. 

1563
01:12:35,520 --> 01:12:38,640
So I think it's still too early, but I think this could be the next thing.

1564
01:12:40,180 --> 01:12:40,260
Right? 

1565
01:12:40,270 --> 01:12:42,100
And a there's a ton of these logos. 

1566
01:12:43,140 --> 01:12:43,850
It's hard to keep track. 

1567
01:12:47,200 --> 01:12:47,360
I clicked. 

1568
01:12:47,370 --> 01:12:49,330
All right. 

1569
01:12:52,300 --> 01:12:53,870
What's going to happen in the future? 

1570
01:12:53,880 --> 01:12:57,340
So I think right now we're in the golden era databases, 

1571
01:12:57,660 --> 01:13:00,500
meaning like there's so many different choices, open source,

1572
01:13:00,510 --> 01:13:02,200
commercial cloud systems on pram. 

1573
01:13:04,320 --> 01:13:07,360
Sequel is considered the way to go forward right now. 

1574
01:13:07,670 --> 01:13:08,910
Again, that'll change in 10 years,

1575
01:13:09,400 --> 01:13:10,590
but we'll be back again. 

1576
01:13:11,150 --> 01:13:13,150
An example would be all the new sql systems for 10 years ago, 

1577
01:13:13,160 --> 01:13:13,790
except for retis. 

1578
01:13:13,800 --> 01:13:15,720
I've either died, 

1579
01:13:16,440 --> 01:13:19,820
or they support sql and something that looks like the rational model. 

1580
01:13:23,370 --> 01:13:28,470
It's like1+1 equals 2 that basic arithmetic from thousands of years ago. 

1581
01:13:29,840 --> 01:13:31,520
It stands the test of time because it's the right way to do this. 

1582
01:13:32,040 --> 01:13:33,610
That's what I sort of see the relational model. 

1583
01:13:34,580 --> 01:13:36,460
Now sequel the best query language you could have

1584
01:13:36,470 --> 01:13:37,660
for a relational database system. 

1585
01:13:37,670 --> 01:13:38,100
No. 

1586
01:13:38,810 --> 01:13:40,760
There's obviously problems with it. 

1587
01:13:41,710 --> 01:13:48,570
But at this. there's so much buy and there's so much existing tooling

1588
01:13:49,970 --> 01:13:54,600
and utilities that assume the sql database system. 

1589
01:13:54,610 --> 01:13:57,210
It would be very hard for anybody to change that. 

1590
01:13:58,900 --> 01:13:59,100
Right? 

1591
01:13:59,110 --> 01:14:00,820
I there's so much fracturing in sequel itself, 

1592
01:14:00,830 --> 01:14:03,140
how you come along say I have a new query language, 

1593
01:14:03,980 --> 01:14:05,420
then everyone's going to start using it. 

1594
01:14:06,170 --> 01:14:07,290
Yeah, you could build your one system that does it,

1595
01:14:07,300 --> 01:14:08,550
but then nobody else is going to use it. 

1596
01:14:10,220 --> 01:14:13,760
So I don't know where sql is going to go with the future other than barring

1597
01:14:13,770 --> 01:14:18,060
ideas from other non sql systems. 

1598
01:14:18,800 --> 01:14:21,550
But I see the relational model being standing the test of time. 

1599
01:14:21,560 --> 01:14:22,070
In my opinion. 

1600
01:14:22,440 --> 01:14:24,330
There's a reason why ted kahn won the touring world war. 

1601
01:14:25,190 --> 01:14:26,830
Charles bachman won the turing wood for kodasal. 

1602
01:14:27,490 --> 01:14:27,520
First, 

1603
01:14:29,060 --> 01:14:30,010
the both days, it doesn't matter.

1604
01:14:30,460 --> 01:14:31,830
All right. 

1605
01:14:31,840 --> 01:14:32,470
So next class, 

1606
01:14:33,040 --> 01:14:35,160
I got to go deal with some courts in seattle. 

1607
01:14:35,680 --> 01:14:37,390
Next week will be not in person. 

1608
01:14:37,400 --> 01:14:40,030
I'll post the monday lecture and wednesday lecture on youtube. 

1609
01:14:40,400 --> 01:14:43,090
But we'll kick off starting talking about modern medical daily systems. 

1610
01:14:43,730 --> 01:14:45,960
And we'll read about the papers about snowflake. 

1611
01:14:45,970 --> 01:14:47,200
It's from the snowflake people. 

1612
01:14:48,050 --> 01:14:49,160
There's some details about snowflake, 

1613
01:14:49,170 --> 01:14:51,400
but I really want to understand the big idea of like running

1614
01:14:51,410 --> 01:14:52,840
on a shared disk architecture in the cloud. 

1615
01:14:53,760 --> 01:14:55,230
Make sure you submit your first reading of you

1616
01:14:56,790 --> 01:15:00,400
before the class on2 o'clock wednesday, 

1617
01:15:00,410 --> 01:15:00,760
right? 

1618
01:15:01,130 --> 01:15:01,840
I what did I say? 

1619
01:15:02,180 --> 01:15:03,570
No, there's no reading reviews.

1620
01:15:06,050 --> 01:15:08,740
No, there is a did I say tuesday?

1621
01:15:09,310 --> 01:15:11,290
No, I i'm just confused.

1622
01:15:11,540 --> 01:15:13,490
Make sure you spend your first reading for you. 

1623
01:15:13,880 --> 01:15:14,440
Monday. 

1624
01:15:18,320 --> 01:15:18,840
Awesome, guys.

1625
01:15:19,190 --> 01:15:19,380
Thank you. 

1626
01:15:19,390 --> 01:15:19,820
See you. 

1627
01:15:20,300 --> 01:15:23,050
Ha, that's my favorite all that.

1628
01:15:25,690 --> 01:15:26,120
What is it? 

1629
01:15:27,010 --> 01:15:28,560
It's the st cricket, 

1630
01:15:28,570 --> 01:15:35,780
idesi make a mess unless I can do it like ago ice cube with the g to the e

1631
01:15:35,790 --> 01:15:37,540
to the t here comes duke. 

1632
01:15:37,550 --> 01:15:38,460
I play the game. 

1633
01:15:38,470 --> 01:15:39,300
Where's no roof? 

1634
01:15:39,310 --> 01:15:40,500
And poem is on the custody. 

1635
01:15:40,510 --> 01:15:41,940
I'm a focus on drink fruit. 

1636
01:15:42,280 --> 01:15:44,830
Put the bus a cap on the eyes, bro, push.

1637
01:15:44,840 --> 01:15:47,150
We gonna go with a blow to the eyes. 

1638
01:15:48,600 --> 01:15:51,270
Indeed, that's me rolling with 5th one,

1639
01:15:51,280 --> 01:15:55,390
south park and south central g and thank us when I party. 

1640
01:15:55,760 --> 01:15:58,390
By the 12 pack case on the 46 pack, 

1641
01:15:58,400 --> 01:16:00,310
48 gets the real price. 

1642
01:16:00,610 --> 01:16:03,480
I drink fruit which are drinking about 12 hours, 

1643
01:16:03,490 --> 01:16:05,480
they say bill makes you fat, 

1644
01:16:05,490 --> 01:16:07,040
but saying eyes is straight, 

1645
01:16:07,050 --> 01:16:08,600
so it really don't matter. 
