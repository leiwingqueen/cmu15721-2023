1
00:00:04,670 --> 00:00:05,740
嘿 哟 哟

2
00:00:05,750 --> 00:00:07,540
把铬的声音包起来 就像夫人

3
00:00:07,550 --> 00:00:09,220
琼斯 利物浦数学

4
00:00:09,230 --> 00:00:10,780
我们有魔鬼说话的石头

5
00:00:10,890 --> 00:00:11,440
在我们开始搭讪的时候

6
00:00:11,450 --> 00:00:14,480
床上弄了一些小镜头

7
00:00:14,490 --> 00:00:16,640
每个人都会和我们一起开始

8
00:00:17,200 --> 00:00:19,610
我在纽约很容易就能抓到两个人 埃文

9
00:00:19,620 --> 00:00:23,630
然后布鲁克林的dva是西雅图最好的监狱 他们把希腊人关起来了

10
00:00:23,930 --> 00:00:26,650
这些人帮助我们走出困境 忠于我们

11
00:00:26,660 --> 00:00:27,280
从一开始

12
00:00:27,910 --> 00:00:30,980
我要感谢卡内基梅隆大学没有再解雇我一年

13
00:00:31,310 --> 00:00:31,880
这总是很重要的

14
00:00:32,680 --> 00:00:36,110
这学期的核心赞助商将是亚马逊

15
00:00:36,580 --> 00:00:41,410
就市值而言 亚马逊是世界上最大的数据库供应商

16
00:00:41,420 --> 00:00:42,250
他们赚了多少钱

17
00:00:42,890 --> 00:00:43,250
对的

18
00:00:43,480 --> 00:00:45,090
他们在商店上赚了所有的钱

19
00:00:45,410 --> 00:00:48,400
在aws上赚了很多钱 但他们在数据库上赚了很多钱

20
00:00:48,800 --> 00:00:53,170
红移极光或发电机DB他们有一吨的东西

21
00:00:54,600 --> 00:00:55,920
通常甲骨文是第一名

22
00:00:55,930 --> 00:00:58,160
事实上 也许微软在一段时间内也是第一

23
00:00:58,800 --> 00:01:04,530
亚马逊（Amazon）是官方排名第一的公司 而微软（Microsoft）可能是排名第100的公司

24
00:01:04,540 --> 00:01:05,770
不管他们赚了多少钱

25
00:01:07,290 --> 00:01:10,190
不管怎样 他们正在帮助我们安排课程的后勤工作 赞助商也去了

26
00:01:11,850 --> 00:01:12,840
我们对此非常感激

27
00:01:13,200 --> 00:01:14,240
然后到了学期末

28
00:01:15,800 --> 00:01:18,480
红移团队的人会来做一个关于他们正在建造的

29
00:01:18,490 --> 00:01:19,640
系统的技术演讲

30
00:01:19,650 --> 00:01:21,920
我们将在整个学期中讨论红移

31
00:01:23,360 --> 00:01:25,550
很多技术将在学期中描述

32
00:01:26,230 --> 00:01:28,580
他们实际上在他们的系统中实施

33
00:01:30,280 --> 00:01:33,470
我很快就想回顾一下课程的逻辑和本学期的预期

34
00:01:33,480 --> 00:01:34,030
但我肯定

35
00:01:34,040 --> 00:01:36,350
花了大部分时间在数据库的历史上

36
00:01:36,360 --> 00:01:37,930
因为我觉得这部分更有趣

37
00:01:37,940 --> 00:01:40,680
然后当我在周末发出电子邮件时

38
00:01:41,430 --> 00:01:42,940
它将基于两个读数

39
00:01:44,250 --> 00:01:48,530
同样 它并不意味着要深入到数据系统的内部

40
00:01:48,910 --> 00:01:51,330
只是为了让您了解前景是什么样子的

41
00:01:51,630 --> 00:01:53,160
为什么我们一直在讨论关系数据库

42
00:01:53,170 --> 00:01:55,000
而不是其他东西

43
00:01:56,450 --> 00:01:59,370
所以你们中的很多人来这里的原因很明显 你们想上这门课

44
00:02:00,200 --> 00:02:01,470
但就像最后的演讲一样

45
00:02:01,480 --> 00:02:07,070
我要说的是我们这学期讨论的数据库系统

46
00:02:07,080 --> 00:02:08,950
特别是分析数据库系统

47
00:02:10,050 --> 00:02:12,120
这些都是永远做不到的难题

48
00:02:12,680 --> 00:02:15,910
公司为学生支付了很多钱

49
00:02:16,420 --> 00:02:19,790
而不是从其他地方来上这门课

50
00:02:19,800 --> 00:02:20,830
因为他们有数据库系统的工作经验

51
00:02:22,550 --> 00:02:24,180
如果你只是一个随机的JavaScript程序员

52
00:02:25,030 --> 00:02:27,070
他们不会以同样的方式接触Davis和Turtles

53
00:02:27,080 --> 00:02:30,030
他们不会触及操作系统的内核 对吗

54
00:02:30,360 --> 00:02:32,220
他们不想让人们离开这条街

55
00:02:32,230 --> 00:02:35,350
他们希望人们从根本上了解这些系统是如何工作的

56
00:02:35,720 --> 00:02:37,130
这些就是我们要讲的内容

57
00:02:38,200 --> 00:02:39,740
这不是完整的名单

58
00:02:39,750 --> 00:02:42,700
但这些只是一些以前和我们一起上这门课的学生

59
00:02:43,410 --> 00:02:46,000
以及他们去过的地方

60
00:02:47,580 --> 00:02:50,540
这些是我有照片的 比我错过的要多得多

61
00:02:51,720 --> 00:02:53,370
但这些是我能很快找到的

62
00:02:54,730 --> 00:02:56,810
他们中的三个和我一起在我的创业公司AutoGen工作

63
00:02:57,280 --> 00:02:58,390
其中一些也是最好的

64
00:02:59,380 --> 00:02:59,590
好吧

65
00:02:59,600 --> 00:03:03,410
所以不像前几年

66
00:03:03,420 --> 00:03:05,050
你可能会在内存中讨论数据库系统

67
00:03:05,550 --> 00:03:08,640
并花一点时间讨论事务系统

68
00:03:09,940 --> 00:03:13,690
这学期 我们将只关注分析型数据库系统

69
00:03:15,580 --> 00:03:18,160
只是因为这是现在最热门的事情

70
00:03:18,490 --> 00:03:21,010
有大量的资金在许多正在建设的系统中流动

71
00:03:21,980 --> 00:03:24,770
为了理解 我们想要了解艺术的现状

72
00:03:24,780 --> 00:03:27,090
以及我们是如何走到今天这一步的

73
00:03:28,120 --> 00:03:30,750
你们的目标是

74
00:03:30,760 --> 00:03:31,830
我们不仅要了解这些系统实际上是什么

75
00:03:32,130 --> 00:03:35,030
它们的关键特性是什么 它们可以帮助您了解一种

76
00:03:35,040 --> 00:03:37,900
系统设计或实现与另一种系统设计或实现之间的

77
00:03:37,910 --> 00:03:38,420
权衡

78
00:03:39,460 --> 00:03:42,730
希望你也能熟练地编写高质量的系统代码

79
00:03:43,120 --> 00:03:43,260
对吗

80
00:03:43,270 --> 00:03:45,300
做文档和测试 做代码审查

81
00:03:45,560 --> 00:03:45,580
对的

82
00:03:45,590 --> 00:03:48,580
这些都是软技能 当你在现实世界中进行新

83
00:03:48,590 --> 00:03:49,540
系统开发时

84
00:03:49,940 --> 00:03:52,630
这些技能可能很重要 这不像任何课程所说的

85
00:03:52,640 --> 00:03:53,730
这是如何编写文档

86
00:03:54,080 --> 00:03:55,020
下面是如何编写测试代码

87
00:03:55,550 --> 00:03:57,840
这只是你在前进的过程中必须学会的东西

88
00:03:58,200 --> 00:04:00,830
这些项目将被设计成这样

89
00:04:00,840 --> 00:04:04,140
你将接触到这些关于如何在数据系统上工作的最佳实践

90
00:04:05,450 --> 00:04:07,820
本课程也只会涵盖最先进的主题

91
00:04:08,360 --> 00:04:10,030
我假设每个人都上过数据库课程

92
00:04:10,040 --> 00:04:12,130
要么是上学期 要么是四四五六 45

93
00:04:12,560 --> 00:04:13,080
你是个大学生

94
00:04:13,090 --> 00:04:16,080
我们不会讨论什么是联合的基础知识 对吧

95
00:04:16,580 --> 00:04:16,910
说起来

96
00:04:17,480 --> 00:04:18,990
我们假设如何进行哈希连接

97
00:04:19,380 --> 00:04:21,850
我们将讨论如何并行地做 让它运行得更快

98
00:04:23,850 --> 00:04:25,000
我们将要讨论的主题

99
00:04:26,140 --> 00:04:28,690
首先 开始讨论存储模型和压缩

100
00:04:28,700 --> 00:04:32,780
实际上 如何表示磁盘上文件中的数据

101
00:04:33,240 --> 00:04:35,930
然后

102
00:04:35,940 --> 00:04:38,450
我们将讨论如何使用向量化和编译等现代技术来执行查询

103
00:04:38,850 --> 00:04:40,890
然后 我们将讨论现代连接算法

104
00:04:41,520 --> 00:04:45,110
网络协议将数据中的内容输入和输出数据库

105
00:04:45,550 --> 00:04:47,910
然后 我们将花一点时间讨论如何进行查询优化

106
00:04:48,700 --> 00:04:51,400
这比我们在inter类中讨论的要深入得多

107
00:04:51,920 --> 00:04:52,910
如果你看一下时间表

108
00:04:52,920 --> 00:04:57,810
最后四到五节课实际上是针对单一数据库系统的

109
00:04:58,420 --> 00:05:00,520
有一个关于雪花的讲座

110
00:05:00,530 --> 00:05:03,990
一个关于数据砖块的讲座 一个关于戏剧大查询的讲座

111
00:05:04,480 --> 00:05:07,070
我的想法是

112
00:05:07,080 --> 00:05:07,950
我们想把我们整个学期讨论的所有事情

113
00:05:09,470 --> 00:05:10,460
了解它们的基础知识

114
00:05:10,470 --> 00:05:13,060
然后看看实现所有这些功能的真实系统

115
00:05:13,520 --> 00:05:16,120
试着去理解 他们为什么要以某种方式做这件事

116
00:05:16,130 --> 00:05:17,960
或者有什么好处

117
00:05:17,970 --> 00:05:20,840
或者他们所采取的方法的缺点是什么

118
00:05:25,840 --> 00:05:29,600
再说一次 我假设你上过戴维斯的入门课程

119
00:05:30,080 --> 00:05:33,530
我们不打算介绍SQL的基础知识和其他内容

120
00:05:35,130 --> 00:05:37,330
所有的网站都是最新的

121
00:05:37,340 --> 00:05:40,310
我还没有更新主页

122
00:05:41,070 --> 00:05:46,170
因为我试着 我试着用多莉来做最后的晚餐 在中间

123
00:05:47,050 --> 00:05:48,520
效果不是很好

124
00:05:48,810 --> 00:05:49,890
不管怎样 我得继续努力

125
00:05:49,900 --> 00:05:51,490
所以网站是最新的

126
00:05:51,500 --> 00:05:54,070
所以教学大纲和时间表都在那里

127
00:05:54,510 --> 00:05:56,530
在大多数情况下 它是稳定的

128
00:05:57,570 --> 00:06:00,040
所以 如果你明白这门课对你的期望

129
00:06:00,050 --> 00:06:00,960
请去看看

130
00:06:01,590 --> 00:06:04,580
我会在开始的时候说几次 对吗

131
00:06:05,090 --> 00:06:06,200
对于学术诚信

132
00:06:06,430 --> 00:06:08,200
再次强调 这是高级水平课程

133
00:06:08,210 --> 00:06:09,640
我想这里的每个人都很聪明

134
00:06:09,990 --> 00:06:11,010
因此 你不需要作弊

135
00:06:11,350 --> 00:06:15,570
如果你作弊 我们会把你带到华纳大厅去处理

136
00:06:17,470 --> 00:06:18,130
如果你有疑问

137
00:06:18,140 --> 00:06:19,690
如果你不确定是否要做一些事情

138
00:06:19,700 --> 00:06:21,450
比如我有一个人在Get Hub中编写的愚蠢的代码

139
00:06:21,460 --> 00:06:22,570
我可以在我的项目中使用它吗

140
00:06:22,580 --> 00:06:23,980
如果你不确定

141
00:06:24,320 --> 00:06:31,120
那就在助教那里问问我自己 我的办公时间是周一和周三

142
00:06:31,170 --> 00:06:32,520
上课前的一小时

143
00:06:32,960 --> 00:06:34,160
在楼上的一层

144
00:06:34,530 --> 00:06:35,790
然后我们可以谈论任何你想要的东西

145
00:06:35,800 --> 00:06:37,510
任何项目和论文

146
00:06:37,920 --> 00:06:38,800
如何获取数据库作业

147
00:06:38,810 --> 00:06:39,920
我有一堆数据库衬衫

148
00:06:39,930 --> 00:06:41,200
我的办公室 公司派我来的

149
00:06:41,590 --> 00:06:43,370
请来买一些

150
00:06:43,750 --> 00:06:46,060
因为我有点囤积症

151
00:06:46,070 --> 00:06:47,220
因为他们在流感大流行期间给我送来了一堆

152
00:06:47,230 --> 00:06:48,340
我有一堆盒子

153
00:06:48,350 --> 00:06:49,620
我得开始摆脱他们了

154
00:06:49,630 --> 00:06:51,070
所以来和我谈谈

155
00:06:52,010 --> 00:06:54,910
我们有一个助教 当他很棒的时候

156
00:06:55,690 --> 00:06:57,280
他是我三年级的博士生

157
00:06:57,620 --> 00:06:58,300
这是真的

158
00:06:58,310 --> 00:07:00,830
他以前是Sketchy律师事务所的律师助理

159
00:07:01,050 --> 00:07:02,510
他是一名持证养鸡户

160
00:07:03,230 --> 00:07:06,740
他是卡内基梅隆大学排名第一的博士生

161
00:07:06,750 --> 00:07:08,060
因为数据库的数据非常清晰

162
00:07:08,460 --> 00:07:10,500
所以 再说一次 他会帮我做项目

163
00:07:10,510 --> 00:07:12,940
他将成为我们这学期谈话的一部分

164
00:07:14,280 --> 00:07:15,630
所以一定要利用他

165
00:07:15,640 --> 00:07:16,270
如果你有问题

166
00:07:18,420 --> 00:07:20,530
期望是33件事

167
00:07:20,540 --> 00:07:22,730
有阅读作业 项目和期末考试

168
00:07:23,710 --> 00:07:25,350
除了今天的课

169
00:07:25,360 --> 00:07:26,430
每节课都会有一篇指定阅读

170
00:07:26,820 --> 00:07:29,190
它们将由此处的图标指示

171
00:07:30,490 --> 00:07:37,990
我将在Piazza上发布这些阅读评论中真正期待的内容

172
00:07:38,000 --> 00:07:41,520
但我想让你们了解的主要想法是

173
00:07:41,530 --> 00:07:42,400
阅读论文 理解他们在做什么

174
00:07:43,180 --> 00:07:45,120
理解我们讨论的所有事情

175
00:07:45,350 --> 00:07:47,230
如何把它放在一个更高的系统中

176
00:07:47,240 --> 00:07:48,630
一个更高层次的系统中

177
00:07:48,640 --> 00:07:48,750
然后

178
00:07:49,440 --> 00:07:49,930
我也很好奇

179
00:07:49,940 --> 00:07:52,450
我不明白您要评估

180
00:07:52,460 --> 00:07:56,620
分析数据库实施的工作负载是什么

181
00:07:56,630 --> 00:07:59,620
最有可能的是一次又一次的TPCH和TPCD

182
00:08:00,040 --> 00:08:01,500
知道这些东西是什么是很好的

183
00:08:01,510 --> 00:08:05,470
这样当我们进入项目一

184
00:08:05,840 --> 00:08:08,150
项目二或项目三时

185
00:08:08,160 --> 00:08:08,950
你就会根据你读过的论文知道你可以使用哪些工作负载

186
00:08:09,590 --> 00:08:11,350
这里有一个实时的谷歌表单

187
00:08:11,360 --> 00:08:12,550
然后会有一个下拉菜单

188
00:08:12,560 --> 00:08:13,110
你把它填好

189
00:08:13,120 --> 00:08:13,510
是的

190
00:08:15,600 --> 00:08:16,230
应该是三个

191
00:08:16,510 --> 00:08:17,460
你可以跳过三次阅读

192
00:08:17,770 --> 00:08:18,500
对不起 我会解决的

193
00:08:18,990 --> 00:08:19,280
谢谢

194
00:08:20,210 --> 00:08:23,220
再次 所有这些评论都必须是你自己写的

195
00:08:23,950 --> 00:08:25,060
有些论文写得很好

196
00:08:25,070 --> 00:08:26,220
他们就像上周出来的一样

197
00:08:26,230 --> 00:08:28,260
所以他们可能不会在互联网上发表评论

198
00:08:28,270 --> 00:08:28,860
你可以用

199
00:08:31,220 --> 00:08:33,140
你可以试试聊天GPT 看看会发生什么

200
00:08:37,260 --> 00:08:39,010
项目一 我们将在下周发布

201
00:08:39,320 --> 00:08:42,090
但你基本上要为后图 过程

202
00:08:42,600 --> 00:08:44,910
柱状数据格式编写一个外来数据包装器 就像一个镶木文件

203
00:08:45,200 --> 00:08:49,030
这里的想法只是向您展示如何在post图的上下文

204
00:08:49,570 --> 00:08:50,710
中执行向量

205
00:08:50,720 --> 00:08:52,230
所以我们不用担心做SQL解析

206
00:08:52,240 --> 00:08:53,970
我们不用担心进行查询计划

207
00:08:53,980 --> 00:08:55,330
让明信片来处理这一切

208
00:08:55,750 --> 00:08:58,880
这里的想法是 你可以在列上的

209
00:08:58,890 --> 00:09:01,520
自定义引擎和我们的数据与后

210
00:09:01,530 --> 00:09:03,200
压力之间进行权衡

211
00:09:03,210 --> 00:09:05,000
基于行的迭代器模型

212
00:09:05,890 --> 00:09:07,170
再说一次 我说的有意义吗

213
00:09:07,180 --> 00:09:10,530
那就不好了 因为我们在课堂上讨论了这些东西

214
00:09:11,320 --> 00:09:14,670
但至少要确保回去看看它们

215
00:09:14,680 --> 00:09:15,230
并理解我在说什么

216
00:09:15,920 --> 00:09:17,120
同样 我们将在下周发布这篇文章

217
00:09:17,800 --> 00:09:21,360
项目二将为百科全书写一篇文章

218
00:09:21,810 --> 00:09:23,300
所以我们有一个数据库百科全书

219
00:09:23,310 --> 00:09:26,760
因此 我所知道的每一个数据库的想法都是

220
00:09:26,770 --> 00:09:28,640
你去看看文档 去阅读

221
00:09:28,650 --> 00:09:29,760
甚至可能运行这些系统

222
00:09:29,770 --> 00:09:30,880
去与开发人员交谈

223
00:09:31,230 --> 00:09:34,310
了解他们如何实现我们所关心的系统的这些

224
00:09:34,320 --> 00:09:35,270
不同部分

225
00:09:35,770 --> 00:09:38,080
你将为此写一篇文章

226
00:09:38,090 --> 00:09:38,640
好吧

227
00:09:39,380 --> 00:09:40,490
不要抄袭

228
00:09:40,540 --> 00:09:42,530
避免使用营销语言

229
00:09:43,020 --> 00:09:45,130
有时我让公司访问网站

230
00:09:45,430 --> 00:09:49,080
他们会说 我的数据库是最快的 对吗

231
00:09:49,090 --> 00:09:50,040
我们必须把这些都去掉

232
00:09:51,150 --> 00:09:53,650
只说那些你可以用具体的声明来支持的事情

233
00:09:54,970 --> 00:09:55,080
对的

234
00:09:55,290 --> 00:09:57,910
我们更关心内部 而不是人们对数据库的感觉

235
00:09:57,920 --> 00:09:59,230
如果这是有意义的话

236
00:10:01,090 --> 00:10:02,760
项目三将是小组项目

237
00:10:03,010 --> 00:10:07,890
这里的想法是一些你感兴趣的更大的主题

238
00:10:07,900 --> 00:10:09,990
这是基于我们整个学期所讨论的事情

239
00:10:10,460 --> 00:10:12,430
它不一定要在postgres 但如果你想

240
00:10:12,980 --> 00:10:13,510
它可以

241
00:10:14,870 --> 00:10:18,840
这里的想法是

242
00:10:18,850 --> 00:10:22,250
你只是想建立一些东西

243
00:10:22,260 --> 00:10:22,970
展示对我们在这些大师中讨论的材料的掌握的一些理解

244
00:10:24,690 --> 00:10:27,010
再一次 当我们接近的时候 我会发布一些主题

245
00:10:27,020 --> 00:10:28,370
你想晚些时候决定 直到三月

246
00:10:28,380 --> 00:10:29,490
你到底想做什么

247
00:10:30,990 --> 00:10:32,390
我对我想做的事情有一些想法

248
00:10:32,400 --> 00:10:34,110
这可能会变成一篇简短的论文

249
00:10:34,600 --> 00:10:35,770
或者像一个捕捉项目

250
00:10:36,180 --> 00:10:38,210
同样 我们可以边走边讨论

251
00:10:39,410 --> 00:10:40,610
再说一次 不要抄袭

252
00:10:40,620 --> 00:10:43,130
你所有的代码都必须是你提交给我们的代码 必须是你的

253
00:10:43,140 --> 00:10:47,800
除非你在百科全书中讨论并引用了同样的东西

254
00:10:47,810 --> 00:10:53,260
请不要只是从互联网上随机复制的东西

255
00:10:53,270 --> 00:10:55,980
一年前 有人从维基掌上电脑复制

256
00:10:55,990 --> 00:10:58,920
他们有一些类似的文字 然后是方括号

257
00:10:58,930 --> 00:10:59,550
然后是引用的数字

258
00:10:59,560 --> 00:11:04,010
所以我们不得不再次处理这件事

259
00:11:04,220 --> 00:11:07,030
所以我一直在展示这个的原因是因为这个现在在视频上

260
00:11:07,320 --> 00:11:09,270
因为如果你们真的剽窃了

261
00:11:09,770 --> 00:11:11,330
我就去告发你们

262
00:11:11,340 --> 00:11:15,470
我给他们看YouTube上的视频链接 或者说 我在这里讨论这个

263
00:11:16,030 --> 00:11:16,680
你完蛋了

264
00:11:18,430 --> 00:11:20,220
将会有一次期末考试 但它会被带回家

265
00:11:20,490 --> 00:11:21,310
长格式问题

266
00:11:21,320 --> 00:11:24,150
我试着和GBT聊天 但它无法回答他们

267
00:11:25,420 --> 00:11:29,010
所以谁知道会有多好呢

268
00:11:29,020 --> 00:11:30,410
所以要么是喜欢

269
00:11:31,730 --> 00:11:35,610
我想知道这是否是聊天GBT的限制 或者我的问题是否很糟糕

270
00:11:36,200 --> 00:11:41,080
它不能解析它们 和你一起表演真的很糟糕

271
00:11:41,090 --> 00:11:43,240
就像你可以很好地回答基本的计算机科学问题

272
00:11:43,250 --> 00:11:44,920
但一旦你和专家打交道

273
00:11:44,930 --> 00:11:48,570
你就会掉链子 但很糟糕

274
00:11:48,580 --> 00:11:50,570
但它说的是琥珀

275
00:11:50,580 --> 00:11:51,530
所以你认为这是正确的

276
00:11:51,620 --> 00:11:54,090
就像多版本当前控制很重要

277
00:11:54,100 --> 00:11:55,370
因为它像Thanks一样进行多版本控制

278
00:11:56,220 --> 00:11:57,710
这就是它告诉我的

279
00:11:59,860 --> 00:11:59,970
对的

280
00:11:59,980 --> 00:12:01,170
灰色分解是这样的

281
00:12:01,180 --> 00:12:02,330
同样 这是在教学大纲上

282
00:12:03,340 --> 00:12:04,650
这里没有太大的惊喜

283
00:12:05,050 --> 00:12:07,140
然后是合唱团的邮件列表 所有的东西都会在广场上

284
00:12:07,150 --> 00:12:09,760
如果你有任何关于项目一和潜在项目三的技术问题

285
00:12:09,770 --> 00:12:11,490
在我们进行的

286
00:12:11,500 --> 00:12:12,570
过程中

287
00:12:13,430 --> 00:12:14,540
请在广场上发帖

288
00:12:14,550 --> 00:12:16,580
不要直接给自己发电子邮件

289
00:12:17,230 --> 00:12:19,910
如果你有任何健康问题

290
00:12:19,920 --> 00:12:21,260
无论你有什么问题

291
00:12:21,810 --> 00:12:22,540
请直接发电子邮件

292
00:12:24,040 --> 00:12:24,750
对此有什么问题吗

293
00:12:27,770 --> 00:12:28,840
让我们来看看这个数据库

294
00:12:30,080 --> 00:12:30,090
是啊

295
00:12:30,100 --> 00:12:31,480
一年前有人在YouTube上抱怨

296
00:12:31,490 --> 00:12:34,320
如果你花了25分钟讨论课程的后勤工作

297
00:12:34,330 --> 00:12:35,160
那就是好东西

298
00:12:35,170 --> 00:12:36,460
所以我们在这里

299
00:12:37,300 --> 00:12:38,010
正如我所说

300
00:12:38,540 --> 00:12:41,060
这是我过去50

301
00:12:41,070 --> 00:12:42,260
60年数据库的桥梁历史

302
00:12:43,090 --> 00:12:45,040
因此 我们不会深入讨论任何一个主题

303
00:12:45,050 --> 00:12:50,240
但我们将对这一领域进行概述

304
00:12:50,790 --> 00:12:54,610
我认为真正有趣的是

305
00:12:54,620 --> 00:12:59,520
数据库目前在研究和行业中都是一个热门领域

306
00:12:59,530 --> 00:13:02,280
但他们已经60岁了

307
00:13:02,290 --> 00:13:04,240
第一个是20世纪60年代的

308
00:13:05,330 --> 00:13:05,750
对的

309
00:13:06,070 --> 00:13:09,040
它只是告诉你它们有多重要 问题有多难

310
00:13:09,050 --> 00:13:09,480
如果喜欢

311
00:13:10,090 --> 00:13:12,280
这显然不是一个解决的问题

312
00:13:13,560 --> 00:13:16,950
这节课是从两篇论文中衍生出来的

313
00:13:16,960 --> 00:13:19,740
第一本书名为《What Goes Around Comes Around》

314
00:13:19,750 --> 00:13:23,180
由迈克·斯特恩·巴克（Mike Stern Bakker）和乔·海勒斯·斯坦（Joe Heller Stein）于2006年撰写

315
00:13:23,740 --> 00:13:31,700
这基本上是迈克对数据库行业的评价

316
00:13:31,710 --> 00:13:33,780
以及他在过去40年里是如何正确的

317
00:13:34,800 --> 00:13:36,390
迈克在2014年赢得了巡回演出奖

318
00:13:36,400 --> 00:13:38,630
所以我同意他的观点

319
00:13:38,960 --> 00:13:40,850
然后是论文 我寄给你的另一份草稿

320
00:13:40,860 --> 00:13:41,420
这是迈克

321
00:13:41,430 --> 00:13:46,950
我去年写了这篇文章 我们基本上是从这篇论文停止的地方开始的

322
00:13:46,960 --> 00:13:49,750
然后说接下来的16年和17年是什么

323
00:13:50,110 --> 00:13:51,430
这实际上是由我引发的

324
00:13:51,800 --> 00:13:54,350
因为有一些像邮差黑客新闻之类的人

325
00:13:54,360 --> 00:13:56,560
我不知道为什么人们一直在使用关系数据库

326
00:13:56,570 --> 00:13:57,760
图形数据库是一条可行之路

327
00:13:57,770 --> 00:13:59,160
我想 好吧

328
00:13:59,250 --> 00:14:01,400
我说麦克风 让我们写新的

329
00:14:05,450 --> 00:14:06,120
主要带走

330
00:14:06,130 --> 00:14:08,880
你们从这里得到的是

331
00:14:08,890 --> 00:14:10,480
即使数据库真的很老

332
00:14:10,490 --> 00:14:11,800
这个概念也很老

333
00:14:12,190 --> 00:14:14,080
它们在今天是高度相关的

334
00:14:14,090 --> 00:14:16,690
因为前几天 每个应用程序

335
00:14:17,200 --> 00:14:18,070
它们本质上在做什么

336
00:14:19,380 --> 00:14:19,450
对的

337
00:14:20,060 --> 00:14:24,270
它们为人类或另一台机器或与数据库

338
00:14:24,280 --> 00:14:27,910
交互的东西公开了一些用户界面

339
00:14:29,370 --> 00:14:29,830
对的

340
00:14:30,850 --> 00:14:34,600
有趣的是这学期要讲的很多东西

341
00:14:34,940 --> 00:14:36,180
这些都不是新的想法

342
00:14:36,190 --> 00:14:37,380
它们不是新概念

343
00:14:37,950 --> 00:14:39,430
我要去看看 我在安德鲁的课上说过

344
00:14:39,440 --> 00:14:42,470
我会在整个学期里一遍又一遍地说这句话

345
00:14:42,820 --> 00:14:45,630
IBM在20世纪70年代做了很多这样的事情

346
00:14:46,500 --> 00:14:48,340
很明显 港口很不一样

347
00:14:48,730 --> 00:14:49,770
前景是非常不同的

348
00:14:49,780 --> 00:14:53,390
但我们将谈论的许多东西将只是ibm

349
00:14:53,400 --> 00:14:54,550
发明的现代化身

350
00:14:55,520 --> 00:14:56,110
几年前

351
00:14:56,760 --> 00:14:58,550
我们将花一整堂课的时间来讲解查询编译

352
00:14:58,960 --> 00:14:59,910
如何将Segal查询转换为查询计划

353
00:14:59,920 --> 00:15:04,070
然后将该查询计划转换为机器码

354
00:15:04,960 --> 00:15:06,520
IBM在20世纪70年代就这样做了

355
00:15:06,530 --> 00:15:08,550
这是系统R 他们在一个组件中做的

356
00:15:09,300 --> 00:15:13,460
现在我们使用LBM 但同样 这些技术并不是新的

357
00:15:13,470 --> 00:15:16,910
另一件大事将会发生 在你的余生中

358
00:15:16,920 --> 00:15:22,130
你会看到每隔10年

359
00:15:22,140 --> 00:15:23,210
就会有人走过来说 嘿 续集是愚蠢的

360
00:15:23,550 --> 00:15:25,440
关系模型很慢 对吧

361
00:15:25,980 --> 00:15:26,690
我们可以做得更好

362
00:15:26,700 --> 00:15:30,890
这是我的新数据系统 不使用 至少模型是平等的

363
00:15:31,620 --> 00:15:31,730
对的

364
00:15:32,260 --> 00:15:33,535
每个人都会很兴奋 就像未来的sql

365
00:15:33,535 --> 00:15:34,810
是旧的

366
00:15:34,810 --> 00:15:35,050


367
00:15:35,060 --> 00:15:36,530
续集是失败的 我们不想用它

368
00:15:37,040 --> 00:15:40,270
然后看吧 人们意识到关系模型是一个好主意

369
00:15:40,280 --> 00:15:40,715
或者sql

370
00:15:40,715 --> 00:15:41,150
是一个好主意

371
00:15:41,150 --> 00:15:42,070


372
00:15:43,380 --> 00:15:45,970
要么是新发明出现

373
00:15:46,290 --> 00:15:47,270
要么是失败

374
00:15:48,400 --> 00:15:52,650
或者这个新的想法

375
00:15:52,660 --> 00:15:56,220
这个新的概念或者新的数据系统有字母的任何想法被采纳

376
00:15:57,230 --> 00:15:58,900
按照续集的标准和种族模式

377
00:15:59,550 --> 00:16:00,480
然后那东西就消失了

378
00:16:00,490 --> 00:16:01,900
好吧

379
00:16:02,460 --> 00:16:04,100
所以我想我在自己的生活中已经看到了这一点

380
00:16:04,470 --> 00:16:05,760
就像没有续集是一件热门的事情

381
00:16:06,380 --> 00:16:08,350
人们说sql慢 sql愚蠢

382
00:16:08,590 --> 00:16:10,130
关系型模型也是

383
00:16:10,140 --> 00:16:11,860
但你想做文档 你需要json和每个人都建立了所有这些json

384
00:16:11,860 --> 00:16:13,580
数据库

385
00:16:14,110 --> 00:16:14,290
对的

386
00:16:14,300 --> 00:16:18,120
然后现在我们到了也许这对一切都是个坏主意的地步

387
00:16:18,960 --> 00:16:20,260
json对某些事情很在行

388
00:16:20,430 --> 00:16:22,250
关系型模型现在支持json

389
00:16:23,880 --> 00:16:27,080
然后所有没有续集的系统都说sql是个坏主意

390
00:16:27,680 --> 00:16:29,970
除了redis 他们每个人都支持sql

391
00:16:30,570 --> 00:16:30,650
对吧

392
00:16:30,660 --> 00:16:32,170
去年mongo支持看

393
00:16:33,630 --> 00:16:33,980
对的

394
00:16:33,990 --> 00:16:35,940
所以你会在整个主题中看到这一点

395
00:16:35,950 --> 00:16:39,530
至少一旦我们过去了

396
00:16:39,540 --> 00:16:39,910
一旦种族模式被发明出来

397
00:16:40,530 --> 00:16:42,540
人们每10年就会说这是愚蠢的

398
00:16:43,040 --> 00:16:48,100
结果发现是马克在我的冲浪板上

399
00:16:48,110 --> 00:16:48,460
你的余生都会看到这个

400
00:16:48,770 --> 00:16:49,220
我向你保证

401
00:16:51,120 --> 00:16:52,670
让我们从头开始

402
00:16:54,170 --> 00:16:55,050
1960年代

403
00:16:55,910 --> 00:16:57,470
所以据我所知

404
00:16:57,960 --> 00:16:59,830
至少被认为是传统智慧

405
00:17:00,320 --> 00:17:02,050
第一个数据库系统

406
00:17:03,290 --> 00:17:05,010
我们的通用数据库系统

407
00:17:05,560 --> 00:17:11,170
被称为集成数据存储或iids 我说的通用

408
00:17:11,180 --> 00:17:15,570
我的意思是它是一个数据库系统

409
00:17:16,310 --> 00:17:18,460
旨在支持任意数据集或数据库

410
00:17:19,040 --> 00:17:19,270
对的

411
00:17:19,400 --> 00:17:19,790
显然

412
00:17:19,800 --> 00:17:22,870
您可以自己编写一个小型Python应用程序并读写文件

413
00:17:22,880 --> 00:17:25,190
这只是一个数据库

414
00:17:25,540 --> 00:17:27,610
这不是我的意思 就像那些东西存在一样

415
00:17:28,050 --> 00:17:31,270
但这特别是说

416
00:17:31,280 --> 00:17:34,700
我们可以将该系统重新用于另一个应用程序或另一个客户

417
00:17:36,170 --> 00:17:37,480
通用电气得到了这个

418
00:17:38,730 --> 00:17:41,830
这就像西雅图的一些木材公司有一个巨大的库存跟踪问题

419
00:17:41,840 --> 00:17:46,860
他们需要处理

420
00:17:47,170 --> 00:17:49,160
并说他们建立了一个叫做IDS的东西来处理这个问题

421
00:17:51,140 --> 00:17:55,490
他们最终将其从木材公司的定制解决方案中分离出来

422
00:17:55,800 --> 00:17:58,100
并试图将其作为独立产品销售

423
00:17:58,350 --> 00:17:58,360
对的

424
00:17:58,370 --> 00:17:59,950
就像通用电气试图成为一家软件供应商一样

425
00:18:01,280 --> 00:18:05,580
GE现在是计算机领域的热门产品吗

426
00:18:05,590 --> 00:18:05,740
不

427
00:18:06,090 --> 00:18:06,470
对的

428
00:18:06,990 --> 00:18:13,050
所以他们犯了一个巨大的错误

429
00:18:13,060 --> 00:18:15,580
他们当时的公司政策是

430
00:18:16,330 --> 00:18:18,340
如果我们在某个行业不是第一

431
00:18:18,680 --> 00:18:19,840
我们就根本不想进入这个行业

432
00:18:20,090 --> 00:18:22,990
所以他们就像是排名第三的电脑销售商

433
00:18:23,000 --> 00:18:23,510
对他们来说不够好

434
00:18:23,520 --> 00:18:26,230
所以他们把计算机部门卖给了honeywell

435
00:18:27,430 --> 00:18:27,610
对的

436
00:18:27,780 --> 00:18:33,100
然后霍尼韦尔拥有自己的ID

437
00:18:33,650 --> 00:18:34,110
然后他们卖了一段时间

438
00:18:35,340 --> 00:18:41,210
因此 关于ids可能有两个关键的东西 这两个东西将是坏主意

439
00:18:41,220 --> 00:18:44,990
然后将在它们与模型的关系中得到修复

440
00:18:45,630 --> 00:18:47,350
第一个是满足这个网络数据模型

441
00:18:47,360 --> 00:18:48,710
第二个我会解释它是什么

442
00:18:49,120 --> 00:18:52,030
然后另一个是tuple-at-a-time query的概念

443
00:18:52,700 --> 00:18:54,020
意思是我要写的

444
00:18:54,530 --> 00:18:56,580
基本上是我的程序中的循环

445
00:18:57,020 --> 00:18:59,310
一次迭代一个元组 然后做一些事情

446
00:19:00,470 --> 00:19:01,630
但正如我们所知道的

447
00:19:01,640 --> 00:19:03,430
结果是 我们是一个运营商或包或设置

448
00:19:04,440 --> 00:19:06,630
我们宣布我们真正想做的事情

449
00:19:06,980 --> 00:19:09,450
这可能适用于多个tuples

450
00:19:10,390 --> 00:19:11,400
这是我更有效率的方式

451
00:19:13,670 --> 00:19:18,300
所以据我所知 身份证并没有真正流行起来

452
00:19:19,160 --> 00:19:21,750
但实际上这个项目产生的是一个叫做Codacil的东西

453
00:19:21,760 --> 00:19:24,470
我应该在上课前做个调查

454
00:19:24,480 --> 00:19:25,550
谁还听说过尾波

455
00:19:27,090 --> 00:19:29,110
好吧 谁不是上一届的

456
00:19:30,570 --> 00:19:34,250
你们中的一个代码总是会成为数据库中的热门话题

457
00:19:34,540 --> 00:19:37,090
这是每个人都要为他们的数据库建立的东西

458
00:19:37,640 --> 00:19:39,080
很明显 我们没有

459
00:19:39,730 --> 00:19:41,510
所以有一个人

460
00:19:41,920 --> 00:19:45,550
查尔斯·巴赫曼 他在ids工作 他看到了

461
00:19:45,850 --> 00:19:49,730
她看到了cobalt程序员需要一种标准的方式来

462
00:19:49,740 --> 00:19:51,490
与数据库系统交互

463
00:19:52,750 --> 00:20:00,570
他们提出了这个数据模型和这个名为codes film的查询api

464
00:20:01,480 --> 00:20:03,870
它结合了ids上一张幻灯片中的网络数据模型

465
00:20:03,880 --> 00:20:08,570
和tube out of time查询模型

466
00:20:08,980 --> 00:20:09,370
他们说这将成为

467
00:20:09,380 --> 00:20:10,770
未来的标准

468
00:20:12,010 --> 00:20:16,210
然后巴赫曼离开了ids 他在一个叫que lane的地方工作

469
00:20:16,760 --> 00:20:19,150
这个地方已经被买卖了很多年

470
00:20:19,460 --> 00:20:22,320
他帮助建立了一个基于代码单元的网络数据模型的新版本 称为idms

471
00:20:22,330 --> 00:20:26,100
这个东西实际上今天仍然存在

472
00:20:26,440 --> 00:20:28,510
很明显 如果你是一家全新的创业公司

473
00:20:28,520 --> 00:20:28,700
你不会用这个 对吧

474
00:20:28,710 --> 00:20:29,840
这适用于类似的遗留应用程序

475
00:20:31,230 --> 00:20:33,250
所以网络模型看起来是这样的

476
00:20:33,260 --> 00:20:38,360
我举个例子 我说我是NASA

477
00:20:38,370 --> 00:20:40,200
这其实是一个真实的例子

478
00:20:40,660 --> 00:20:44,370
我是美国国家航空航天局

479
00:20:44,380 --> 00:20:45,330
我正在为阿波罗登月计划建造一枚火箭

480
00:20:46,900 --> 00:20:48,370
A这是一个庞大的工程项目

481
00:20:48,380 --> 00:20:51,640
我需要跟踪我的火箭的所有部件

482
00:20:52,340 --> 00:20:55,210
以及什么制造商或什么公司可以为我提供这些部件

483
00:20:56,350 --> 00:20:56,500
对的

484
00:20:56,510 --> 00:20:59,660
所以他们会有这个数据库 你有供应商和零件

485
00:21:00,130 --> 00:21:02,400
然后你跟踪什么供应商可以提供某些零件

486
00:21:02,410 --> 00:21:03,800
什么价格 什么尺寸等等

487
00:21:05,510 --> 00:21:06,820
在网络数据模型下

488
00:21:06,830 --> 00:21:09,300
您将拥有高级实体

489
00:21:09,310 --> 00:21:13,570
就像您将拥有供应商一样 即可以提供零件或提供零件的公司的名称

490
00:21:13,910 --> 00:21:15,070
你有你需要的部分

491
00:21:15,420 --> 00:21:17,050
然后你有另一套

492
00:21:17,060 --> 00:21:19,290
这是这个供应商的

493
00:21:19,300 --> 00:21:21,450
他们将提供这个零件 这个价格

494
00:21:21,460 --> 00:21:24,080
所以你可以拥有这些高级实体

495
00:21:25,640 --> 00:21:28,180
但是你必须隐式地拥有这些集合

496
00:21:29,180 --> 00:21:30,630
这是我用斜体显示的 对吗

497
00:21:30,640 --> 00:21:32,550
你会有供应品和供应者

498
00:21:33,080 --> 00:21:37,660
你会说我有一个供应商

499
00:21:37,670 --> 00:21:39,300
在供应品集合中会有一个供应品

500
00:21:40,690 --> 00:21:47,420
现在 如果我想找到供应商提供的所有零件

501
00:21:47,850 --> 00:21:49,490
我必须做一堆四个嘴唇的巢穴

502
00:21:49,500 --> 00:21:51,050
去看看这里的每一个供应商

503
00:21:51,450 --> 00:21:53,190
看看他们所有的供应集

504
00:21:53,700 --> 00:21:56,390
得到供应类型 然后反过来回到那里 对吗

505
00:21:57,410 --> 00:21:59,200
你基本上写了一堆四个嘴唇的网

506
00:21:59,210 --> 00:22:00,700
你一次在一个管子上做这个

507
00:22:03,220 --> 00:22:06,400
另一个问题是 实际上

508
00:22:06,410 --> 00:22:07,920
你看起来像这样

509
00:22:07,930 --> 00:22:10,800
如果你真的有一个这样的例子

510
00:22:11,490 --> 00:22:11,530
对吧

511
00:22:11,540 --> 00:22:13,170
你有供应商供应的零件

512
00:22:13,690 --> 00:22:16,750
然后你会有这些

513
00:22:16,760 --> 00:22:18,510
辅助表和基本的交叉引用表

514
00:22:19,160 --> 00:22:24,540
或者你保留指向实际对象的指针

515
00:22:25,070 --> 00:22:26,520
所以我在这里画了这些红线

516
00:22:26,530 --> 00:22:29,540
这些实际上是类似物理指针的指针

517
00:22:29,550 --> 00:22:32,880
这是该记录在磁盘或内存中的位置

518
00:22:34,140 --> 00:22:34,540
对的

519
00:22:35,230 --> 00:22:35,730
又

520
00:22:35,740 --> 00:22:37,770
所以现在 当你通过循环时

521
00:22:39,100 --> 00:22:41,170
试着找到所有的供应商来申请某一部分

522
00:22:41,700 --> 00:22:42,940
您必须查看第一个

523
00:22:42,950 --> 00:22:47,040
然后查找该实体中的记录

524
00:22:47,050 --> 00:22:48,720
我要称它为桌子 因为它不是

525
00:22:49,740 --> 00:22:51,700
然后你会跟着指针跳到这里

526
00:22:52,140 --> 00:22:52,740
然后潜在地

527
00:22:52,750 --> 00:22:54,620
你可以有一个指针回到另一个方向

528
00:22:55,740 --> 00:22:56,060
对的

529
00:22:57,530 --> 00:23:00,430
所以查询非常复杂 对吧

530
00:23:00,440 --> 00:23:01,910
这都是用钴写的

531
00:23:03,350 --> 00:23:06,850
它的效率较低

532
00:23:06,980 --> 00:23:08,690
因为你一次只在一个tuple上操作

533
00:23:09,690 --> 00:23:10,600
它很容易被打断

534
00:23:10,610 --> 00:23:13,680
所以如果这个东西得到了

535
00:23:13,690 --> 00:23:18,010
如果这个港口是蹩脚的 那么这个提供或由这些数据的集合提供

536
00:23:18,020 --> 00:23:18,690
这些指针

537
00:23:19,020 --> 00:23:20,400
如果这个东西被破坏了

538
00:23:20,410 --> 00:23:21,560
你的整个数据库都是主机

539
00:23:21,570 --> 00:23:24,660
因为现在你没有办法遍历和查找东西

540
00:23:25,670 --> 00:23:28,340
了解这些对象之间的关系

541
00:23:28,350 --> 00:23:31,660
好吧

542
00:23:31,670 --> 00:23:35,850
所以在20世纪60年代的下一个大系统是这个叫做IMS的东西

543
00:23:36,390 --> 00:23:38,400
它实际上是为阿波罗登月任务建造的

544
00:23:38,570 --> 00:23:42,260
IBM负责构建数据库

545
00:23:42,270 --> 00:23:44,340
以跟踪它们的所有部分

546
00:23:44,350 --> 00:23:46,480
美国国家航空航天局购买建造火箭

547
00:23:47,330 --> 00:23:47,680
同样

548
00:23:47,690 --> 00:23:51,870
就像ge和is一样 他们为该项目建立了一种自定义数据库系统

549
00:23:51,880 --> 00:23:55,110
然后意识到它对其他客户有用

550
00:23:55,630 --> 00:23:57,090
他们将其作为一个单独的产品

551
00:23:57,620 --> 00:23:58,940
这件事今天仍然存在

552
00:23:59,170 --> 00:24:02,230
IBM在这些东西上赚了很多钱

553
00:24:02,240 --> 00:24:03,470
这个数据一直到今天

554
00:24:04,970 --> 00:24:07,350
如果你曾经使用过ATM机或银行里的任何东西

555
00:24:07,360 --> 00:24:10,760
他们中的很多人仍然在使用70年代建立的IMS

556
00:24:11,200 --> 00:24:11,880
如果它没坏

557
00:24:12,410 --> 00:24:12,960
就不要修理它

558
00:24:15,770 --> 00:24:18,190
IMS将使用所谓的分层数据模型

559
00:24:19,880 --> 00:24:23,420
就像网络数据模型一样 将使用管超时查询

560
00:24:23,970 --> 00:24:27,210
另一件重要的事情是它将支持程序员找到

561
00:24:27,800 --> 00:24:28,900
物理数据结构

562
00:24:30,010 --> 00:24:32,270
意思是如果我有一个像表一样的数据集合

563
00:24:32,960 --> 00:24:34,550
我不会使用你的表 因为他们不会这样称呼它

564
00:24:34,560 --> 00:24:35,390
而是假设它是一个表

565
00:24:36,250 --> 00:24:37,640
我会告诉数据库系统

566
00:24:37,650 --> 00:24:38,840
我想把它存储为哈希表

567
00:24:38,850 --> 00:24:40,280
或者我想把它存储为AB加树

568
00:24:41,360 --> 00:24:42,870
然后根据我告诉它的

569
00:24:42,880 --> 00:24:45,350
我想存储它 然后你得到一个不同的api

570
00:24:45,360 --> 00:24:46,190
允许你遍历数

571
00:24:47,000 --> 00:24:48,780
据因为你不能做范围查询和哈希表

572
00:24:48,790 --> 00:24:50,140
但你不能在b加树上做

573
00:24:52,460 --> 00:24:53,530
回到我们的例子

574
00:24:54,760 --> 00:24:55,810
我们现在有供应商了

575
00:24:57,600 --> 00:24:59,790
我是个白痴 因为我把遥控器的插头留在里面了

576
00:25:01,280 --> 00:25:01,870
太可悲了

577
00:25:02,760 --> 00:25:02,870
对的

578
00:25:02,880 --> 00:25:04,070
所以我有一个供应商

579
00:25:04,590 --> 00:25:08,680
现在他们有了看起来更好的部分 对吧

580
00:25:08,690 --> 00:25:10,400
因为现在我不需要这些多余的东西了

581
00:25:12,340 --> 00:25:12,570
现在

582
00:25:12,580 --> 00:25:16,390
但我确实在供应商和零件之间的显式关系之间

583
00:25:16,400 --> 00:25:17,890
有一个隐式关系

584
00:25:18,550 --> 00:25:21,880
一个零件只能由一个特定的供应商供应

585
00:25:23,480 --> 00:25:24,720
现在 如果我去我的实例

586
00:25:26,090 --> 00:25:26,440
是吧

587
00:25:26,810 --> 00:25:29,450
比如说第一个供应商

588
00:25:29,980 --> 00:25:31,040
他们供应电池

589
00:25:31,050 --> 00:25:32,680
我必须有另一个完整的记录

590
00:25:33,300 --> 00:25:36,410
然后我必须为第二个供应商提供另一张唱片

591
00:25:36,420 --> 00:25:37,730
他们可能使用相同的电池

592
00:25:37,740 --> 00:25:38,570
但价格不同

593
00:25:39,990 --> 00:25:47,000
现在 假设我将部件的名称从batteries更改为on a

594
00:25:47,330 --> 00:25:49,200
brand name battery

595
00:25:49,210 --> 00:25:51,510
无论我想在这里更改什么

596
00:25:51,850 --> 00:25:55,930
我都必须检查并更改

597
00:25:55,940 --> 00:25:59,210
电池所在位置的每个记录实例

598
00:26:00,440 --> 00:26:03,030
因为你基本上是在重复信息

599
00:26:03,440 --> 00:26:07,020
因为在这个模型中 你不能让一个零件由多个供应商提供

600
00:26:10,140 --> 00:26:11,960
你还会遇到的另一个问题是

601
00:26:11,970 --> 00:26:13,010
正如我所说的

602
00:26:13,860 --> 00:26:17,200
由于系统公开了你实际上想要如何存储数据的能力

603
00:26:17,210 --> 00:26:18,360
一个哈希表与B集群或其他什么

604
00:26:18,370 --> 00:26:20,000
那么如果我改变主意

605
00:26:20,710 --> 00:26:23,860
我说我对哈希表进行了排序

606
00:26:24,050 --> 00:26:25,300
但我想做范围查询

607
00:26:25,490 --> 00:26:27,860
让我把它切换到AB加树

608
00:26:28,930 --> 00:26:30,690
你没有办法轻易改变这一点

609
00:26:30,700 --> 00:26:32,770
实际上 您必须将数据转储出来

610
00:26:33,230 --> 00:26:36,050
然后将其加载回新的数据结构中

611
00:26:36,940 --> 00:26:40,300
然后你实际上必须去更新你的应用程序代码

612
00:26:40,740 --> 00:26:43,690
因为现在它暴露了b+gapi的哈希

613
00:26:43,700 --> 00:26:46,890
而不是哈希表api 物理层和逻辑层之间没有独立性

614
00:26:46,900 --> 00:26:49,050
数据实际上是什么

615
00:26:53,280 --> 00:26:54,780
所有这些都是一种 是的

616
00:27:02,480 --> 00:27:09,140
在2003年的20年里 系统不支持IMS

617
00:27:09,560 --> 00:27:14,230
我人工智能认为他们在它上面有ASQL单板

618
00:27:15,350 --> 00:27:15,580
对的

619
00:27:15,590 --> 00:27:19,260
我认为这仍然是一个很难的事情

620
00:27:19,270 --> 00:27:23,870
在80年代 有人试图把它转换成种族模式

621
00:27:24,310 --> 00:27:25,950
但我这就像20世纪60年代

622
00:27:25,960 --> 00:27:26,390
这就是方法

623
00:27:26,880 --> 00:27:32,030
这就是关系模型的动机

624
00:27:34,540 --> 00:27:35,580
在20世纪60年代末 有一个叫泰德·科德的家伙

625
00:27:36,040 --> 00:27:39,780
他刚刚完成了数学博士学位

626
00:27:40,430 --> 00:27:42,200
他当时在ibm研究院工作

627
00:27:42,210 --> 00:27:46,480
他看到所有这些ims程序员花费大量时间一遍又一遍地

628
00:27:46,490 --> 00:27:48,120
重写应用程序代码

629
00:27:48,400 --> 00:27:50,090
原因是物理层和逻辑层

630
00:27:50,890 --> 00:27:52,750
之间的这种紧密耦合

631
00:27:54,930 --> 00:27:56,950
然后他意识到

632
00:27:57,610 --> 00:28:00,810
这实际上是相当有先见之明的 这是不可扩展的

633
00:28:01,440 --> 00:28:03,930
在某种程度上 它可能比计算机更昂贵

634
00:28:04,460 --> 00:28:06,550
在计算机超级昂贵的时候 人类是廉价的

635
00:28:07,190 --> 00:28:08,170
现在正好相反 对吧

636
00:28:08,180 --> 00:28:09,450
我可以得到一个

637
00:28:09,460 --> 00:28:11,950
amazon实例

638
00:28:12,720 --> 00:28:18,520
每小时只需一分钱 但一个程序将花费我20万美元 这是怎么回事

639
00:28:19,630 --> 00:28:21,360
继续讲课

640
00:28:21,370 --> 00:28:23,100
不是那个

641
00:28:23,110 --> 00:28:23,680
什么

642
00:28:23,690 --> 00:28:25,360
现在我很好奇

643
00:28:28,380 --> 00:28:28,970
我不知道

644
00:28:30,980 --> 00:28:34,810
你在嘲笑数据库程序员的200K吗

645
00:28:34,820 --> 00:28:35,370
那有点低

646
00:28:42,150 --> 00:28:43,920
无论如何 数据程序并不便宜

647
00:28:46,290 --> 00:28:47,590
但在它睡觉的时候

648
00:28:47,970 --> 00:28:50,360
他看到所有这些人又在浪费时间

649
00:28:50,370 --> 00:28:51,640
重写应用程序

650
00:28:52,740 --> 00:28:55,570
他们看到了这种一次两个Po的编程API的低效率

651
00:28:55,580 --> 00:29:02,270
关系模型有三个关键部分

652
00:29:03,390 --> 00:29:03,860
再一次

653
00:29:03,870 --> 00:29:07,620
它成为了今天所有现代种族数据系统的背景

654
00:29:08,740 --> 00:29:09,490
首先 我们

655
00:29:09,500 --> 00:29:11,590
将把数据库存储在简单的数据结构中

656
00:29:11,810 --> 00:29:15,180
而不是编码器单元网络模型中的这个图

657
00:29:15,520 --> 00:29:20,280
或者ims下的这个层次结构 我们将存储表关系

658
00:29:20,290 --> 00:29:22,050
所以这些单堆的东西

659
00:29:22,870 --> 00:29:29,440
如果它们有关系 或者有对其他表的引用

660
00:29:29,450 --> 00:29:32,360
我们只需将其作为另一个属性再次存储在它们的关系中

661
00:29:32,770 --> 00:29:32,920
对的

662
00:29:32,930 --> 00:29:34,880
不需要任何明确的指针

663
00:29:36,320 --> 00:29:39,600
该程序是我们通过高级语言访问

664
00:29:39,610 --> 00:29:40,680
数据库的方式

665
00:29:41,520 --> 00:29:42,820
而不是编写这些嵌套的for循环

666
00:29:42,830 --> 00:29:46,420
他们将能够说他当时没有发泄Sequel

667
00:29:46,430 --> 00:29:47,490
但很抱歉

668
00:29:47,500 --> 00:29:49,290
当时没有像Siegel这样的编程语言

669
00:29:49,300 --> 00:29:50,850
但他有这样的想法

670
00:29:51,210 --> 00:29:55,830
好吧

671
00:29:55,840 --> 00:29:57,470
有一种方法可以抽象数据库系统的物理结构的实际物理物化

672
00:29:57,480 --> 00:29:59,030
这就是我想要的答案

673
00:29:59,550 --> 00:30:01,140
然后数据系统会帮你算出来

674
00:30:02,390 --> 00:30:02,710
对的

675
00:30:02,720 --> 00:30:05,350
这也意味着

676
00:30:05,360 --> 00:30:06,830
由于我在物理层和逻辑层之间进行了这种抽象

677
00:30:07,320 --> 00:30:11,210
该策略只是将数据物理地存储在磁盘或内存中

678
00:30:11,640 --> 00:30:13,450
我们完全由实现决定

679
00:30:14,410 --> 00:30:16,480
因为根据查询想要做的事情

680
00:30:16,990 --> 00:30:19,310
它可以决定存储数据的最佳方式

681
00:30:21,020 --> 00:30:21,170
对的

682
00:30:21,340 --> 00:30:24,570
第一篇关于种族模式的论文发表于1969年

683
00:30:25,590 --> 00:30:27,140
这是第一个

684
00:30:28,200 --> 00:30:31,010
这通常是每个人都引用的一篇事实上的关系模型论文

685
00:30:31,540 --> 00:30:35,570
该论文于1970年发表

686
00:30:35,580 --> 00:30:36,450
在cacm上

687
00:30:36,810 --> 00:30:37,990
但这是第一个

688
00:30:39,410 --> 00:30:42,750
我们回到供应商 供应品和零件之前的例子

689
00:30:43,430 --> 00:30:43,690
对的

690
00:30:43,700 --> 00:30:44,730
它看起来像这样

691
00:30:45,280 --> 00:30:47,200
它本质上是网络模型

692
00:30:47,210 --> 00:30:50,570
但现在我没有这些明确的成员集

693
00:30:52,140 --> 00:30:55,450
现在 如果我想在一个表或关系数据库中的

694
00:30:56,370 --> 00:30:56,620
表中排序 现在

695
00:30:56,630 --> 00:31:01,340
我有这些外键引用 它们只是对象中的属性

696
00:31:01,870 --> 00:31:08,000
数据系统可以理解这个供应商编号对应于另一个表

697
00:31:08,010 --> 00:31:11,010
中的某个供应商编号

698
00:31:14,840 --> 00:31:15,870
我们会得到C等于2

699
00:31:15,880 --> 00:31:17,150
但这是一个激进的想法

700
00:31:17,540 --> 00:31:18,740
续集是一个激进的想法

701
00:31:20,410 --> 00:31:24,830
现在我们认为它是理所当然的

702
00:31:24,840 --> 00:31:32,290
因为它是如此普遍 但当时对关系模型的批评是没有办法数据库

703
00:31:32,300 --> 00:31:34,810
没有办法软件

704
00:31:34,820 --> 00:31:38,500
它将编写与人类所能编写的查询一样高效的查询

705
00:31:40,030 --> 00:31:41,660
这似乎有点奇怪

706
00:31:41,670 --> 00:31:44,020
但这与当年人们提出的论点相同

707
00:31:44,480 --> 00:31:47,790
即编译器不可能生成比人类编写的代码

708
00:31:47,800 --> 00:31:49,520
更高效的程序代码

709
00:31:49,530 --> 00:31:54,470
当然 对于高技能的嵌入式系统程序员来说 这可能是真的

710
00:31:54,710 --> 00:31:55,950
但是今天没有人写汇编

711
00:31:56,480 --> 00:31:56,800
对的

712
00:31:57,570 --> 00:32:02,050
每个人都用更高级的语言写作 甚至更高级的语言 比如Python

713
00:32:02,490 --> 00:32:02,860
对的

714
00:32:05,730 --> 00:32:08,370
但在当时 这就像是1970年推出的SEA编译器

715
00:32:08,660 --> 00:32:12,920
这是一个疯狂的想法 事实证明它是正确的

716
00:32:13,850 --> 00:32:17,400
这取决于查询优化器的实现 以及它有多好

717
00:32:17,730 --> 00:32:20,570
我们会看到一些论文 说明事情是如何出错的

718
00:32:21,570 --> 00:32:23,490
这当然是个难题

719
00:32:23,500 --> 00:32:24,370
但一般来说

720
00:32:24,380 --> 00:32:27,600
就像数据库系统将生成比一般程序员实际编写的更

721
00:32:27,610 --> 00:32:29,000
有效的查询计划一样

722
00:32:29,590 --> 00:32:29,880
而且

723
00:32:29,890 --> 00:32:32,680
现在它将数据系统暴露给可能是艺术程序员的人

724
00:32:33,320 --> 00:32:36,600
比如业务分析师或做会计报告的人 对吧

725
00:32:36,610 --> 00:32:38,120
但他们不是铁杆程序员

726
00:32:38,560 --> 00:32:41,840
他们可以编写SQL 但可能不能编写任何CC Plus

727
00:32:44,830 --> 00:32:47,790
所以特德·科德在1970年发表了这篇论文

728
00:32:48,820 --> 00:32:49,810
他是个数学家

729
00:32:53,300 --> 00:32:55,990
这里的这篇论文 实际上并不难读

730
00:32:57,270 --> 00:33:00,160
但当你读到对它的批评 或者人们谈论它的时候

731
00:33:00,630 --> 00:33:01,950
当代关于它的谈话

732
00:33:02,310 --> 00:33:03,770
人们说它是高深莫测的

733
00:33:04,020 --> 00:33:05,690
据说它的数学很重

734
00:33:06,790 --> 00:33:07,180
不

735
00:33:07,570 --> 00:33:09,650
但是 也许是20世纪70年代 我不知道 也许是

736
00:33:11,160 --> 00:33:14,460
他在那篇论文中并没有提出一种编程语言

737
00:33:14,470 --> 00:33:16,530
他后来在1974年 75年

738
00:33:16,540 --> 00:33:19,320
这个叫做阿尔法的东西没有去任何地方

739
00:33:19,640 --> 00:33:20,810
但当时都是数学

740
00:33:21,750 --> 00:33:25,350
他实际上并没有建立一个系统来证明他的想法是可行的

741
00:33:25,830 --> 00:33:26,240


742
00:33:27,310 --> 00:33:30,040
事情是这样的 有一群人看到了他的论文

743
00:33:30,460 --> 00:33:30,720
说

744
00:33:30,730 --> 00:33:33,210
嘿 我认为这是一个好主意

745
00:33:33,220 --> 00:33:34,930
并开始建立实验系统来测试它

746
00:33:36,380 --> 00:33:39,570
据我所知

747
00:33:39,580 --> 00:33:41,330
第一个这样做的系统是一个叫做彼得·李关系测试工具的东西

748
00:33:41,720 --> 00:33:43,470
听起来像20世纪70年代的毒品禁令

749
00:33:44,740 --> 00:33:47,990
但这些人就像英国人一样 基本上都读过他的论文

750
00:33:48,040 --> 00:33:48,910
就像 我认为这是一个好主意

751
00:33:49,210 --> 00:33:52,250
他们建立了四个续集的早期原型

752
00:33:52,570 --> 00:33:53,280
他们谈到

753
00:33:53,290 --> 00:33:56,340
它可以存储大量的数据集 比如1002个极点

754
00:33:56,350 --> 00:33:57,300
这对他们来说是令人兴奋的

755
00:33:59,260 --> 00:34:00,410
人们通常会忘记这一点

756
00:34:00,420 --> 00:34:01,930
据我所知 这是第一个

757
00:34:02,610 --> 00:34:09,000
但是还有另外两个项目是在ibm的system和berkeley的ingress之后1

758
00:34:09,010 --> 00:34:10,800
或2年出现的

759
00:34:11,300 --> 00:34:15,880
这些被认为是第一个关系数据系统

760
00:34:15,890 --> 00:34:19,160
试图建立一些基于Ted卡片的工作

761
00:34:19,170 --> 00:34:20,760
并真正建立一个真正的系统

762
00:34:21,270 --> 00:34:23,420
我认为《哑剧续集》是在瑞典推出的

763
00:34:23,850 --> 00:34:25,380
可能是1年或2年后

764
00:34:25,990 --> 00:34:27,530
但这是一个项目的行为

765
00:34:27,540 --> 00:34:28,610
这在今天仍然存在

766
00:34:29,410 --> 00:34:31,240
甲骨文和拉里·埃里森 我们知道这件事

767
00:34:31,930 --> 00:34:33,700
我们将在整个学期中讨论这个问题

768
00:34:34,440 --> 00:34:35,150
基本上

769
00:34:36,810 --> 00:34:40,620
这一切都发生在硅谷

770
00:34:40,630 --> 00:34:42,510
Larry Elsin基本上复制了IBM的做法

771
00:34:42,880 --> 00:34:44,910
他会给他们打电话

772
00:34:45,400 --> 00:34:45,910
问他们 这是怎么回事

773
00:34:45,920 --> 00:34:47,910
他们会告诉他们 因为他们是研究人员 不知道

774
00:34:48,130 --> 00:34:49,300
他去复制了它

775
00:34:50,950 --> 00:34:55,100
然后ingress最终在70年代末在大学里商业化了

776
00:34:55,580 --> 00:34:56,250
因为人们

777
00:34:56,260 --> 00:34:58,690
实际上开始真正使用它

778
00:34:58,700 --> 00:35:00,750
因为他们了解种族模型的证书

779
00:35:02,220 --> 00:35:05,440
但同样 在20世纪70年代 不清楚它是否可能是尾波

780
00:35:05,450 --> 00:35:06,770
但它可能是一个关系模型

781
00:35:07,870 --> 00:35:10,320
最终在20世纪80年代 关系模型 一

782
00:35:13,330 --> 00:35:14,510
发生了两件事 三件事

783
00:35:15,210 --> 00:35:20,570
首先 ibm从未将系统商业化

784
00:35:20,580 --> 00:35:23,490
他们本可以在这个市场上占据主导地位

785
00:35:23,500 --> 00:35:27,660
但他们放弃了秃头 因为他们在ims上赚了很多钱

786
00:35:27,670 --> 00:35:30,530
当你在ims上赚了这么多钱的时候

787
00:35:30,540 --> 00:35:34,170
你为什么要用另一个可能不起作用的新数据系统来杀死这只下金蛋的鹅呢

788
00:35:34,180 --> 00:35:35,370
但最终他们看到了曙光

789
00:35:35,380 --> 00:35:39,510
并在1981年推出了他们的第一个关系数据库系统

790
00:35:39,790 --> 00:35:43,840
称为segal ds 这是系统r的残余 但很多都是从零开始编写的

791
00:35:44,940 --> 00:35:45,730
续集

792
00:35:45,740 --> 00:35:46,610
DS还在

793
00:35:46,620 --> 00:35:48,090
他们将其重命名为DB 2

794
00:35:48,420 --> 00:35:57,370
就像VSE的DV 2一样

795
00:35:57,380 --> 00:35:58,210
还有一些类似于他们编写的SQL DS 4的大型机系统

796
00:35:58,650 --> 00:36:00,120
DB 2有五个版本

797
00:36:00,130 --> 00:36:01,840
很难追踪他们

798
00:36:02,680 --> 00:36:06,670
但是我们今天所知道的DB 2

799
00:36:07,090 --> 00:36:08,720
第一次出现是在1983年

800
00:36:09,280 --> 00:36:10,670
当它在83年问世时

801
00:36:11,040 --> 00:36:13,790
这是数据库行业的一次尝试

802
00:36:14,160 --> 00:36:15,550
现在是IBM系列的关系模型

803
00:36:15,560 --> 00:36:17,310
这是一个真实的想法

804
00:36:17,870 --> 00:36:20,090
Ingress和Oracle仍然在市场上

805
00:36:20,510 --> 00:36:22,920
但它基本上表明 关系模式是前进的方向

806
00:36:23,520 --> 00:36:29,140
当这本书在83年出版时 续集成为了有缺陷的标准

807
00:36:29,990 --> 00:36:31,600
甲骨文在正确的时间出现在了正确的地方

808
00:36:31,610 --> 00:36:35,930
因为当IBM的时候

809
00:36:35,940 --> 00:36:36,810
IBM不会说他们是通勤行业的巨头

810
00:36:36,820 --> 00:36:38,370
所以他们说 嘿 事情就是这样的

811
00:36:38,950 --> 00:36:39,950
这就是我们要用的语言

812
00:36:39,960 --> 00:36:42,390
每个人都说IBM说这就是我所做的

813
00:36:42,810 --> 00:36:44,750
当甲骨文在那里的时候 我们说 嘿 我们已经支持Sequel了

814
00:36:44,760 --> 00:36:45,630
我们要走了

815
00:36:46,080 --> 00:36:48,120
Ingress有自己的编程语言Quell

816
00:36:48,690 --> 00:36:52,010
那个强大的破坏者仍然声称比SQL更好

817
00:36:52,830 --> 00:36:54,090
他们最终支持了

818
00:36:54,100 --> 00:36:57,180
《续集》 但当他们加入时 已经太晚了

819
00:36:58,640 --> 00:37:03,760
所以Sequel合理地拼写为Seqeul

820
00:37:03,770 --> 00:37:04,480
因为它应该是Quell的续集

821
00:37:05,000 --> 00:37:05,380
对的

822
00:37:05,660 --> 00:37:06,750
玩文字游戏

823
00:37:07,090 --> 00:37:09,080
然后他们因为商标丰富而被起诉

824
00:37:09,090 --> 00:37:14,500
所以他们把它改名为SQL

825
00:37:14,510 --> 00:37:17,020
然后有一个标准机构来确定我们应该使用什么编程语言

826
00:37:19,080 --> 00:37:20,270
对于关系数据库

827
00:37:21,920 --> 00:37:24,020
据推测 他们将使用奎尔

828
00:37:24,730 --> 00:37:25,430
设置一个续集

829
00:37:26,170 --> 00:37:30,830
但穹顶破坏者不喜欢标准机构

830
00:37:30,840 --> 00:37:31,990
并决定不为奎尔提交任何文件

831
00:37:32,900 --> 00:37:35,970
这是拉里·埃里森的一段话

832
00:37:36,930 --> 00:37:37,850
未经授权的传记

833
00:37:37,860 --> 00:37:38,970
我不想让你回忆起它

834
00:37:39,460 --> 00:37:41,750
但它出现在90年代末

835
00:37:41,760 --> 00:37:43,600
他们基本上是在谈论他们如何认为Quell比SQL更好

836
00:37:43,770 --> 00:37:45,930
但Mike讨厌标准机构

837
00:37:45,940 --> 00:37:46,970
所以他没有提交任何东西

838
00:37:48,040 --> 00:37:48,230
无论如何

839
00:37:48,940 --> 00:37:50,950
所以这就是为什么我们最终选择了续集而不是《平息》

840
00:37:52,570 --> 00:37:56,950
这个在黑客新闻上偶尔会看到人们说

841
00:37:56,960 --> 00:37:59,460
嘿 我有更好的新版本的续集或更好的版本的续集

842
00:37:59,970 --> 00:38:03,670
他们最终在续集中解决了很多问题

843
00:38:03,680 --> 00:38:07,070
比如在选择条款之后有前爪 比如quell

844
00:38:07,470 --> 00:38:08,540
在70年代已经这样做了

845
00:38:10,020 --> 00:38:11,090
但我们最终还是拍了续集

846
00:38:11,890 --> 00:38:12,170
抱歉

847
00:38:15,670 --> 00:38:15,890
对的

848
00:38:15,900 --> 00:38:19,730
所以甲骨文基本上在20世纪80年代赢得了桂冠

849
00:38:19,930 --> 00:38:23,480
还有很多其他的创业公司也在做关系数据库

850
00:38:23,870 --> 00:38:25,450
PSI基于FORMICS接口

851
00:38:25,780 --> 00:38:28,090
Terror Data是DECK收购的数据仓库串联

852
00:38:29,050 --> 00:38:32,510
基本上 我想说的是 今天唯一还在蓬勃发展的是oracle和db two

853
00:38:32,520 --> 00:38:36,600
而“蓬勃发展”这个词并不恰当

854
00:38:36,610 --> 00:38:38,320
因为所有这些都是基于psi的 但仍然赚了很多钱

855
00:38:38,630 --> 00:38:40,220
但是 如果你是一家新成立的公司 你不会使用它

856
00:38:40,230 --> 00:38:43,360
很多系统仍然处于维护模式

857
00:38:45,780 --> 00:38:47,300
但甲骨文是积极的爱

858
00:38:47,310 --> 00:38:56,430
然后与db two tear数据一样 他们正在被雪花粉碎

859
00:38:57,980 --> 00:38:59,510
所以破石者 他商业化了他的入口

860
00:39:00,160 --> 00:39:01,550
回到伯克利

861
00:39:01,870 --> 00:39:04,140
开始了一个新的一天系统 叫做postgress

862
00:39:04,150 --> 00:39:07,470
如果你是我 Postgress被称为Postgres 因为它是Post Ingress

863
00:39:07,990 --> 00:39:09,400
这是他在进入后建立的感觉

864
00:39:11,280 --> 00:39:13,370
他称这个系统为对象关系数据库系统

865
00:39:13,860 --> 00:39:15,850
而不是关系数据系统

866
00:39:16,800 --> 00:39:18,960
因为面向对象编程是20世纪80年代的热门话题

867
00:39:19,650 --> 00:39:22,800
这就是为什么明信片一开始就被设计得

868
00:39:22,810 --> 00:39:24,160
非常可扩展

869
00:39:24,700 --> 00:39:27,180
你可以有用户定义的类型

870
00:39:27,580 --> 00:39:32,780
用户定义的函数等等 因为他们想借用面向对象数据库的一些想法

871
00:39:32,790 --> 00:39:36,200
这将是下一张幻灯片 并且能够很容易地扩展明信片

872
00:39:38,290 --> 00:39:39,480
即使在今天

873
00:39:39,490 --> 00:39:41,480
从技术上讲 明信片也是一个基于数据库系统的对象

874
00:39:42,470 --> 00:39:43,860
人们大多忽略了这一部分

875
00:39:43,870 --> 00:39:45,010
客体部分

876
00:39:47,590 --> 00:39:48,390
到目前为止我们在哪里

877
00:39:48,740 --> 00:39:49,780
20世纪70年代 科达索

878
00:39:50,720 --> 00:39:55,180
有没有钴

879
00:39:55,190 --> 00:39:55,700
用钴来编程戴维斯是他们的冰川模型出来了

880
00:39:55,990 --> 00:39:57,420
人们说打人是个坏主意

881
00:39:57,790 --> 00:39:59,060
尾波细胞是正确的方法

882
00:39:59,310 --> 00:40:00,570
尤其是在一些模型获胜的情况下

883
00:40:01,350 --> 00:40:04,110
戴维斯的所有这些方法都是在20世纪80年代出现的

884
00:40:04,840 --> 00:40:05,630
80年代初

885
00:40:06,410 --> 00:40:07,450
10年后

886
00:40:07,460 --> 00:40:09,450
我们最终得到了这些对象 普通数据库

887
00:40:10,080 --> 00:40:12,150
我想说的是 每隔10年

888
00:40:12,550 --> 00:40:13,350
人们就会说 我有一个更好的主意

889
00:40:14,320 --> 00:40:15,310
在20世纪80年代 人们认识到

890
00:40:15,920 --> 00:40:19,030
如果应用程序可用

891
00:40:19,040 --> 00:40:20,630
就要使用面向对象的编程语言

892
00:40:21,120 --> 00:40:23,690
就像C+是20世纪80年代末的热门话题一样

893
00:40:25,680 --> 00:40:28,100
存在这种阻抗不匹配

894
00:40:28,110 --> 00:40:33,490
即数据库系统将数据表示为关系的方式没有清晰地映射到

895
00:40:33,500 --> 00:40:37,090
对象或面向对象编程表示数据的方式

896
00:40:38,260 --> 00:40:41,790
因此 您必须编写这些sql查询

897
00:40:41,800 --> 00:40:42,870
这些查询基本上会将行转换为now对象

898
00:40:43,490 --> 00:40:44,270
类似于嵌套层次结构

899
00:40:45,220 --> 00:40:47,420
所以很多公司说这有点愚蠢

900
00:40:47,430 --> 00:40:50,630
数据库中的对象直接作为对象会被扭曲吗

901
00:40:52,370 --> 00:40:54,880
有几个系统 Versant Objects或02

902
00:40:54,890 --> 00:40:58,590
我认为马克的逻辑实际上是你几周前才被买下的

903
00:40:59,890 --> 00:41:02,280
但他们是90年代末的

904
00:41:03,890 --> 00:41:07,210
所以一堆这样的系统再也不存在了

905
00:41:07,220 --> 00:41:08,210
是否有维护模式

906
00:41:08,760 --> 00:41:13,940
杀死他的是没有标准的查询语言

907
00:41:13,950 --> 00:41:16,240
你可以使用面向对象的数据库

908
00:41:16,500 --> 00:41:19,210
最终 他们提出了对象查询语言oql

909
00:41:19,220 --> 00:41:20,450
但没有人支持它

910
00:41:20,460 --> 00:41:21,250
已经太迟了

911
00:41:22,340 --> 00:41:22,650
基本上

912
00:41:22,660 --> 00:41:24,570
这个问题是因为你在数据库系统

913
00:41:24,580 --> 00:41:26,490
和编程语言之间有这种紧密耦合

914
00:41:28,360 --> 00:41:29,520
它降低了应用程序的可移植性

915
00:41:29,530 --> 00:41:32,880
对你来说 切换到另一个面向对象的数据库系统并不容易

916
00:41:32,890 --> 00:41:37,320
因为你正在编写他们的专有api

917
00:41:37,330 --> 00:41:40,980
类似于ims如何将所有者api暴露给他们的内部数据结构

918
00:41:43,150 --> 00:41:48,480
所以现在Sequel应该是基本查询的标准课程

919
00:41:48,730 --> 00:41:50,640
你可以很容易地把它们从星期一换到另一个星期一

920
00:41:52,300 --> 00:41:54,210
每个投标人都拥有专有扩展领域

921
00:41:54,750 --> 00:41:55,810
所以即使有一个标准

922
00:41:57,910 --> 00:41:58,430
不是的

923
00:42:00,350 --> 00:42:02,340
没有一个人人都遵守的通用标准

924
00:42:04,200 --> 00:42:06,690
所以你今天可以对续集提出同样的论点

925
00:42:07,210 --> 00:42:08,650
或者我隐瞒了很多

926
00:42:12,140 --> 00:42:12,760
这是它的样子

927
00:42:12,890 --> 00:42:13,200
说

928
00:42:13,210 --> 00:42:15,240
我们有一个应用代码

929
00:42:15,250 --> 00:42:16,680
我们想要存储学生信息

930
00:42:17,240 --> 00:42:20,150
学生有一个ida名称 一个电子邮件地址

931
00:42:20,600 --> 00:42:22,930
然后是一个可能的电话号码列表

932
00:42:24,340 --> 00:42:27,690
在纯关系模型中

933
00:42:28,340 --> 00:42:29,730
即只有标量值的情况下

934
00:42:30,350 --> 00:42:32,080
您可能会表示这种方式

935
00:42:32,350 --> 00:42:35,320
你必须有一张学生桌

936
00:42:35,640 --> 00:42:37,030
然后是一张学生电话桌

937
00:42:38,700 --> 00:42:40,610
所以现在 如果我想在我的编程语言中

938
00:42:40,620 --> 00:42:42,210
如果我想实例化这个对象

939
00:42:42,850 --> 00:42:48,860
我必须做一个查找 我要么首先查询学生 然后进行第二次查询

940
00:42:48,870 --> 00:42:50,460
以获得所有的电话号码

941
00:42:50,470 --> 00:42:53,610
或者做一个连接

942
00:42:53,620 --> 00:42:56,730
然后确保我扔掉多余的学生信息

943
00:42:56,900 --> 00:42:58,170
当我给回结果的时候

944
00:43:00,350 --> 00:43:02,860
再次 面向对象的基础家伙会说这是愚蠢的

945
00:43:02,870 --> 00:43:03,620
面向对象的

946
00:43:03,630 --> 00:43:04,700
人们说这很愚蠢

947
00:43:05,240 --> 00:43:10,840
只需将嵌套对象一起存储在单个记录中

948
00:43:11,360 --> 00:43:15,310
现在 只需对davis进行一次fetch

949
00:43:15,320 --> 00:43:15,910
就像进行一次read调用以将此数据带入一样

950
00:43:18,940 --> 00:43:20,190
问题是

951
00:43:20,200 --> 00:43:22,970
对于一个简单的例子 有一个1对1的通信程序

952
00:43:22,980 --> 00:43:24,650
一个学生的电话号码

953
00:43:25,150 --> 00:43:28,340
学生确定这可能是好的

954
00:43:29,040 --> 00:43:29,400
事实上

955
00:43:29,970 --> 00:43:31,440
在现代关系数据系统中

956
00:43:31,450 --> 00:43:33,400
您可以将电话号码存储为字符串数组

957
00:43:34,230 --> 00:43:35,440
大多数系统都支持这一点

958
00:43:36,440 --> 00:43:39,570
现在的问题是 当您回到零件供应商问题时

959
00:43:39,580 --> 00:43:45,540
如果您现在开始嵌入或取消标准化供应商提供的所有零件

960
00:43:45,550 --> 00:43:48,380
并将其放入供应商记录中

961
00:43:49,000 --> 00:43:49,710
那么我就会遇到这个问题

962
00:43:49,720 --> 00:43:50,790
或者如果我需要更新的字段

963
00:43:50,800 --> 00:43:51,990
我有重复的信息

964
00:43:52,330 --> 00:43:54,720
我的应用程序代码需要确保所有的同步

965
00:43:55,620 --> 00:43:59,050
我不更新一些记录 但不是全部

966
00:44:01,650 --> 00:44:02,880
执行复杂连接

967
00:44:03,890 --> 00:44:06,340
确保数据完整性

968
00:44:06,780 --> 00:44:09,290
在这种方法中是有问题的

969
00:44:10,180 --> 00:44:12,150
我要说的是 在某些情况下 你确实想要存储Jason

970
00:44:12,160 --> 00:44:12,710
再一次

971
00:44:12,720 --> 00:44:15,600
有一些进步 其他的白天系统将会有一个贾森类型

972
00:44:16,690 --> 00:44:22,840
以及以二进制形式高效存储贾森数据（而不仅仅是文本）的

973
00:44:22,850 --> 00:44:24,200
方法

974
00:44:26,470 --> 00:44:29,380
Mogadi做到了这一点 他们有自己的数据类型基础

975
00:44:29,890 --> 00:44:30,980
明信片也有类似的东西

976
00:44:32,430 --> 00:44:35,420
同样 很多想法都是在这些专门的系统中完成的

977
00:44:35,430 --> 00:44:40,090
所以这些非关系系统现在已经找到了进入关系系统的方法

978
00:44:43,380 --> 00:44:43,680
好吧

979
00:44:43,980 --> 00:44:47,090
然后

980
00:44:47,810 --> 00:44:52,870
在我称之为“无聊的日子”的20世纪90年代

981
00:44:52,880 --> 00:44:54,470
哈佛的格局或工作量格局没有任何根本性的变化

982
00:44:55,070 --> 00:44:55,180
对的

983
00:44:55,190 --> 00:44:59,270
它不像20世纪80年代出现的云或微型计算机

984
00:44:59,280 --> 00:45:00,110
就像事情正在发生

985
00:45:00,120 --> 00:45:02,680
事情正在变得更好

986
00:45:03,160 --> 00:45:05,230
港湾正在变得更好

987
00:45:05,680 --> 00:45:08,750
数据集正在变得更大 但这并不是戏剧性的变化

988
00:45:10,360 --> 00:45:10,700
对的

989
00:45:11,390 --> 00:45:13,560
所以我认为四个主要事件

990
00:45:14,040 --> 00:45:18,780
是微软购买了一个源代码的副本或许可证

991
00:45:19,190 --> 00:45:20,940
然后创建了sql server

992
00:45:22,050 --> 00:45:23,560
Segal服务器支持T Sequel

993
00:45:23,990 --> 00:45:26,110
这是来自Side Base的变体Sequel

994
00:45:26,120 --> 00:45:27,350
Side Base发明了T Sequel

995
00:45:28,180 --> 00:45:29,130
在这一点上

996
00:45:29,140 --> 00:45:31,530
西格尔服务器是最先进的 基地是在维护模式

997
00:45:32,480 --> 00:45:34,070
我不知道有多少原始的sideways代码

998
00:45:34,080 --> 00:45:35,470
仍然是这些天的续集名人

999
00:45:35,480 --> 00:45:37,550
他们在2000年进行了重大重写

1000
00:45:38,530 --> 00:45:41,760
他们在1998年和2006年进行了大量重读

1001
00:45:43,370 --> 00:45:47,650
我的续集有点像芬兰的一个人开始重写或开始编写

1002
00:45:48,040 --> 00:45:51,240
自己的数据系统来取代m sequel

1003
00:45:51,250 --> 00:45:52,720
并称其为我的续集

1004
00:45:53,300 --> 00:45:54,670
我是他女儿的名字

1005
00:45:56,030 --> 00:45:58,420
他还做了玛丽DB 那是他的另一个女儿

1006
00:45:58,920 --> 00:46:01,550
然后他有一个儿子叫马克斯

1007
00:46:01,560 --> 00:46:04,310
还有马克斯db 就像他用他的孩子的名字给他所有的戴维斯命名一样

1008
00:46:05,420 --> 00:46:07,740
Postgres最近开始作为一个学术项目

1009
00:46:08,260 --> 00:46:11,310
在20世纪80年代 当他们第一次开始写这本书的时候 斯特劳伯格很喜欢奎尔

1010
00:46:12,090 --> 00:46:13,280
它被用了12次

1011
00:46:14,350 --> 00:46:15,830
但在95

1012
00:46:15,840 --> 00:46:18,750
9062名研究生采用了原始的学术源代码

1013
00:46:19,370 --> 00:46:21,850
然后对其进行转换 使其真正支持sql

1014
00:46:22,350 --> 00:46:26,350
这就是为什么它被称为Progress QL

1015
00:46:26,360 --> 00:46:29,640
他们可能知道最初的编程语言Process是在20世纪80年代编写的

1016
00:46:29,650 --> 00:46:32,710
让我猜一下

1017
00:46:34,010 --> 00:46:34,490
这是钴

1018
00:46:34,500 --> 00:46:34,730
不

1019
00:46:37,570 --> 00:46:38,260
艾比可以关上它

1020
00:46:40,170 --> 00:46:45,120
你口齿不清吗

1021
00:46:48,550 --> 00:46:49,550
那是80年代 对吧

1022
00:46:49,600 --> 00:46:50,550
可卡因之类的

1023
00:46:52,060 --> 00:46:53,530
然后他们意识到这是个坏主意

1024
00:46:53,540 --> 00:46:58,020
然后他们让一个编译器将Lisp转换成C并编译它

1025
00:46:58,030 --> 00:46:58,980
那是个坏主意

1026
00:46:59,110 --> 00:47:04,330
他们用C语言重写了所有的东西 然后在2000年初开始了续集之光

1027
00:47:04,600 --> 00:47:07,190
这是北卡罗来纳州的一个家伙发明的

1028
00:47:07,690 --> 00:47:08,230
他叫理查德·希普

1029
00:47:09,070 --> 00:47:10,460
他仍然关注参议院的主要计划

1030
00:47:11,280 --> 00:47:12,500
我想说的是

1031
00:47:12,510 --> 00:47:14,420
有一件事确实发生了变化

1032
00:47:14,430 --> 00:47:16,390
但并不是戏剧性的变化

1033
00:47:16,720 --> 00:47:20,850
那就是人们开始意识到 我不想只是使用我的数据系统来处理和接收新数据

1034
00:47:21,220 --> 00:47:22,890
有人想开始做分析

1035
00:47:22,900 --> 00:47:26,170
开始推断新的信息业务

1036
00:47:26,180 --> 00:47:28,770
智能决策支持有很多不同的名称

1037
00:47:30,240 --> 00:47:32,230
当时所有这些系统都是行存储

1038
00:47:33,230 --> 00:47:33,970
正如我们所知

1039
00:47:33,980 --> 00:47:37,130
在行存储上运行分析查询的效率非常低

1040
00:47:38,070 --> 00:47:42,550
有一种叫做数据立方体的优化技术

1041
00:47:42,560 --> 00:47:44,470
你基本上就像物化视图一样

1042
00:47:44,750 --> 00:47:46,990
你预先计算这些不同

1043
00:47:47,980 --> 00:47:51,600
组的多个常规阵列和聚合等等

1044
00:47:51,950 --> 00:47:53,910
你会在比赛前运行你的分析

1045
00:47:54,800 --> 00:47:58,700
现在没有人使用数据立方体 因为列存储的速度要快得多

1046
00:47:59,130 --> 00:48:01,730
但这就是上世纪90年代人们的生活方式

1047
00:48:04,260 --> 00:48:05,370
因此

1048
00:48:05,380 --> 00:48:07,910
最大的游戏规则改变者是2000年代互联网的出现

1049
00:48:09,120 --> 00:48:10,790
所以 在此之前

1050
00:48:10,800 --> 00:48:12,590
当你想到谁拥有大数据库时

1051
00:48:13,790 --> 00:48:16,030
大爆炸 沃尔玛 对吧

1052
00:48:16,040 --> 00:48:19,800
只有财富500强公司才有大数据问题

1053
00:48:20,880 --> 00:48:22,160
但当互联网出现时

1054
00:48:23,730 --> 00:48:26,430
一小部分人把东西放到互联网上

1055
00:48:26,440 --> 00:48:29,900
让很多人开始使用网站的应用程序

1056
00:48:29,910 --> 00:48:30,500
这并不需要太多时间

1057
00:48:31,010 --> 00:48:33,470
你开始产生大量的流量和数据

1058
00:48:33,480 --> 00:48:34,270
大量的用户

1059
00:48:35,430 --> 00:48:35,840
对的

1060
00:48:36,860 --> 00:48:40,800
所以这是2000年人们如何处理数据库的一个巨大变化

1061
00:48:42,470 --> 00:48:43,340
但在当时

1062
00:48:43,350 --> 00:48:46,970
所有的商业企业数据库都是重量级的 比如oracle

1063
00:48:47,800 --> 00:48:50,750
db two cyprus 它们都非常昂贵

1064
00:48:52,710 --> 00:48:54,950
然后我们今天想到的开源数据库

1065
00:48:55,340 --> 00:48:56,820
明信片和我的SQL

1066
00:48:57,300 --> 00:48:58,730
它们在过去是非常原始的

1067
00:48:59,900 --> 00:49:04,360
我的续篇支持事务

1068
00:49:05,090 --> 00:49:06,360
直到2003年和2004年Inter DB出现

1069
00:49:07,890 --> 00:49:11,550
因此

1070
00:49:11,560 --> 00:49:16,500
人们最终要做的是编写自己的自定义中间件

1071
00:49:16,510 --> 00:49:16,780
将查询路由到这些单节点数据库索引

1072
00:49:17,350 --> 00:49:20,040
所以他们会把我的SQL当作一个哑键值存储

1073
00:49:20,630 --> 00:49:24,200
然后在它前面有一些东西来将查询路由到不同的碎片

1074
00:49:24,210 --> 00:49:27,410
这个想法至今仍被广泛使用

1075
00:49:27,420 --> 00:49:29,730
但人们自己错了

1076
00:49:29,740 --> 00:49:29,970
然后

1077
00:49:29,980 --> 00:49:33,290
发生的另一件事是

1078
00:49:33,550 --> 00:49:34,100
正如我所说的

1079
00:49:34,110 --> 00:49:36,260
开始收集大量数据并不需要那么多时间

1080
00:49:36,730 --> 00:49:38,860
更多的人开始想要分析这些数据

1081
00:49:39,780 --> 00:49:43,350
然后我们意识到

1082
00:49:43,360 --> 00:49:46,600
或者他们意识到

1083
00:49:47,030 --> 00:49:47,650
行存储中的通用数据系统试图进行交易和分析

1084
00:49:48,120 --> 00:49:48,900
这是个坏主意吗

1085
00:49:48,910 --> 00:49:51,960
人们开始建立这些定制的分析数据系统

1086
00:49:52,450 --> 00:49:52,800


1087
00:49:52,810 --> 00:49:57,150
这也将是我们这学期关注的关键思想

1088
00:49:58,120 --> 00:50:00,460
其中很多都是分发的 我们没有分享任何东西

1089
00:50:00,470 --> 00:50:02,220
所有这些实际上都是关系和SQL

1090
00:50:02,230 --> 00:50:07,600
其中大多数都是POST图的分支

1091
00:50:09,210 --> 00:50:13,670
他们将把数据库存储为列存储

1092
00:50:14,580 --> 00:50:16,660
再一次 现在似乎是一个显而易见的想法

1093
00:50:17,340 --> 00:50:19,870
因为你得到的风是如此重要

1094
00:50:20,420 --> 00:50:21,630
这在当时是闻所未闻的

1095
00:50:22,030 --> 00:50:23,770
这不是闻所未闻的

1096
00:50:23,780 --> 00:50:26,000
因为70年代的想法

1097
00:50:26,010 --> 00:50:28,080
但就像这些明确存储的想法专栏是新颖的

1098
00:50:28,970 --> 00:50:29,810
这是游戏规则的改变者

1099
00:50:31,540 --> 00:50:35,630
所以这里列出了目前主要系统的种类

1100
00:50:35,970 --> 00:50:37,620
因此 natzisa是postgrasse的一个分支

1101
00:50:37,630 --> 00:50:42,280
但他们将fpga放到存储层 使其更快地运行滤波器

1102
00:50:43,170 --> 00:50:44,480
帕克出售一大堆明信片

1103
00:50:44,490 --> 00:50:45,640
分发版Postgres

1104
00:50:46,590 --> 00:50:48,390
这就是所谓的红移

1105
00:50:48,400 --> 00:50:50,230
他们买了停车许可证

1106
00:50:50,870 --> 00:50:53,570
并没有真正做任何改变 只是把它拍起来 并称之为红移

1107
00:50:54,580 --> 00:50:58,400
这不是秘密

1108
00:50:58,410 --> 00:50:59,720
我告诉你 好吧 这是公开的

1109
00:51:01,720 --> 00:51:03,090
所以就吐了出来

1110
00:51:03,570 --> 00:51:04,410
它赚了这么多钱

1111
00:51:04,740 --> 00:51:06,130
现在我们必须开始让这一切成为现实

1112
00:51:07,250 --> 00:51:07,420
对的

1113
00:51:07,430 --> 00:51:11,040
它在Vertica上被写了很多次

1114
00:51:11,050 --> 00:51:13,240
这是一家由我的顾问迈克·斯

1115
00:51:13,250 --> 00:51:15,820
通·布雷克和圣佐纳蒂克创办的公司

1116
00:51:15,830 --> 00:51:17,180
那是一把叉子 一把叉子

1117
00:51:17,720 --> 00:51:20,540
Data Leg Row是Ingress的较短版本

1118
00:51:20,550 --> 00:51:24,130
青梅是一个叉子

1119
00:51:24,140 --> 00:51:26,130
而Postgres模式ADB正是另一个从零开始编写的模式

1120
00:51:27,190 --> 00:51:28,700
从CWI出来的也是一样

1121
00:51:28,710 --> 00:51:33,490
你听说过ducky b吗 它是制作mode adb.

1122
00:51:33,500 --> 00:51:36,490
db的同一个研究小组 最初被称为mode db light

1123
00:51:36,500 --> 00:51:40,740
这是一个分叉模式的数据库 可以像我们的程序一样嵌入运行

1124
00:51:41,250 --> 00:51:46,850
然后他们重写了它 最后变成了道格db

1125
00:51:46,860 --> 00:51:47,750
我不确定我可能要流这个血

1126
00:51:47,760 --> 00:51:48,590
我不确定这是公开的

1127
00:51:49,220 --> 00:51:51,570
微软买了数据 微软买了数据 leg grow

1128
00:51:51,580 --> 00:51:53,510
ibm买了teaser park sell

1129
00:51:53,520 --> 00:51:54,830
他们永远不会被收买

1130
00:51:54,840 --> 00:51:56,150
他有 我也有执照

1131
00:51:56,160 --> 00:52:00,630
我认为公司的死亡vertica被惠普收购了

1132
00:52:00,640 --> 00:52:02,990
你们中的任何一个都没有被收购 然后green palm被收购了

1133
00:52:04,940 --> 00:52:10,290
没有EMC 请稍候

1134
00:52:11,920 --> 00:52:14,630
在某种程度上 有miemc很难跟踪这一点

1135
00:52:15,670 --> 00:52:16,400
他们被收买了

1136
00:52:18,070 --> 00:52:21,220
然后他们将其剥离给EMC 以便收回

1137
00:52:21,510 --> 00:52:23,570
EMC有一个数据库部分

1138
00:52:24,310 --> 00:52:25,400
VMR有一个数据库片段

1139
00:52:25,740 --> 00:52:27,900
他们把它拿出来 成立了一家名为Pivotal的新公司

1140
00:52:29,420 --> 00:52:33,250
它是绿色棕榈 然后是续集火或宝石火

1141
00:52:35,290 --> 00:52:37,870
我认为注意到EMC购买了它们

1142
00:52:37,880 --> 00:52:39,150
VM Ware购买了SQL文件

1143
00:52:39,900 --> 00:52:41,270
他们把它们拿出来

1144
00:52:41,280 --> 00:52:42,880
做了pivotal 然后bmr收购了pivotal

1145
00:52:44,110 --> 00:52:49,920
所以数据腿排和微软站在了一起

1146
00:52:50,360 --> 00:52:53,180
这是海图入口的一个破解版本

1147
00:52:54,130 --> 00:52:55,950
我想他们为此付了钱

1148
00:52:56,270 --> 00:52:57,400
然后在他们买了它之后

1149
00:52:57,410 --> 00:52:58,780
所以在他们写了支票之后

1150
00:52:59,310 --> 00:53:01,660
他们让他们的技术人员看了看

1151
00:53:01,670 --> 00:53:02,100
然后说这都是废话

1152
00:53:02,110 --> 00:53:03,860
我们不能用这些东西 他们把它们都扔了

1153
00:53:05,140 --> 00:53:08,170
他们最终从头开始运行Sequel服务器数据仓库

1154
00:53:08,940 --> 00:53:10,760
并行数据仓库

1155
00:53:10,770 --> 00:53:11,240
而不是使用这些垃圾

1156
00:53:13,270 --> 00:53:13,930
还有一个

1157
00:53:14,060 --> 00:53:16,450
我错过了他们购买的阿斯特数据

1158
00:53:17,950 --> 00:53:19,540
我想他们是被恐怖数据收买的

1159
00:53:26,820 --> 00:53:30,780
虽然所有这些工作都是在这些并行列存储数据仓库上进行的

1160
00:53:31,680 --> 00:53:35,580
但还有另一个大趋势 即这些减少了遮罩的系统

1161
00:53:36,320 --> 00:53:36,570
再一次

1162
00:53:36,580 --> 00:53:39,290
自从普通数据库的对象是一个坏主意以来

1163
00:53:39,300 --> 00:53:40,050
已经过去了10年

1164
00:53:40,660 --> 00:53:43,850
现在我们已经10年了 所以这个东西来自谷歌

1165
00:53:45,890 --> 00:53:48,200
他们用这个地图建立了一个自定义的执行引擎

1166
00:53:48,210 --> 00:53:53,320
减少了编程模型

1167
00:53:53,330 --> 00:53:54,080
以帮助他们抓取他们的建立索引的网页抓取

1168
00:53:54,880 --> 00:53:57,810
他们最终将其用于其他数据处理任务或分析

1169
00:53:57,820 --> 00:53:58,440
任务

1170
00:53:59,430 --> 00:54:00,720
所以谷歌发布了这篇论文 说

1171
00:54:01,040 --> 00:54:02,350
嘿 这就是我们正在使用的

1172
00:54:03,490 --> 00:54:04,620
PI现在仍在发生

1173
00:54:04,630 --> 00:54:08,860
但谷歌在2000年代确实是超级热门的东西

1174
00:54:09,360 --> 00:54:09,470
对的

1175
00:54:10,000 --> 00:54:11,990
他们所做的任何事情 他们发表的任何论文

1176
00:54:12,000 --> 00:54:13,750
人们最终都会去重新实现自己

1177
00:54:13,760 --> 00:54:15,510
因为他们认为谷歌赚了一大笔钱

1178
00:54:16,110 --> 00:54:17,230
因为他们拥有所有这些定制系统

1179
00:54:17,240 --> 00:54:18,830
让我们也去建立我们自己的自定义系统

1180
00:54:19,500 --> 00:54:19,750
对的

1181
00:54:20,460 --> 00:54:22,830
就像H Base是一个大表的克隆

1182
00:54:23,220 --> 00:54:29,830
因为Cassandra是一个大表的克隆

1183
00:54:29,840 --> 00:54:32,550
而Dynamo DB是ACFS的Dude是Matt Reduce的克隆

1184
00:54:34,030 --> 00:54:36,990
所以谷歌把地图减少了纸

1185
00:54:37,550 --> 00:54:39,540
雅虎说 看 这是个好主意

1186
00:54:39,550 --> 00:54:40,420
我们也可以用它

1187
00:54:40,810 --> 00:54:43,050
他们编写了自己的开源版本 名为Duke

1188
00:54:44,650 --> 00:54:47,430
基本的想法是

1189
00:54:47,440 --> 00:54:52,610
你可以像写地图一样写这些用户定义的函数 并在下一节课上减少洗牌阶段

1190
00:54:54,720 --> 00:54:57,100
您可以编写这些自定义函数 而不是使用Sequel

1191
00:54:57,110 --> 00:55:00,620
您只需将它们提交给davis 再提交给map reduce或do框架

1192
00:55:00,950 --> 00:55:01,690
然后为您运行它们

1193
00:55:03,070 --> 00:55:07,630
它把我们带回了20世纪70年代

1194
00:55:07,640 --> 00:55:09,830
那时程序员必须定义数据模型或他们正在处理的数据

1195
00:55:10,680 --> 00:55:12,980
在这些系统的时候没有续集

1196
00:55:13,270 --> 00:55:15,080
你必须从字面上写所有的部分

1197
00:55:15,350 --> 00:55:17,380
我要解析这个CSV文件

1198
00:55:17,390 --> 00:55:18,740
我希望他们有这些列

1199
00:55:18,750 --> 00:55:23,510
你可以在这些函数的程序编码器中写下明确的

1200
00:55:23,960 --> 00:55:24,910
引文

1201
00:55:26,440 --> 00:55:28,500
所以这是2000年末的热门话题

1202
00:55:28,510 --> 00:55:29,940
这就像是这样做的方式

1203
00:55:29,950 --> 00:55:30,540
你应该加起来

1204
00:55:31,720 --> 00:55:32,860
然后破石者

1205
00:55:32,870 --> 00:55:36,990
然后另一个发明了很多第一个枕头数据库的人 发表了一篇文章

1206
00:55:37,800 --> 00:55:39,520
说这是一个坏主意

1207
00:55:39,830 --> 00:55:41,930
然后我给他们写了一篇论文 证明它是

1208
00:55:43,590 --> 00:55:46,190
然后人们最终意识到这一点 事实证明老家伙们是对的

1209
00:55:46,200 --> 00:55:47,150
这是个坏主意

1210
00:55:47,820 --> 00:55:50,420
所以他们试图把续集放在地图上

1211
00:55:50,430 --> 00:55:52,700
减少Facebook发明的蜂巢

1212
00:55:52,710 --> 00:55:56,490
在地图R上有一个叫做地图RDB的东西 我想他们现在已经死了

1213
00:55:57,660 --> 00:55:59,700
但后来发现这是超级低效和超级缓慢的

1214
00:55:59,710 --> 00:56:05,470
因为她的家伙实际上是如何实现的

1215
00:56:05,480 --> 00:56:09,570
或者我不知道地图艺术框架实际上是如何工作的

1216
00:56:09,580 --> 00:56:13,190
但他们在查询的每一个阶段存储这些检查点的

1217
00:56:13,200 --> 00:56:15,310
方式是超级低效的

1218
00:56:16,990 --> 00:56:19,200
所以这一切都被抛弃了

1219
00:56:19,210 --> 00:56:20,120
我我仍然存在

1220
00:56:20,130 --> 00:56:23,830
但就像人们意识到这实际上是一个坏主意

1221
00:56:24,810 --> 00:56:27,240
因为你想要一个类似于仓库的东西

1222
00:56:27,250 --> 00:56:28,800
你想要我们之前看到的东西

1223
00:56:29,920 --> 00:56:31,920
但人们又花了10年时间才意识到这一点

1224
00:56:31,930 --> 00:56:32,720
这是个坏主意

1225
00:56:34,680 --> 00:56:37,050
同样相关的是 我不会在这里说不好的想法

1226
00:56:37,060 --> 00:56:40,620
但又有了这个没有续集的运动

1227
00:56:40,630 --> 00:56:45,020
我认为是由谷歌带来的

1228
00:56:45,400 --> 00:56:48,390
大桌子上的纸基本上说 嘿 种族模式是不好的

1229
00:56:48,560 --> 00:56:52,220
对于现代Web应用程序来说 Sequel太慢了

1230
00:56:53,170 --> 00:56:54,600
我们不需要交易 我们不需要关节

1231
00:56:55,130 --> 00:56:56,330
我们想从头开始建立这些系统

1232
00:56:57,240 --> 00:56:57,280
对吗

1233
00:56:57,290 --> 00:56:59,630
因为您必须了解

1234
00:56:59,640 --> 00:57:06,250
如果您正在构建一个网站

1235
00:57:06,260 --> 00:57:07,170
您需要在数据库系统事务中考虑2047个事务

1236
00:57:07,990 --> 00:57:11,470
这些事务可能没有备份或副本以实现高可用性

1237
00:57:12,080 --> 00:57:13,560
这意味着如果没有宕机

1238
00:57:13,570 --> 00:57:15,980
如果你的整个网站宕机 那很糟糕 你会赔钱

1239
00:57:17,950 --> 00:57:19,850
所以没有续集的人说

1240
00:57:20,690 --> 00:57:25,370
好吧 也许你要让系统可能有损坏的数据

1241
00:57:25,380 --> 00:57:28,690
或者不严格遵循事务语义

1242
00:57:28,700 --> 00:57:31,910
传输以换取始终启动 始终在线

1243
00:57:31,920 --> 00:57:35,110
所以有很多这样的系统被建造出来

1244
00:57:35,470 --> 00:57:36,540
在这种模式下

1245
00:57:36,550 --> 00:57:39,540
有些事情有时是爆炸性的

1246
00:57:39,550 --> 00:57:41,500
DB是亚马逊为购物车打造的

1247
00:57:42,950 --> 00:57:45,060
如果我把一些放进购物车 它可能会消失

1248
00:57:45,070 --> 00:57:46,960
这是世界末日

1249
00:57:48,090 --> 00:57:48,540
可能不会

1250
00:57:49,720 --> 00:57:52,520
如果我在银行账户里存了钱 然后消失了 那就是个大问题

1251
00:57:53,050 --> 00:57:53,400
对的

1252
00:57:54,150 --> 00:57:58,180
因此 所有这些系统基本上都遵循不同的松散语义

1253
00:57:58,190 --> 00:58:01,390
而传统的关系事务

1254
00:58:01,400 --> 00:58:05,930
强一致性日常系统则遵循不同的成功程度

1255
00:58:06,830 --> 00:58:07,860
正如我之前所说

1256
00:58:07,870 --> 00:58:10,890
现在基本上每个人都支持segal 除了retis

1257
00:58:11,540 --> 00:58:14,730
我认为raven db他们都有自己的sql版本 但它基本上是sql

1258
00:58:14,740 --> 00:58:19,120
不想说它的反应是死的

1259
00:58:19,130 --> 00:58:22,730
所以 我不认为我们有任何

1260
00:58:22,740 --> 00:58:28,850
然后甲骨文新的续集 我认为这是完美的 在同一时间被掩盖

1261
00:58:28,860 --> 00:58:32,530
好吧 在“无续集”数据库流行后不久

1262
00:58:33,060 --> 00:58:34,460
就出现了另一个运动 叫做“新续集”

1263
00:58:34,470 --> 00:58:38,740
我参与的这个项目的想法是

1264
00:58:38,750 --> 00:58:42,160
您不会拥有与无SQL数据库系统相同的高可伸缩性和性能

1265
00:58:42,620 --> 00:58:44,010
但在不放弃交易的情况下

1266
00:58:45,560 --> 00:58:47,010
显然 你不能

1267
00:58:49,440 --> 00:58:50,750
你不可能超过光速

1268
00:58:50,760 --> 00:58:53,150
因此 如果你在世界的不同地区都有机器

1269
00:58:53,370 --> 00:58:54,610
你不能让它运行得更快

1270
00:58:55,070 --> 00:58:56,550
但你至少要确保事情是正确的

1271
00:58:57,990 --> 00:59:01,550
因此 除了odb map c之外 所有在“无Segal ”

1272
00:59:01,990 --> 00:59:06,930
运动下推出的系统都将重命名为sequel store

1273
00:59:06,940 --> 00:59:09,850
并且它们现在不一定会称自己为新的sql系统

1274
00:59:10,240 --> 00:59:11,520
然后扳手做了细节

1275
00:59:11,530 --> 00:59:12,400
扳手还在这里

1276
00:59:12,410 --> 00:59:13,360
扳手是合法的

1277
00:59:13,810 --> 00:59:14,600
但在大多数情况下

1278
00:59:14,610 --> 00:59:16,360
在trans lattice之前

1279
00:59:16,370 --> 00:59:20,310
你从来没有听说过很多东西 我敢肯定没有人听说过gddb 他们几乎都失败了

1280
00:59:21,610 --> 00:59:23,920
DB基金会在那里有一个续集 那是一种垃圾

1281
00:59:24,530 --> 00:59:26,010
苹果买下了 扔掉了

1282
00:59:26,410 --> 00:59:27,750
他们已经开源了它

1283
00:59:27,760 --> 00:59:31,990
但它没有被用作Sequel的关系数据系统

1284
00:59:32,000 --> 00:59:32,150
现在

1285
00:59:33,110 --> 00:59:34,620
但发生了什么

1286
00:59:34,630 --> 00:59:36,740
所有这些系统都没有成功

1287
00:59:37,240 --> 00:59:41,800
新的交易数据系统实际上并没有得到一些牵引力

1288
00:59:41,810 --> 00:59:44,920
而这些都属于分布式Sequel的范畴

1289
00:59:45,530 --> 00:59:47,040
而不是调用新的SQL是一种模糊的

1290
00:59:47,050 --> 00:59:48,760
你说它是一个衍生的SQL系统

1291
00:59:49,610 --> 00:59:51,440
浪潮EB退出中国

1292
00:59:51,450 --> 00:59:54,960
科克伦EB可能是所有这些中筹集资金最多的

1293
00:59:55,510 --> 00:59:58,590
然后你就变成了另一家基于研究生的创业公司

1294
00:59:58,950 --> 01:00:01,170
我认为 COM DB Two是由Bloomberg建立的

1295
01:00:01,980 --> 01:00:04,890
我从来没有听说过有人在彭博以外的地方使用com db 2

1296
01:00:05,670 --> 01:00:07,100
但这是荒谬的 所以它并不存在

1297
01:00:08,760 --> 01:00:11,870
所以这里主要的收获是这些系统

1298
01:00:13,170 --> 01:00:15,520
这些系统违背了传统智慧

1299
01:00:15,530 --> 01:00:16,160
就像你想要一个原始模型一样

1300
01:00:16,170 --> 01:00:17,520
你想要在交易中继续一个

1301
01:00:17,860 --> 01:00:19,330
因为所有新的续集系统都很热门

1302
01:00:19,880 --> 01:00:23,040
当人们意识到我确实想要续集时 我确实想要交易

1303
01:00:24,270 --> 01:00:26,780
他们失败了或者没有成功

1304
01:00:27,100 --> 01:00:29,370
然后这些系统在正确的时间出现在正确的地方

1305
01:00:29,380 --> 01:00:34,600
建立在早期系统已经完成的东西之上

1306
01:00:34,690 --> 01:00:35,960
我们有云系统

1307
01:00:36,850 --> 01:00:38,410
同样 我们将在整个学期中对此进行大量讨论

1308
01:00:38,850 --> 01:00:41,210
基本上 现在逃离的港湾已经改变了

1309
01:00:41,690 --> 01:00:43,210
人们不再在婴儿车上奔跑

1310
01:00:43,860 --> 01:00:45,220
您现在正在云中运行

1311
01:00:46,380 --> 01:00:46,670
是吧

1312
01:00:46,680 --> 01:00:48,870
这意味着你的资源是有弹性的

1313
01:00:48,880 --> 01:00:51,150
您不必经历这种漫长的配置周期

1314
01:00:51,420 --> 01:00:52,670
例如 我想购买这些机器并进行采购

1315
01:00:52,680 --> 01:00:54,270
而实际获得它们需要很长时间

1316
01:00:54,770 --> 01:00:55,360
用信用卡

1317
01:00:55,370 --> 01:00:57,000
您可以非常快速地创建一个新实例

1318
01:00:58,140 --> 01:01:00,980
所以最初有一堆服务产品或产品的数据库

1319
01:01:00,990 --> 01:01:05,840
它只会像现成的一样

1320
01:01:05,850 --> 01:01:08,830
而不是AVM

1321
01:01:08,840 --> 01:01:10,710
对你来说 这是在集装箱之前 而不是在avm之前

1322
01:01:11,060 --> 01:01:12,000
他们会向你收费

1323
01:01:12,280 --> 01:01:12,840
但它没有

1324
01:01:13,270 --> 01:01:14,990
我的续集并没有真正意识到它在云中运行

1325
01:01:15,000 --> 01:01:18,690
它只是在一些虚拟机上运行 但从那时起

1326
01:01:18,700 --> 01:01:22,660
现在有从零开始设计的评估

1327
01:01:22,670 --> 01:01:23,700
明确用于在云系统中运行

1328
01:01:24,000 --> 01:01:25,960
但我们会称这些云为原生雪花

1329
01:01:25,970 --> 01:01:28,480
可能是所有这些中最出名的一个

1330
01:01:28,490 --> 01:01:29,560
就像他们一开始明确设计的那样

1331
01:01:29,910 --> 01:01:32,370
不在婴儿车上运行 只在云中运行

1332
01:01:32,680 --> 01:01:33,110
因此

1333
01:01:33,120 --> 01:01:35,700
你可以做出某些设计选择 这将涵盖下周

1334
01:01:36,070 --> 01:01:37,540
可以利用这一点

1335
01:01:39,760 --> 01:01:41,250
想做的事也要到那去

1336
01:01:41,570 --> 01:01:44,190
从地图中产生的世界加上现在的云

1337
01:01:44,730 --> 01:01:46,360
这些是共享磁盘系统吗

1338
01:01:47,480 --> 01:01:48,350
在此之前

1339
01:01:48,720 --> 01:01:52,580
传统的智慧

1340
01:01:52,590 --> 01:01:53,980
你将如何建立它和贡品每日系统是不会分享什么

1341
01:01:54,990 --> 01:01:57,610
现在有了云

1342
01:01:57,620 --> 01:01:59,170
Amazon或任何为您负责存储层的人

1343
01:02:01,020 --> 01:02:02,640
你不想什么都不共享系统

1344
01:02:02,650 --> 01:02:06,620
您希望使用共享磁盘系统

1345
01:02:06,630 --> 01:02:07,300
并让云供应商为您处理存储

1346
01:02:08,550 --> 01:02:13,390
因此 现在有许多系统都是基于这种共享磁盘方法构建的

1347
01:02:13,730 --> 01:02:14,510
这就是事实

1348
01:02:14,520 --> 01:02:17,670
这就是今天每个人构建现代数据系统的方式

1349
01:02:18,670 --> 01:02:20,090
人们谈论我有一个数据湖

1350
01:02:20,980 --> 01:02:21,190
对吗

1351
01:02:21,200 --> 01:02:22,510
否则我们会看到这个

1352
01:02:23,310 --> 01:02:24,260
当我们谈论数据砖块时

1353
01:02:25,920 --> 01:02:28,450
他们说的基本上是在S 3上服务 对吗

1354
01:02:28,580 --> 01:02:30,370
具有共享磁盘模型的东西

1355
01:02:32,980 --> 01:02:35,350
每年我都要抱怨这个

1356
01:02:37,910 --> 01:02:40,570
我们现在正处于这样一个阶段

1357
01:02:41,280 --> 01:02:42,320
再一次 没有sql 没有续集的女人消失了

1358
01:02:42,330 --> 01:02:49,910
人们意识到续集是未来的发展方向

1359
01:02:50,320 --> 01:02:52,760
我不一定会把这些新的sequel系统称为sequel系统 但在过去的5

1360
01:02:53,540 --> 01:02:56,820
6年里 它们肯定会变得更加突出

1361
01:02:57,270 --> 01:02:58,440
或者这些图形数据库系统

1362
01:02:58,770 --> 01:03:03,740
但其思想是不将数据库存储为关系

1363
01:03:04,910 --> 01:03:06,470
从本质上讲 它是一个图表

1364
01:03:06,480 --> 01:03:09,780
让我把它分类为关系之间的图形结构等等

1365
01:03:09,790 --> 01:03:12,460
这可以是RDF或三元组存储或属性图

1366
01:03:12,470 --> 01:03:13,940
它有一堆不同的名字

1367
01:03:14,780 --> 01:03:17,500
但本质上

1368
01:03:17,670 --> 01:03:19,830
这与他们在70年代用科达索网络模型所做的事情是一样的

1369
01:03:21,420 --> 01:03:24,930
所以最大的声明是

1370
01:03:24,940 --> 01:03:26,490
因为你正在启动一个像图表一样消极的数据库

1371
01:03:27,090 --> 01:03:30,520
因为您现在公开了一个NATO图形API

1372
01:03:30,530 --> 01:03:32,040
所以您可以比关系数据系统好得多

1373
01:03:33,290 --> 01:03:33,960
我们以前听说过

1374
01:03:34,130 --> 01:03:36,200
这就是面向对象数据库的论点

1375
01:03:36,930 --> 01:03:37,600
它是物体

1376
01:03:39,270 --> 01:03:40,840
贾森数据库

1377
01:03:40,850 --> 01:03:42,120
所有这些人都提出了同样的论点

1378
01:03:43,150 --> 01:03:47,980
当然 有时您确实需要遍历数据库

1379
01:03:50,730 --> 01:03:52,720
以一种原生图形的方式

1380
01:03:54,330 --> 01:03:57,940
但Segal标准今年实际上增加了对图形查询的支持

1381
01:03:59,870 --> 01:04:00,760
它是基于密码的

1382
01:04:00,770 --> 01:04:06,570
这是由neo为j发明的 所以他们失去了优势

1383
01:04:07,440 --> 01:04:10,300
那么 如果我以消极的方式开始

1384
01:04:10,310 --> 01:04:13,470
那么图不会比关系数据库更好 这一论点又如何呢

1385
01:04:13,600 --> 01:04:13,710
不

1386
01:04:13,720 --> 01:04:17,120
因为上周发表的一篇论文表明

1387
01:04:17,510 --> 01:04:21,860
如果您构建了数据库 您就会结合一些技术

1388
01:04:21,870 --> 01:04:22,380
这些技术将明确地帮助图形工作负载

1389
01:04:22,790 --> 01:04:23,470
就像多波加入 我们将在本学期晚些时候介绍

1390
01:04:23,480 --> 01:04:28,710
你不能通过10 x dfoj为j执行mu

1391
01:04:28,720 --> 01:04:33,100
dfoj已经筹集了数亿美元

1392
01:04:33,690 --> 01:04:38,900
B医生就像是荷兰的一个小团队

1393
01:04:40,190 --> 01:04:43,270
他们以10:00的速度击败了他们 这是一个真正的系统

1394
01:04:43,280 --> 01:04:44,470
它不只是一个玩具

1395
01:04:49,150 --> 01:04:50,470
我认为图表数据库

1396
01:04:51,480 --> 01:04:54,910
我们已经看到这种种族模式正在吸收它的思想

1397
01:04:55,970 --> 01:05:00,930
在我的有生之年

1398
01:05:01,770 --> 01:05:02,380
我没有看到这些系统真正取代戴维斯的关系

1399
01:05:02,820 --> 01:05:03,820
我应该做个演讲的

1400
01:05:03,830 --> 01:05:09,780
我做了一个公开的赌注 我做了一个公开的赌注

1401
01:05:09,790 --> 01:05:13,090
他们说在2020年到2030年

1402
01:05:13,100 --> 01:05:16,350
图形数据库市场超过了种族数据库市场

1403
01:05:16,700 --> 01:05:19,210
我会把我的官方CMU目录照片改成这样

1404
01:05:19,500 --> 01:05:23,140
我敢肯定 当他说我喜欢图表数据库时

1405
01:05:23,150 --> 01:05:24,660
我会一直使用它 直到我死了或者因为见到你而被解雇

1406
01:05:25,120 --> 01:05:26,610
我不认为这会发生

1407
01:05:28,450 --> 01:05:28,650
好吧

1408
01:05:28,740 --> 01:05:30,810
所以很快就完成了时间序列数据库

1409
01:05:30,820 --> 01:05:34,740
因此 现在这些是较新的数据库

1410
01:05:35,050 --> 01:05:39,030
旨在存储您正在收集的遥测数据或您正在从其他服务

1411
01:05:39,040 --> 01:05:40,310
其他设备等收集的指标

1412
01:05:40,830 --> 01:05:41,780
它是关系型的

1413
01:05:42,270 --> 01:05:47,110
有明确的时间顺序和你正在生成的数据的概念

1414
01:05:47,510 --> 01:05:47,770
因此

1415
01:05:47,780 --> 01:05:52,420
您可以将系统设计为正式利用您正在工作的

1416
01:05:52,430 --> 01:05:53,180
领域

1417
01:05:53,990 --> 01:05:56,740
您不会想要使用它们来存储任意数据

1418
01:05:57,210 --> 01:05:59,320
如果你有这样的概念

1419
01:05:59,330 --> 01:06:02,040
比如滴答声或事件与时间的概念一起出现

1420
01:06:02,520 --> 01:06:04,510
任何人都可以根据这些时间进行范围查询

1421
01:06:05,120 --> 01:06:07,140
你可以设计一个系统来更有效地做到这一点

1422
01:06:07,850 --> 01:06:10,200
所以三个主要的可能是时间尺度

1423
01:06:10,210 --> 01:06:13,950
这是在后图表之上使用扩展

1424
01:06:14,260 --> 01:06:17,440
这是超级酷的 因为你得到了常规的表格和后图表加上时间序列

1425
01:06:17,970 --> 01:06:20,440
流入EB是从头开始编写的

1426
01:06:21,150 --> 01:06:22,980
我想他们是第三次重写了

1427
01:06:24,480 --> 01:06:25,820
但同样

1428
01:06:25,830 --> 01:06:27,100
他们的目标是时间序列

1429
01:06:29,710 --> 01:06:31,350
点击房子不在俄罗斯

1430
01:06:32,690 --> 01:06:37,540
这可能是当我第一次了解点击时

1431
01:06:37,550 --> 01:06:38,980
当你阅读网站和他们支持的所有东西时

1432
01:06:39,150 --> 01:06:40,740
我们在课堂上讨论了很多技巧

1433
01:06:41,000 --> 01:06:41,620
这似乎不真实

1434
01:06:41,630 --> 01:06:43,090
这是最先进的

1435
01:06:44,370 --> 01:06:45,680
表演者萨默斯看起来棒极了

1436
01:06:45,940 --> 01:06:46,870
不过 我的印象是 启动和运行并不容易

1437
01:06:46,880 --> 01:06:53,750
还有很多手工工作要做

1438
01:06:53,760 --> 01:06:54,710
但我认为这将

1439
01:06:54,720 --> 01:06:56,590
是一个大玩家

1440
01:06:56,920 --> 01:07:00,930
普罗米修斯是这一领域的另一项重大成就

1441
01:07:03,370 --> 01:07:03,930
最后一个

1442
01:07:05,150 --> 01:07:05,780
区块链设备

1443
01:07:12,810 --> 01:07:13,190
是的 比特币

1444
01:07:13,640 --> 01:07:15,830
如果你在2010年买了比特币

1445
01:07:15,840 --> 01:07:16,050
棒极了

1446
01:07:16,060 --> 01:07:16,270
谢谢

1447
01:07:16,650 --> 01:07:17,030
祝贺

1448
01:07:18,730 --> 01:07:22,770
但就像人们曾经宣称的那样 区块链数据库是

1449
01:07:24,100 --> 01:07:25,850
在网络三下 或者大家所说的

1450
01:07:25,860 --> 01:07:29,560
这是构建现代应用程序的一种完全不同的方式

1451
01:07:29,570 --> 01:07:33,120
在关系数据库和Sequel上提供这些服务器的旧方法

1452
01:07:33,130 --> 01:07:36,350
以及你想在区块链数据库上建立的所有愚蠢的东西

1453
01:07:36,360 --> 01:07:38,680
来解决世界上所有的问题

1454
01:07:40,020 --> 01:07:41,060
说到底 什么是区块链

1455
01:07:42,220 --> 01:07:43,210
这只是一根木头

1456
01:07:43,620 --> 01:07:44,310
他们会叫账本

1457
01:07:44,320 --> 01:07:48,110
这就像 我提前写日志 或者包说日志 状态日志

1458
01:07:48,640 --> 01:07:51,030
这里是所有的事件或事情正在发生的这一天的行为

1459
01:07:52,270 --> 01:07:54,660
然后他们有这些增量校验

1460
01:07:54,790 --> 01:07:59,110
和其中日志中新条目的校验和依赖于日志中以前的条目

1461
01:07:59,120 --> 01:07:59,390


1462
01:07:59,400 --> 01:08:00,910
如果你捏造任何低于这个标准的东西

1463
01:08:01,410 --> 01:08:03,470
在上一个条目中 校验和不匹配

1464
01:08:03,480 --> 01:08:05,230
并且您没有完整的数据

1465
01:08:05,980 --> 01:08:07,970
这项技术是在默克尔的零食上发明的

1466
01:08:08,820 --> 01:08:09,160
然后现在

1467
01:08:09,170 --> 01:08:11,800
因为你假设你在一个分散的分布式环境中运行

1468
01:08:12,240 --> 01:08:15,110
我们不信任那些直接读入数据库的人

1469
01:08:15,730 --> 01:08:19,540
你必须使用一些访问容错或BFT协议来达成共识

1470
01:08:19,550 --> 01:08:20,260
下一个放入日志的条目是什么

1471
01:08:20,270 --> 01:08:26,630
这是很多很酷的想法

1472
01:08:27,000 --> 01:08:28,920
并以一种有趣的方式组合在一起

1473
01:08:29,380 --> 01:08:31,270
但现在这是游戏规则的改变者吗

1474
01:08:32,660 --> 01:08:32,740
对的

1475
01:08:32,750 --> 01:08:38,560
我还没有看到一个大家都提出的使用案例

1476
01:08:38,570 --> 01:08:40,810
区块链可以解决像postgres这样的传统sql数据库

1477
01:08:40,820 --> 01:08:42,560
无法解决的问题

1478
01:08:44,090 --> 01:08:49,540
或者你有一些外部的外部问题 你必须通过法律来解决

1479
01:08:50,370 --> 01:08:50,570
对吗

1480
01:08:50,580 --> 01:08:51,610
或法律事务

1481
01:08:52,770 --> 01:08:53,260
对的

1482
01:08:54,460 --> 01:08:58,390
所以我觉得都是垃圾

1483
01:09:00,290 --> 01:09:04,040
这里的这些系统在我们的去中心化模型中明确地

1484
01:09:04,760 --> 01:09:06,270
用a来做区块链

1485
01:09:07,700 --> 01:09:10,960
这是podb的标志 亚马逊有最糟糕的标志

1486
01:09:11,230 --> 01:09:13,000
因为它就像 除非它是对的

1487
01:09:13,010 --> 01:09:14,190
喜欢它

1488
01:09:14,560 --> 01:09:16,860
QLQLDB是我们的量子账本数据库

1489
01:09:17,160 --> 01:09:19,930
它不是一个区块链数据库 它像去中心化的

1490
01:09:20,130 --> 01:09:21,500
像亚马逊 权威的信任

1491
01:09:22,030 --> 01:09:23,340
像你认证亚马逊

1492
01:09:23,760 --> 01:09:26,890
你不需要做bfti 他们只需要做两个基本的提交

1493
01:09:28,450 --> 01:09:32,280
但你仍然可以得到可验证的总账和支票总额

1494
01:09:32,290 --> 01:09:33,810
据他们所知

1495
01:09:33,820 --> 01:09:39,040
这是不会去任何地方 他们在销售上赚更多的钱

1496
01:09:39,990 --> 01:09:43,100
转售我的续集和明信片作为rds或根据极光

1497
01:09:44,720 --> 01:09:47,970
再次 我在这一点上 当我第一次看到这些设备

1498
01:09:47,980 --> 01:09:50,640
但也许有一些东西 我相信这一切都是废话

1499
01:09:52,630 --> 01:09:56,060
我可以说区块链数据库没有固有的数据模型

1500
01:09:56,070 --> 01:09:57,580
它只是日志中的条目 只是字节

1501
01:09:58,110 --> 01:10:00,750
它上面有一些引擎 必须解释这些字节是什么

1502
01:10:00,760 --> 01:10:01,950
所以它可以是一个键值存储

1503
01:10:02,450 --> 01:10:03,170
关系数据库

1504
01:10:03,710 --> 01:10:04,300
这不重要

1505
01:10:08,300 --> 01:10:10,420
还有一堆其他的东西应该是2020年

1506
01:10:10,430 --> 01:10:11,260
所以有一个错别字

1507
01:10:11,270 --> 01:10:12,460
还有很多其他的系统

1508
01:10:12,870 --> 01:10:15,560
我们可以讨论嵌入式数据库

1509
01:10:15,570 --> 01:10:20,420
比如sequel light和rock cb和duck tb

1510
01:10:20,430 --> 01:10:24,560
这些多模态或多模型数据库 比如orangu tv

1511
01:10:24,570 --> 01:10:27,480
你可以尝试在一个数据库中支持图形

1512
01:10:27,490 --> 01:10:28,360
关系和文档

1513
01:10:29,150 --> 01:10:31,820
在你们读过的论文中 我们谈到了港口加速

1514
01:10:32,420 --> 01:10:36,000
基本上 人们喜欢寻找埃尔多拉多

1515
01:10:36,490 --> 01:10:38,080
南美洲的黄金之城

1516
01:10:38,710 --> 01:10:41,640
在过去的四五十年里

1517
01:10:41,650 --> 01:10:42,200
人们一直在寻找某种数据库硬件

1518
01:10:42,780 --> 01:10:43,700
从来没有成功过

1519
01:10:44,440 --> 01:10:46,440
人们一直在尝试 但从来没有成功过

1520
01:10:46,950 --> 01:10:47,770
但并不是说它不起作用

1521
01:10:47,780 --> 01:10:52,420
它只是你 它永远不会在市场上得到采用

1522
01:10:53,250 --> 01:10:54,630
商品港总是会赢的

1523
01:10:55,410 --> 01:10:59,250
我不认为FPG AS或GP US是该领域的重大游戏规则改变者

1524
01:10:59,830 --> 01:11:01,830
风险五 可能是一些有趣的东西

1525
01:11:02,140 --> 01:11:03,880
但是 只有google

1526
01:11:03,890 --> 01:11:07,090
amazon和microsoft等云供应商才能提供硬件加速或数据库

1527
01:11:07,410 --> 01:11:10,190
因为在他们的规模上

1528
01:11:10,200 --> 01:11:13,950
他们可以支付5000万美元的开发费用来构建新的定制硬件

1529
01:11:13,960 --> 01:11:17,200
因为他们可以赚很多钱 而且效率更高

1530
01:11:17,680 --> 01:11:18,520
有数百万的客户

1531
01:11:19,560 --> 01:11:20,120
这很难做到

1532
01:11:20,130 --> 01:11:22,000
我认为独立软件供应商

1533
01:11:22,010 --> 01:11:24,690
独立硬件供应商很难打入这个市场

1534
01:11:24,700 --> 01:11:27,970
因为他们不仅设计了芯片或其他硬件加速器

1535
01:11:27,980 --> 01:11:28,810
他们还无法说服

1536
01:11:28,820 --> 01:11:31,700
其他软件公司将其放入自己的数据库中

1537
01:11:31,710 --> 01:11:32,220


1538
01:11:32,230 --> 01:11:33,840
但从来没有发生过

1539
01:11:35,000 --> 01:11:36,540
我们并没有真正讨论数组矩阵

1540
01:11:36,550 --> 01:11:39,500
而向量数据现在成为了新的流行词

1541
01:11:39,510 --> 01:11:40,260
由于机器学习

1542
01:11:40,350 --> 01:11:44,400
在新的数据库中有许多关于向量的新的最近邻搜索

1543
01:11:45,930 --> 01:11:47,020
这些已经存在了一段时间

1544
01:11:47,370 --> 01:11:48,730
但矢量的是新的

1545
01:11:49,070 --> 01:11:50,860
我想说的是

1546
01:11:51,230 --> 01:11:52,410
据我所知

1547
01:11:52,840 --> 01:11:55,250
这是唯一一种你不想使用关系数据库系统的数据类型

1548
01:11:55,260 --> 01:11:57,890
因为你想使用

1549
01:11:57,900 --> 01:11:59,730
专门为向量设计的系统

1550
01:12:00,900 --> 01:12:04,070
因为当你考虑它时 如果它是一个多国数组

1551
01:12:04,440 --> 01:12:05,480
你必须遍历它

1552
01:12:05,490 --> 01:12:08,600
可能是按行和按列以及在不同的维度上

1553
01:12:09,030 --> 01:12:12,490
并且将其存储在具有索引列的表中是一个坏主意

1554
01:12:14,240 --> 01:12:19,120
因此 我认为我们将看到市场是否足够大

1555
01:12:19,130 --> 01:12:20,240
以证明需要一个专门的系统

1556
01:12:20,690 --> 01:12:22,490
在这一点上 答案是否定的 正如我在论文中所说的

1557
01:12:22,500 --> 01:12:26,430
因为亚马逊 微软或谷歌是否提供矢量

1558
01:12:26,440 --> 01:12:27,030
数据库服务

1559
01:12:27,370 --> 01:12:27,730
不

1560
01:12:28,540 --> 01:12:29,060
他们可以建造一个

1561
01:12:29,070 --> 01:12:30,740
他们有无限的钱

1562
01:12:30,750 --> 01:12:33,710
但他们还没有看到一个大市场

1563
01:12:35,520 --> 01:12:38,640
所以我认为现在还为时尚早 但我认为这可能是下一件事

1564
01:12:40,180 --> 01:12:40,260
对的

1565
01:12:40,270 --> 01:12:42,100
有很多这样的标志

1566
01:12:43,140 --> 01:12:43,850
很难跟踪

1567
01:12:47,200 --> 01:12:47,360
我点击了

1568
01:12:47,370 --> 01:12:49,330
好吧

1569
01:12:52,300 --> 01:12:53,870
未来会发生什么

1570
01:12:53,880 --> 01:12:57,340
所以我认为现在我们正处于数据库的黄金时代

1571
01:12:57,660 --> 01:13:00,500
这意味着有这么多不同的选择

1572
01:13:00,510 --> 01:13:02,200
开源 pram上的商业云系统

1573
01:13:04,320 --> 01:13:07,360
续集被认为是现在前进的方向

1574
01:13:07,670 --> 01:13:08,910
再说一次 这将在10年内改变

1575
01:13:09,400 --> 01:13:10,590
但我们会再次回来

1576
01:13:11,150 --> 01:13:13,150
一个例子是10年前的所有新SQL系统

1577
01:13:13,160 --> 01:13:13,790
除了RETIS

1578
01:13:13,800 --> 01:13:15,720
要么我已经死了

1579
01:13:16,440 --> 01:13:19,820
要么他们支持SQL和一些看起来像Rational模型的东西

1580
01:13:23,370 --> 01:13:28,470
就像几千年前的基本算术1+1等于2

1581
01:13:29,840 --> 01:13:31,520
它经受住了时间的考验 因为这是正确的做法

1582
01:13:32,040 --> 01:13:33,610
这就是我在关系模型中看到的

1583
01:13:34,580 --> 01:13:36,460
现在

1584
01:13:36,470 --> 01:13:37,660
Sequel是关系数据库系统的最佳查询语言

1585
01:13:37,670 --> 01:13:38,100
不

1586
01:13:38,810 --> 01:13:40,760
它显然有问题

1587
01:13:41,710 --> 01:13:48,570
但在这个 有这么多的购买和有这么多的现有工具

1588
01:13:49,970 --> 01:13:54,600
和采用SQL数据库系统的实用程序

1589
01:13:54,610 --> 01:13:57,210
任何人都很难改变这一点

1590
01:13:58,900 --> 01:13:59,100
对的

1591
01:13:59,110 --> 01:14:00,820
Sequel本身有太多的分裂

1592
01:14:00,830 --> 01:14:03,140
你怎么说我有一种新的查询语言

1593
01:14:03,980 --> 01:14:05,420
然后每个人都会开始使用它

1594
01:14:06,170 --> 01:14:07,290
是的 你可以建立一个这样的系统

1595
01:14:07,300 --> 01:14:08,550
但没有其他人会使用它

1596
01:14:10,220 --> 01:14:13,760
所以我不知道SQL在未来会走向何方

1597
01:14:13,770 --> 01:14:18,060
除了禁止其他非SQL系统的想法

1598
01:14:18,800 --> 01:14:21,550
但我看到关系模式经受住了时间的考验

1599
01:14:21,560 --> 01:14:22,070
在我看来

1600
01:14:22,440 --> 01:14:24,330
泰德·卡恩赢得巡回世界大战是有原因的

1601
01:14:25,190 --> 01:14:26,830
查尔斯·巴赫曼为柯达萨尔赢得了图灵木奖

1602
01:14:27,490 --> 01:14:27,520
第一

1603
01:14:29,060 --> 01:14:30,010
这两天 并不重要

1604
01:14:30,460 --> 01:14:31,830
好吧

1605
01:14:31,840 --> 01:14:32,470
下节课

1606
01:14:33,040 --> 01:14:35,160
我要去西雅图的一些法院

1607
01:14:35,680 --> 01:14:37,390
下周将不会亲自

1608
01:14:37,400 --> 01:14:40,030
我将在YouTube上发布周一和周三的讲座

1609
01:14:40,400 --> 01:14:43,090
但我们将开球开始讨论现代医学日常系统

1610
01:14:43,730 --> 01:14:45,960
我们会读关于雪花的报纸

1611
01:14:45,970 --> 01:14:47,200
它来自雪花人

1612
01:14:48,050 --> 01:14:49,160
有一些关于雪花的细节

1613
01:14:49,170 --> 01:14:51,400
但我真的很想了解在云中的共享

1614
01:14:51,410 --> 01:14:52,840
磁盘架构上运行的大想法

1615
01:14:53,760 --> 01:14:55,230
确保你提交了你的第一次阅读

1616
01:14:56,790 --> 01:15:00,400
在星期三下午2点上课之前

1617
01:15:00,410 --> 01:15:00,760
对吗

1618
01:15:01,130 --> 01:15:01,840
我我说什么了

1619
01:15:02,180 --> 01:15:03,570
不 没有阅读评论

1620
01:15:06,050 --> 01:15:08,740
不 我说的是星期二吗

1621
01:15:09,310 --> 01:15:11,290
不 我只是有点困惑

1622
01:15:11,540 --> 01:15:13,490
确保你的第一次阅读是为了你自己

1623
01:15:13,880 --> 01:15:14,440
周一

1624
01:15:18,320 --> 01:15:18,840
太棒了伙计们

1625
01:15:19,190 --> 01:15:19,380
谢谢

1626
01:15:19,390 --> 01:15:19,820
一会儿见

1627
01:15:20,300 --> 01:15:23,050
哈 那是我最喜欢的

1628
01:15:25,690 --> 01:15:26,120
那是什么

1629
01:15:27,010 --> 01:15:28,560
这是st cricket

1630
01:15:28,570 --> 01:15:35,780
idesi弄得一团糟 除非我能像ago ice cube那样做

1631
01:15:35,790 --> 01:15:37,540
从g到e再到t杜克来了

1632
01:15:37,550 --> 01:15:38,460
我玩游戏

1633
01:15:38,470 --> 01:15:39,300
哪里没有屋顶

1634
01:15:39,310 --> 01:15:40,500
诗在监护权上

1635
01:15:40,510 --> 01:15:41,940
我专注于喝水果

1636
01:15:42,280 --> 01:15:44,830
把巴士的帽子放在眼睛上 兄弟 推

1637
01:15:44,840 --> 01:15:47,150
我们要在眼睛上打一拳

1638
01:15:48,600 --> 01:15:51,270
事实上 这是我与第五个

1639
01:15:51,280 --> 01:15:55,390
南方公园和南部中心g一起滚动 并在我聚会时感谢我们

1640
01:15:55,760 --> 01:15:58,390
通过46包上的12包箱子

1641
01:15:58,400 --> 01:16:00,310
48得到了真实的价格

1642
01:16:00,610 --> 01:16:03,480
我喝了大约12个小时的水果

1643
01:16:03,490 --> 01:16:05,480
他们说比尔会让你变胖

1644
01:16:05,490 --> 01:16:07,040
但他们说眼睛是直的

1645
01:16:07,050 --> 01:16:08,600
所以这真的没关系
