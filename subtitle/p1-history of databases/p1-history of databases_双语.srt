1
00:00:04,670 --> 00:00:05,740
Hey, yo, yo,
嘿 哟 哟

2
00:00:05,750 --> 00:00:07,540
pack the chrome sounds by like mrs. 
把铬的声音包起来 就像夫人

3
00:00:07,550 --> 00:00:09,220
Jones, liverpool mathematics.
琼斯 利物浦数学

4
00:00:09,230 --> 00:00:10,780
We have the devil spoken stone. 
我们有魔鬼说话的石头

5
00:00:10,890 --> 00:00:11,440
Up one heads, 
在我们开始搭讪的时候

6
00:00:11,450 --> 00:00:14,480
the bed make shot some little when we get started for chat up, 
床上弄了一些小镜头

7
00:00:14,490 --> 00:00:16,640
everyone can down with us this beginning. 
每个人都会和我们一起开始

8
00:00:17,200 --> 00:00:19,610
I'll get two people in new york city easy, evan,
我在纽约很容易就能抓到两个人 埃文

9
00:00:19,620 --> 00:00:23,630
and then brooklyn dva is the finest jail in seattle and they put the greek. 
然后布鲁克林的dva是西雅图最好的监狱 他们把希腊人关起来了

10
00:00:23,930 --> 00:00:26,650
These people that are helping us out and staying true to us. 
这些人帮助我们走出困境 忠于我们

11
00:00:26,660 --> 00:00:27,280
Since the beginning. 
从一开始

12
00:00:27,910 --> 00:00:30,980
I want to thank carnegie mellon for not firing me for another year. 
我要感谢卡内基梅隆大学没有再解雇我一年

13
00:00:31,310 --> 00:00:31,880
That's always important. 
这总是很重要的

14
00:00:32,680 --> 00:00:36,110
The core sponsor for this semester is going to be amazon. 
这学期的核心赞助商将是亚马逊

15
00:00:36,580 --> 00:00:41,410
Amazon is the largest database vendor in the world in terms of market cap, 
就市值而言 亚马逊是世界上最大的数据库供应商

16
00:00:41,420 --> 00:00:42,250
how much money they're making. 
他们赚了多少钱

17
00:00:42,890 --> 00:00:43,250
Right? 
对的

18
00:00:43,480 --> 00:00:45,090
They make all the money on the store, 
他们在商店上赚了所有的钱

19
00:00:45,410 --> 00:00:48,400
make a lot of money aws but they make a ton of money on databases. 
在aws上赚了很多钱 但他们在数据库上赚了很多钱

20
00:00:48,800 --> 00:00:53,170
Redshift aurora or the dynamo db they have a ton of stuff. 
红移极光或发电机DB他们有一吨的东西

21
00:00:54,600 --> 00:00:55,920
Usually oracle was number one. 
通常甲骨文是第一名

22
00:00:55,930 --> 00:00:58,160
Actually, maybe microsoft is number one for a while, too.
事实上 也许微软在一段时间内也是第一

23
00:00:58,800 --> 00:01:04,530
Amazon is officially number one as of which microsoft might be number 100, 
亚马逊（Amazon）是官方排名第一的公司 而微软（Microsoft）可能是排名第100的公司

24
00:01:04,540 --> 00:01:05,770
whatever they're making a ton of money. 
不管他们赚了多少钱

25
00:01:07,290 --> 00:01:10,190
Anyway, they're helping us with the course logistics and sponsor goes.
不管怎样 他们正在帮助我们安排课程的后勤工作 赞助商也去了

26
00:01:11,850 --> 00:01:12,840
We're really appreciative of that. 
我们对此非常感激

27
00:01:13,200 --> 00:01:14,240
And then the end of the semester, 
然后到了学期末

28
00:01:15,800 --> 00:01:18,480
somebody will come give from the redshift team come and give a tech talk
红移团队的人会来做一个关于他们正在建造的

29
00:01:18,490 --> 00:01:19,640
about the system that they're building. 
系统的技术演讲

30
00:01:19,650 --> 00:01:21,920
We will discuss redshift throughout the semester. 
我们将在整个学期中讨论红移

31
00:01:23,360 --> 00:01:25,550
A lot of the techniques that will describe during the semester
很多技术将在学期中描述

32
00:01:26,230 --> 00:01:28,580
they're actually implementing in their system. 
他们实际上在他们的系统中实施

33
00:01:30,280 --> 00:01:33,470
I quickly want to go over the course logistics and what the expected
我很快就想回顾一下课程的逻辑和本学期的预期

34
00:01:33,480 --> 00:01:34,030
for the semester, 
但我肯定

35
00:01:34,040 --> 00:01:36,350
but I must have had most of the time on the history of databases, 
花了大部分时间在数据库的历史上

36
00:01:36,360 --> 00:01:37,930
because I find that part more interesting. 
因为我觉得这部分更有趣

37
00:01:37,940 --> 00:01:40,680
And then as I sent the email out over the weekend, 
然后当我在周末发出电子邮件时

38
00:01:41,430 --> 00:01:42,940
it would be based on the two readings. 
它将基于两个读数

39
00:01:44,250 --> 00:01:48,530
Again, it's not meant to be like deep into the internal of data systems.
同样 它并不意味着要深入到数据系统的内部

40
00:01:48,910 --> 00:01:51,330
Just to give you perspective of what the landscape looks like, 
只是为了让您了解前景是什么样子的

41
00:01:51,630 --> 00:01:53,160
why we're spending all the time talking
为什么我们一直在讨论关系数据库

42
00:01:53,170 --> 00:01:55,000
about relational databases and not other things. 
而不是其他东西

43
00:01:56,450 --> 00:01:59,370
So a lot of you guys are here for obvious reasons you want to take this course. 
所以你们中的很多人来这里的原因很明显 你们想上这门课

44
00:02:00,200 --> 00:02:01,470
But just as the final pitch, 
但就像最后的演讲一样

45
00:02:01,480 --> 00:02:07,070
i'll say the things that we talk about this semester for database systems
我要说的是我们这学期讨论的数据库系统

46
00:02:07,080 --> 00:02:08,950
and particularly for analytical database systems, 
特别是分析数据库系统

47
00:02:10,050 --> 00:02:12,120
these are hard problems not ever can do it. 
这些都是永远做不到的难题

48
00:02:12,680 --> 00:02:15,910
And companies pay a lot of money for students, 
公司为学生支付了很多钱

49
00:02:16,420 --> 00:02:19,790
not coming to this class from other places as well that have experience
而不是从其他地方来上这门课

50
00:02:19,800 --> 00:02:20,830
in working database systems. 
因为他们有数据库系统的工作经验

51
00:02:22,550 --> 00:02:24,180
If you're just a random javascript programmer, 
如果你只是一个随机的JavaScript程序员

52
00:02:25,030 --> 00:02:27,070
they're not going to be touching davis and turtles same way. 
他们不会以同样的方式接触Davis和Turtles

53
00:02:27,080 --> 00:02:30,030
They're not going to be touching the kernel in an operating system, right?
他们不会触及操作系统的内核 对吗

54
00:02:30,360 --> 00:02:32,220
They don't want people off the street. 
他们不想让人们离开这条街

55
00:02:32,230 --> 00:02:35,350
They want people to understand fundamentally how these systems are working. 
他们希望人们从根本上了解这些系统是如何工作的

56
00:02:35,720 --> 00:02:37,130
These are the things that we're going to cover. 
这些就是我们要讲的内容

57
00:02:38,200 --> 00:02:39,740
This is not the full list, 
这不是完整的名单

58
00:02:39,750 --> 00:02:42,700
but these are just some of the former students that have worked with us
但这些只是一些以前和我们一起上这门课的学生

59
00:02:43,410 --> 00:02:46,000
in taking this class and places that they've gone. 
以及他们去过的地方

60
00:02:47,580 --> 00:02:50,540
These are the ones I have photos a there's way more than i'm missing, 
这些是我有照片的 比我错过的要多得多

61
00:02:51,720 --> 00:02:53,370
but these are the ones that I I could quickly find. 
但这些是我能很快找到的

62
00:02:54,730 --> 00:02:56,810
Three of them are with me at my startup at autogen, 
他们中的三个和我一起在我的创业公司AutoGen工作

63
00:02:57,280 --> 00:02:58,390
some of the best ones as well. 
其中一些也是最好的

64
00:02:59,380 --> 00:02:59,590
All right. 
好吧

65
00:02:59,600 --> 00:03:03,410
So the unlike in previous years where you try to cover
所以不像前几年

66
00:03:03,420 --> 00:03:05,050
maybe in memory database systems, 
你可能会在内存中讨论数据库系统

67
00:03:05,550 --> 00:03:08,640
and spend a little time discussing transaction systems, 
并花一点时间讨论事务系统

68
00:03:09,940 --> 00:03:13,690
this semester, we're only going to focus on analytical database systems,
这学期 我们将只关注分析型数据库系统

69
00:03:15,580 --> 00:03:18,160
just because this is sort of what the hot thing is right now. 
只是因为这是现在最热门的事情

70
00:03:18,490 --> 00:03:21,010
And there's a lot of money sloshing around a lot of systems being built. 
有大量的资金在许多正在建设的系统中流动

71
00:03:21,980 --> 00:03:24,770
And to sort of understand we want to understand what the state of the art
为了理解 我们想要了解艺术的现状

72
00:03:24,780 --> 00:03:27,090
is and how we got to the point where we are today. 
以及我们是如何走到今天这一步的

73
00:03:28,120 --> 00:03:30,750
The goal for you guys is that not only we become aware of what
你们的目标是

74
00:03:30,760 --> 00:03:31,830
these systems actually are. 
我们不仅要了解这些系统实际上是什么

75
00:03:32,130 --> 00:03:35,030
What are the key features about them and help you to sort of understand
它们的关键特性是什么 它们可以帮助您了解一种

76
00:03:35,040 --> 00:03:37,900
the trade offs between one system design or implementation versus
系统设计或实现与另一种系统设计或实现之间的

77
00:03:37,910 --> 00:03:38,420
another? 
权衡

78
00:03:39,460 --> 00:03:42,730
You'll hopefully also become proficient in writing high quality systems code, 
希望你也能熟练地编写高质量的系统代码

79
00:03:43,120 --> 00:03:43,260
right? 
对吗

80
00:03:43,270 --> 00:03:45,300
Doing documentation and testing and doing code reviews. 
做文档和测试 做代码审查

81
00:03:45,560 --> 00:03:45,580
Right? 
对的

82
00:03:45,590 --> 00:03:48,580
These are soft skills that can be important when you go out in the real world, 
这些都是软技能 当你在现实世界中进行新

83
00:03:48,590 --> 00:03:49,540
new systems development, 
系统开发时

84
00:03:49,940 --> 00:03:52,630
that it's not something like there's any class to say, 
这些技能可能很重要 这不像任何课程所说的

85
00:03:52,640 --> 00:03:53,730
here's how to write documentation. 
这是如何编写文档

86
00:03:54,080 --> 00:03:55,020
Here's how to write test code. 
下面是如何编写测试代码

87
00:03:55,550 --> 00:03:57,840
It's just things you sort of have to pick up as you go along. 
这只是你在前进的过程中必须学会的东西

88
00:03:58,200 --> 00:04:00,830
The projects will be designed such that you'll get exposure to these sort
这些项目将被设计成这样

89
00:04:00,840 --> 00:04:04,140
of best practices on how to do these to work on data systems. 
你将接触到这些关于如何在数据系统上工作的最佳实践

90
00:04:05,450 --> 00:04:07,820
This course, also, too, is only going to cover state of the art topics.
本课程也只会涵盖最先进的主题

91
00:04:08,360 --> 00:04:10,030
I'm assuming everyone has taken a database class, 
我假设每个人都上过数据库课程

92
00:04:10,040 --> 00:04:12,130
either last semester or four forty five six, 45.
要么是上学期 要么是四四五六 45

93
00:04:12,560 --> 00:04:13,080
What you're undergrad like, 
你是个大学生

94
00:04:13,090 --> 00:04:16,080
we're not going to go over to the basic of what a join is, right?
我们不会讨论什么是联合的基础知识 对吧

95
00:04:16,580 --> 00:04:16,910
Talk, 
说起来

96
00:04:17,480 --> 00:04:18,990
we assume how to do a hash join. 
我们假设如何进行哈希连接

97
00:04:19,380 --> 00:04:21,850
We'll talk about how to do it parallel and do it, make it run fast.
我们将讨论如何并行地做 让它运行得更快

98
00:04:23,850 --> 00:04:25,000
The topics that we're going to cover. 
我们将要讨论的主题

99
00:04:26,140 --> 00:04:28,690
First start off talking about storage models and compression. 
首先 开始讨论存储模型和压缩

100
00:04:28,700 --> 00:04:32,780
And actually, how do you represent data in files on disk?
实际上 如何表示磁盘上文件中的数据

101
00:04:33,240 --> 00:04:35,930
Then we'll talk about how to do query execution using sort
然后

102
00:04:35,940 --> 00:04:38,450
of modern techniques like vectorization and compilation. 
我们将讨论如何使用向量化和编译等现代技术来执行查询

103
00:04:38,850 --> 00:04:40,890
Then we'll talk about modern join algorithms. 
然后 我们将讨论现代连接算法

104
00:04:41,520 --> 00:04:45,110
Networking protocols are getting things out of the data in and out of the database. 
网络协议将数据中的内容输入和输出数据库

105
00:04:45,550 --> 00:04:47,910
Then we'll spend a little time talking about how to do query optimization, 
然后 我们将花一点时间讨论如何进行查询优化

106
00:04:48,700 --> 00:04:51,400
go much deeper than we were able to cover in the inter class. 
这比我们在inter类中讨论的要深入得多

107
00:04:51,920 --> 00:04:52,910
If you look at the schedule, 
如果你看一下时间表

108
00:04:52,920 --> 00:04:57,810
the last four or five lectures are actually targeting single database systems. 
最后四到五节课实际上是针对单一数据库系统的

109
00:04:58,420 --> 00:05:00,520
There's a whole lecture on snowflake, a whole lecture on data bricks,
有一个关于雪花的讲座

110
00:05:00,530 --> 00:05:03,990
a whole lecture on big query of drama. 
一个关于数据砖块的讲座 一个关于戏剧大查询的讲座

111
00:05:04,480 --> 00:05:07,070
The idea is that we want to take all the things we discussed
我的想法是

112
00:05:07,080 --> 00:05:07,950
throughout the semester, 
我们想把我们整个学期讨论的所有事情

113
00:05:09,470 --> 00:05:10,460
understand the basics of them, 
了解它们的基础知识

114
00:05:10,470 --> 00:05:13,060
and then look at a real system that implements all these things. 
然后看看实现所有这些功能的真实系统

115
00:05:13,520 --> 00:05:16,120
And try to understand like, why are they doing this a certain way?
试着去理解 他们为什么要以某种方式做这件事

116
00:05:16,130 --> 00:05:17,960
Or what are the benefits? 
或者有什么好处

117
00:05:17,970 --> 00:05:20,840
Or what are the disadvantages of the approaches that they're taking? 
或者他们所采取的方法的缺点是什么

118
00:05:25,840 --> 00:05:29,600
Again, i'm assuming you've taken an intro davis class.
再说一次 我假设你上过戴维斯的入门课程

119
00:05:30,080 --> 00:05:33,530
We're not going to cover sort of the basics of sql and other things. 
我们不打算介绍SQL的基础知识和其他内容

120
00:05:35,130 --> 00:05:37,330
So all the website is up to date. 
所有的网站都是最新的

121
00:05:37,340 --> 00:05:40,310
I I haven't updated the homepage because I try to get, 
我还没有更新主页

122
00:05:41,070 --> 00:05:46,170
I try to use dolly to have like the last supper and in the middle, 
因为我试着 我试着用多莉来做最后的晚餐 在中间

123
00:05:47,050 --> 00:05:48,520
it didn't work out very well. 
效果不是很好

124
00:05:48,810 --> 00:05:49,890
I've got to work on it anyway. 
不管怎样 我得继续努力

125
00:05:49,900 --> 00:05:51,490
So the website is up to date. 
所以网站是最新的

126
00:05:51,500 --> 00:05:54,070
So the syllabus and the schedule is all there. 
所以教学大纲和时间表都在那里

127
00:05:54,510 --> 00:05:56,530
For the most part, it's stable.
在大多数情况下 它是稳定的

128
00:05:57,570 --> 00:06:00,040
So if you understand what's expected for you in the course, 
所以 如果你明白这门课对你的期望

129
00:06:00,050 --> 00:06:00,960
please go look at that. 
请去看看

130
00:06:01,590 --> 00:06:04,580
I'll say this throughout a couple of times in the beginning, right?
我会在开始的时候说几次 对吗

131
00:06:05,090 --> 00:06:06,200
For academic honesty, 
对于学术诚信

132
00:06:06,430 --> 00:06:08,200
again, this is the advanced level class.
再次强调 这是高级水平课程

133
00:06:08,210 --> 00:06:09,640
I assume everyone here is smart. 
我想这里的每个人都很聪明

134
00:06:09,990 --> 00:06:11,010
Therefore, you don't need to cheat.
因此 你不需要作弊

135
00:06:11,350 --> 00:06:15,570
If you do cheat, we will take you over to warner hall and deal with that.
如果你作弊 我们会把你带到华纳大厅去处理

136
00:06:17,470 --> 00:06:18,130
If you went in doubt, 
如果你有疑问

137
00:06:18,140 --> 00:06:19,690
if you're not sure about doing something like I have
如果你不确定是否要做一些事情

138
00:06:19,700 --> 00:06:21,450
this little stupid code that somebody wrote in get hub, 
比如我有一个人在Get Hub中编写的愚蠢的代码

139
00:06:21,460 --> 00:06:22,570
can I use it in my project? 
我可以在我的项目中使用它吗

140
00:06:22,580 --> 00:06:23,980
If you're not sure, 
如果你不确定

141
00:06:24,320 --> 00:06:31,120
then just ask myself at the ta my office hours to be mondays and wednesdays, 
那就在助教那里问问我自己 我的办公时间是周一和周三

142
00:06:31,170 --> 00:06:32,520
the hour before class, 
上课前的一小时

143
00:06:32,960 --> 00:06:34,160
upstairs on the line floor. 
在楼上的一层

144
00:06:34,530 --> 00:06:35,790
And then we can talk about anything you want, 
然后我们可以谈论任何你想要的东西

145
00:06:35,800 --> 00:06:37,510
any of the projects and papers. 
任何项目和论文

146
00:06:37,920 --> 00:06:38,800
How to get a database job? 
如何获取数据库作业

147
00:06:38,810 --> 00:06:39,920
I have a bunch of database shirts. 
我有一堆数据库衬衫

148
00:06:39,930 --> 00:06:41,200
My office, the company send me.
我的办公室 公司派我来的

149
00:06:41,590 --> 00:06:43,370
Please come and get some, 
请来买一些

150
00:06:43,750 --> 00:06:46,060
because i'm kind of getting a little hoarder level because they send
因为我有点囤积症

151
00:06:46,070 --> 00:06:47,220
a bunch of me during the pandemic. 
因为他们在流感大流行期间给我送来了一堆

152
00:06:47,230 --> 00:06:48,340
I have a bunch of boxes. 
我有一堆盒子

153
00:06:48,350 --> 00:06:49,620
I've got to start getting rid of them. 
我得开始摆脱他们了

154
00:06:49,630 --> 00:06:51,070
So come and talk to me. 
所以来和我谈谈

155
00:06:52,010 --> 00:06:54,910
We have one ta when he's awesome. 
我们有一个助教 当他很棒的时候

156
00:06:55,690 --> 00:06:57,280
So he's my third year ph student. 
他是我三年级的博士生

157
00:06:57,620 --> 00:06:58,300
This is true. 
这是真的

158
00:06:58,310 --> 00:07:00,830
He is a former paralegal for like the sketchy law firm. 
他以前是Sketchy律师事务所的律师助理

159
00:07:01,050 --> 00:07:02,510
He is a certified chicken farmer. 
他是一名持证养鸡户

160
00:07:03,230 --> 00:07:06,740
He is the number of ranked phd student at carnegie mellon for data
他是卡内基梅隆大学排名第一的博士生

161
00:07:06,750 --> 00:07:08,060
for databases to be very clear. 
因为数据库的数据非常清晰

162
00:07:08,460 --> 00:07:10,500
So, again, he'll help me with the projects.
所以 再说一次 他会帮我做项目

163
00:07:10,510 --> 00:07:12,940
He'll be a part of the conversations as we go along the semester. 
他将成为我们这学期谈话的一部分

164
00:07:14,280 --> 00:07:15,630
So by all means, leverage him.
所以一定要利用他

165
00:07:15,640 --> 00:07:16,270
If you have questions. 
如果你有问题

166
00:07:18,420 --> 00:07:20,530
The expectations are 33 things. 
期望是33件事

167
00:07:20,540 --> 00:07:22,730
There's reading assignments, projects, and the final exam.
有阅读作业 项目和期末考试

168
00:07:23,710 --> 00:07:25,350
Every class will have one assigned reading, 
除了今天的课

169
00:07:25,360 --> 00:07:26,430
except for today's class. 
每节课都会有一篇指定阅读

170
00:07:26,820 --> 00:07:29,190
And they'll be indicated by the icon here. 
它们将由此处的图标指示

171
00:07:30,490 --> 00:07:37,990
I'll post on piazza what's actually expected in in these in these reading reviews. 
我将在Piazza上发布这些阅读评论中真正期待的内容

172
00:07:38,000 --> 00:07:41,520
But the main ideas ii want you to get out of is like, read the paper,
但我想让你们了解的主要想法是

173
00:07:41,530 --> 00:07:42,400
understand what they're doing, 
阅读论文 理解他们在做什么

174
00:07:43,180 --> 00:07:45,120
understand all the things that we talked about, 
理解我们讨论的所有事情

175
00:07:45,350 --> 00:07:47,230
how to put, how would it fit together in a higher system,
如何把它放在一个更高的系统中

176
00:07:47,240 --> 00:07:48,630
a higher level system. 
一个更高层次的系统中

177
00:07:48,640 --> 00:07:48,750
Then. 
然后

178
00:07:49,440 --> 00:07:49,930
I'm also curious. 
我也很好奇

179
00:07:49,940 --> 00:07:52,450
I don't understand what are the workloads that you to evaluate
我不明白您要评估

180
00:07:52,460 --> 00:07:56,620
the the implementation for analytical databases. 
分析数据库实施的工作负载是什么

181
00:07:56,630 --> 00:07:59,620
It's most likely going to be tpch and tpcds over and over again. 
最有可能的是一次又一次的TPCH和TPCD

182
00:08:00,040 --> 00:08:01,500
It's good just to know what these things are, 
知道这些东西是什么是很好的

183
00:08:01,510 --> 00:08:05,470
so that when we go into project one, project two, actually, or project three,
这样当我们进入项目一

184
00:08:05,840 --> 00:08:08,150
you'll have an idea of what workloads you can use based
项目二或项目三时

185
00:08:08,160 --> 00:08:08,950
on the papers you've read. 
你就会根据你读过的论文知道你可以使用哪些工作负载

186
00:08:09,590 --> 00:08:11,350
And there's a google form here that is live, 
这里有一个实时的谷歌表单

187
00:08:11,360 --> 00:08:12,550
and then there will be a drop down. 
然后会有一个下拉菜单

188
00:08:12,560 --> 00:08:13,110
You fill that out. 
你把它填好

189
00:08:13,120 --> 00:08:13,510
Yes? 
是的

190
00:08:15,600 --> 00:08:16,230
It should be three. 
应该是三个

191
00:08:16,510 --> 00:08:17,460
You can skip three readings. 
你可以跳过三次阅读

192
00:08:17,770 --> 00:08:18,500
Sorry, i'll fix that.
对不起 我会解决的

193
00:08:18,990 --> 00:08:19,280
Thank you. 
谢谢

194
00:08:20,210 --> 00:08:23,220
Again, all these reviews have to be your own writing.
再次 所有这些评论都必须是你自己写的

195
00:08:23,950 --> 00:08:25,060
Some of these papers are pretty stated. 
有些论文写得很好

196
00:08:25,070 --> 00:08:26,220
They are like they came out last week, 
他们就像上周出来的一样

197
00:08:26,230 --> 00:08:28,260
and so they're probably not going to be a review on the internet. 
所以他们可能不会在互联网上发表评论

198
00:08:28,270 --> 00:08:28,860
You can use. 
你可以用

199
00:08:31,220 --> 00:08:33,140
You could try chat gpt see what happens. 
你可以试试聊天GPT 看看会发生什么

200
00:08:37,260 --> 00:08:39,010
Project one, we'll post next week.
项目一 我们将在下周发布

201
00:08:39,320 --> 00:08:42,090
But you'd be basically writing a foreign data wrapper for post graphs, 
但你基本上要为后图 过程

202
00:08:42,600 --> 00:08:44,910
process, columnar data format, like a parquet file.
柱状数据格式编写一个外来数据包装器 就像一个镶木文件

203
00:08:45,200 --> 00:08:49,030
The idea here is just to expose you to how to do vectors execution
这里的想法只是向您展示如何在post图的上下文

204
00:08:49,570 --> 00:08:50,710
in the context of post graphs. 
中执行向量

205
00:08:50,720 --> 00:08:52,230
So we don't worry about do sql parsing. 
所以我们不用担心做SQL解析

206
00:08:52,240 --> 00:08:53,970
We don't worry about doing query planning. 
我们不用担心进行查询计划

207
00:08:53,980 --> 00:08:55,330
Let postcards handle all that. 
让明信片来处理这一切

208
00:08:55,750 --> 00:08:58,880
And the idea here would be that you'd be able to trade see the tradeoffs
这里的想法是 你可以在列上的

209
00:08:58,890 --> 00:09:01,520
between your sort of custom engine on the column and our data
自定义引擎和我们的数据与后

210
00:09:01,530 --> 00:09:03,200
versus post stresses, 
压力之间进行权衡

211
00:09:03,210 --> 00:09:05,000
row based iterator model. 
基于行的迭代器模型

212
00:09:05,890 --> 00:09:07,170
Again, what i'm saying, does it make sense?
再说一次 我说的有意义吗

213
00:09:07,180 --> 00:09:10,530
Then that's not good because we cover these things in the interclass, 
那就不好了 因为我们在课堂上讨论了这些东西

214
00:09:11,320 --> 00:09:14,670
but make sure at least go back and look at them and understand what
但至少要确保回去看看它们

215
00:09:14,680 --> 00:09:15,230
i'm talking about. 
并理解我在说什么

216
00:09:15,920 --> 00:09:17,120
Again, we'll post this next week.
同样 我们将在下周发布这篇文章

217
00:09:17,800 --> 00:09:21,360
Project two is going to be writing an article for encyclopedia, 
项目二将为百科全书写一篇文章

218
00:09:21,810 --> 00:09:23,300
so we have an encyclopedia of databases. 
所以我们有一个数据库百科全书

219
00:09:23,310 --> 00:09:26,760
So every single database that i'm aware of the idea would be, 
因此 我所知道的每一个数据库的想法都是

220
00:09:26,770 --> 00:09:28,640
you go look at the documentation, go read,
你去看看文档 去阅读

221
00:09:28,650 --> 00:09:29,760
maybe even run these systems, 
甚至可能运行这些系统

222
00:09:29,770 --> 00:09:30,880
go talk to the developers, 
去与开发人员交谈

223
00:09:31,230 --> 00:09:34,310
understand how they're implementing these different parts of the system
了解他们如何实现我们所关心的系统的这些

224
00:09:34,320 --> 00:09:35,270
that we care about. 
不同部分

225
00:09:35,770 --> 00:09:38,080
And you'll be writing article for this. 
你将为此写一篇文章

226
00:09:38,090 --> 00:09:38,640
Ok? 
好吧

227
00:09:39,380 --> 00:09:40,490
Don't plagiarize with this, 
不要抄袭

228
00:09:40,540 --> 00:09:42,530
avoid marketing language. 
避免使用营销语言

229
00:09:43,020 --> 00:09:45,130
Sometimes I give the company's access to the website, 
有时我让公司访问网站

230
00:09:45,430 --> 00:09:49,080
and they'll say, like my database is the fastest whatever, right?
他们会说 我的数据库是最快的 对吗

231
00:09:49,090 --> 00:09:50,040
And we have to remove all that. 
我们必须把这些都去掉

232
00:09:51,150 --> 00:09:53,650
Only say things that you can back up by specific claims. 
只说那些你可以用具体的声明来支持的事情

233
00:09:54,970 --> 00:09:55,080
Right? 
对的

234
00:09:55,290 --> 00:09:57,910
We more care about the internal and not like how people feel
我们更关心内部 而不是人们对数据库的感觉

235
00:09:57,920 --> 00:09:59,230
about the database if that makes sense. 
如果这是有意义的话

236
00:10:01,090 --> 00:10:02,760
Project three will be a group project. 
项目三将是小组项目

237
00:10:03,010 --> 00:10:07,890
And the idea here would be some larger topic that you're interested in. 
这里的想法是一些你感兴趣的更大的主题

238
00:10:07,900 --> 00:10:09,990
That's based on the things we're discussing throughout the semester. 
这是基于我们整个学期所讨论的事情

239
00:10:10,460 --> 00:10:12,430
It doesn't have to be in postgres, but if you want,
它不一定要在postgres 但如果你想

240
00:10:12,980 --> 00:10:13,510
it can be. 
它可以

241
00:10:14,870 --> 00:10:18,840
The idea here is that you just want to build something that exhibits
这里的想法是

242
00:10:18,850 --> 00:10:22,250
some understanding of mastery of the materials we discussed
你只是想建立一些东西

243
00:10:22,260 --> 00:10:22,970
throughout those masters. 
展示对我们在这些大师中讨论的材料的掌握的一些理解

244
00:10:24,690 --> 00:10:27,010
Again, i'll post some topics as we get closer.
再一次 当我们接近的时候 我会发布一些主题

245
00:10:27,020 --> 00:10:28,370
You want to decide later until march. 
你想晚些时候决定 直到三月

246
00:10:28,380 --> 00:10:29,490
What do you exactly want to do? 
你到底想做什么

247
00:10:30,990 --> 00:10:32,390
I have some ideas of things that I want to do. 
我对我想做的事情有一些想法

248
00:10:32,400 --> 00:10:34,110
That could potentially turn into a short paper, 
这可能会变成一篇简短的论文

249
00:10:34,600 --> 00:10:35,770
or like a capturing project. 
或者像一个捕捉项目

250
00:10:36,180 --> 00:10:38,210
Again, we can discuss these as we go along.
同样 我们可以边走边讨论

251
00:10:39,410 --> 00:10:40,610
Again, don't plagiarize.
再说一次 不要抄袭

252
00:10:40,620 --> 00:10:43,130
And all your code has to be your code you submit to us has to be
你所有的代码都必须是你提交给我们的代码 必须是你的

253
00:10:43,140 --> 00:10:47,800
yours unless you discuss and attributed same thing for the encyclopedia. 
除非你在百科全书中讨论并引用了同样的东西

254
00:10:47,810 --> 00:10:53,260
Please don't just copy from the from random things on internet. 
请不要只是从互联网上随机复制的东西

255
00:10:53,270 --> 00:10:55,980
1 year somebody copied from wiki pda and they had like a little
一年前 有人从维基掌上电脑复制

256
00:10:55,990 --> 00:10:58,920
like there's the text and then the square bracket and then the number
他们有一些类似的文字 然后是方括号

257
00:10:58,930 --> 00:10:59,550
for the citation. 
然后是引用的数字

258
00:10:59,560 --> 00:11:04,010
So we had to go deal with that again. 
所以我们不得不再次处理这件事

259
00:11:04,220 --> 00:11:07,030
So the reason why i'm keep showing this because this is on video now. 
所以我一直在展示这个的原因是因为这个现在在视频上

260
00:11:07,320 --> 00:11:09,270
Because then if you guys do plagiarize, 
因为如果你们真的剽窃了

261
00:11:09,770 --> 00:11:11,330
and then I go to turn you in. 
我就去告发你们

262
00:11:11,340 --> 00:11:15,470
I show them the video link on youtube, or like, here's me discussing this.
我给他们看YouTube上的视频链接 或者说 我在这里讨论这个

263
00:11:16,030 --> 00:11:16,680
And you're screwed. 
你完蛋了

264
00:11:18,430 --> 00:11:20,220
There'll be a final exam, but it'll be take home.
将会有一次期末考试 但它会被带回家

265
00:11:20,490 --> 00:11:21,310
Long form questions. 
长格式问题

266
00:11:21,320 --> 00:11:24,150
I did try chat gbt and it was not able to answer them. 
我试着和GBT聊天 但它无法回答他们

267
00:11:25,420 --> 00:11:29,010
So who knows whether how much better that will get? 
所以谁知道会有多好呢

268
00:11:29,020 --> 00:11:30,410
So it's either that like, 
所以要么是喜欢

269
00:11:31,730 --> 00:11:35,610
I wonder if it's a limitation of chat gbt or whether my questions are just terrible. 
我想知道这是否是聊天GBT的限制 或者我的问题是否很糟糕

270
00:11:36,200 --> 00:11:41,080
And it can't parse them acting with you is like really bad at like kind
它不能解析它们 和你一起表演真的很糟糕

271
00:11:41,090 --> 00:11:43,240
of like specialized questions like you can answer
就像你可以很好地回答基本的计算机科学问题

272
00:11:43,250 --> 00:11:44,920
basic computer science questions really well, 
但一旦你和专家打交道

273
00:11:44,930 --> 00:11:48,570
but once you dealt with the specialist you kind of like drops the ball
你就会掉链子 但很糟糕

274
00:11:48,580 --> 00:11:50,570
but like terribly but it phrases an amber. 
但它说的是琥珀

275
00:11:50,580 --> 00:11:51,530
So you think it's right, 
所以你认为这是正确的

276
00:11:51,620 --> 00:11:54,090
it's like multi version current control is important because it
就像多版本当前控制很重要

277
00:11:54,100 --> 00:11:55,370
does multiversioning like thanks. 
因为它像Thanks一样进行多版本控制

278
00:11:56,220 --> 00:11:57,710
That's what it told me. 
这就是它告诉我的

279
00:11:59,860 --> 00:11:59,970
Right? 
对的

280
00:11:59,980 --> 00:12:01,170
Grey breakdown is like this. 
灰色分解是这样的

281
00:12:01,180 --> 00:12:02,330
Again, this is on the syllabus,
同样 这是在教学大纲上

282
00:12:03,340 --> 00:12:04,650
no big surprises here. 
这里没有太大的惊喜

283
00:12:05,050 --> 00:12:07,140
And then the chorus mailing list, everything will be on piazza.
然后是合唱团的邮件列表 所有的东西都会在广场上

284
00:12:07,150 --> 00:12:09,760
If you have any technical questions as about project
如果你有任何关于项目一和潜在项目三的技术问题

285
00:12:09,770 --> 00:12:11,490
one and potentially project three, 
在我们进行的

286
00:12:11,500 --> 00:12:12,570
as we go along. 
过程中

287
00:12:13,430 --> 00:12:14,540
Please post on piazza. 
请在广场上发帖

288
00:12:14,550 --> 00:12:16,580
Don't email one of myself directly. 
不要直接给自己发电子邮件

289
00:12:17,230 --> 00:12:19,910
And if anything else like your health issues, 
如果你有任何健康问题

290
00:12:19,920 --> 00:12:21,260
whatever you have going on, 
无论你有什么问题

291
00:12:21,810 --> 00:12:22,540
please email directly. 
请直接发电子邮件

292
00:12:24,040 --> 00:12:24,750
Any questions about this? 
对此有什么问题吗

293
00:12:27,770 --> 00:12:28,840
Let's get to this databases. 
让我们来看看这个数据库

294
00:12:30,080 --> 00:12:30,090
Yeah. 
是啊

295
00:12:30,100 --> 00:12:31,480
1 year somebody complained on youtube. 
一年前有人在YouTube上抱怨

296
00:12:31,490 --> 00:12:34,320
I you spent 25 minutes discussing logistics of the course, 
如果你花了25分钟讨论课程的后勤工作

297
00:12:34,330 --> 00:12:35,160
get to the good stuff. 
那就是好东西

298
00:12:35,170 --> 00:12:36,460
So here we are. 
所以我们在这里

299
00:12:37,300 --> 00:12:38,010
As I said, 
正如我所说

300
00:12:38,540 --> 00:12:41,060
this is sort of my bridge history of the last 50, 
这是我过去50

301
00:12:41,070 --> 00:12:42,260
60 years of databases. 
60年数据库的桥梁历史

302
00:12:43,090 --> 00:12:45,040
So we're not going to go too deep into any one topic, 
因此 我们不会深入讨论任何一个主题

303
00:12:45,050 --> 00:12:50,240
but it's a going to an overview of the lay of the land that like, 
但我们将对这一领域进行概述

304
00:12:50,790 --> 00:12:54,610
I think what's actually really interesting about this is that databases are
我认为真正有趣的是

305
00:12:54,620 --> 00:12:59,520
a hot area right now in both research and in in industry. 
数据库目前在研究和行业中都是一个热门领域

306
00:12:59,530 --> 00:13:02,280
And yet they're 60 years old. 
但他们已经60岁了

307
00:13:02,290 --> 00:13:04,240
First one is going to be from the 1960s. 
第一个是20世纪60年代的

308
00:13:05,330 --> 00:13:05,750
Right? 
对的

309
00:13:06,070 --> 00:13:09,040
It just shows you how important they are and how hard the problem is. 
它只是告诉你它们有多重要 问题有多难

310
00:13:09,050 --> 00:13:09,480
If like, 
如果喜欢

311
00:13:10,090 --> 00:13:12,280
it's clearly not a solved problem. 
这显然不是一个解决的问题

312
00:13:13,560 --> 00:13:16,950
It's gonna this lecture sort of derived from two papers. 
这节课是从两篇论文中衍生出来的

313
00:13:16,960 --> 00:13:19,740
The first one was called what goes around comes around and is written
第一本书名为《What Goes Around Comes Around》

314
00:13:19,750 --> 00:13:23,180
by mike stern bakker and joe hellers stein in 2006. 
由迈克·斯特恩·巴克（Mike Stern Bakker）和乔·海勒斯·斯坦（Joe Heller Stein）于2006年撰写

315
00:13:23,740 --> 00:13:31,700
And it's basically mikes assessment of the database industry and how he
这基本上是迈克对数据库行业的评价

316
00:13:31,710 --> 00:13:33,780
was right for the last 40 years. 
以及他在过去40年里是如何正确的

317
00:13:34,800 --> 00:13:36,390
Mike won the touring award in 2014, 
迈克在2014年赢得了巡回演出奖

318
00:13:36,400 --> 00:13:38,630
so I would agree with him. 
所以我同意他的观点

319
00:13:38,960 --> 00:13:40,850
Then the paper, this other one draft I sent you.
然后是论文 我寄给你的另一份草稿

320
00:13:40,860 --> 00:13:41,420
This is mike. 
这是迈克

321
00:13:41,430 --> 00:13:46,950
And I wrote this last year where we basically looked at where this paper
我去年写了这篇文章 我们基本上是从这篇论文停止的地方开始的

322
00:13:46,960 --> 00:13:49,750
left off and said what's the next sixteen seventeen years
然后说接下来的16年和17年是什么

323
00:13:50,110 --> 00:13:51,430
And this was actually triggered by me, 
这实际上是由我引发的

324
00:13:51,800 --> 00:13:54,350
because there was some like postman hacker news or somebody's like, 
因为有一些像邮差黑客新闻之类的人

325
00:13:54,360 --> 00:13:56,560
I don't know why people keep using relational databases. 
我不知道为什么人们一直在使用关系数据库

326
00:13:56,570 --> 00:13:57,760
Graph database is the way to go. 
图形数据库是一条可行之路

327
00:13:57,770 --> 00:13:59,160
And I was like, all right,
我想 好吧

328
00:13:59,250 --> 00:14:01,400
I said that the mic, let's write the new ones.
我说麦克风 让我们写新的

329
00:14:05,450 --> 00:14:06,120
The major take away. 
主要带走

330
00:14:06,130 --> 00:14:08,880
What you guys get from this is that again, 
你们从这里得到的是

331
00:14:08,890 --> 00:14:10,480
even though databases are really old, 
即使数据库真的很老

332
00:14:10,490 --> 00:14:11,800
the concept is really old. 
这个概念也很老

333
00:14:12,190 --> 00:14:14,080
They are highly relevant today, 
它们在今天是高度相关的

334
00:14:14,090 --> 00:14:16,690
because the other day, every application,
因为前几天 每个应用程序

335
00:14:17,200 --> 00:14:18,070
what are they essentially doing? 
它们本质上在做什么

336
00:14:19,380 --> 00:14:19,450
Right? 
对的

337
00:14:20,060 --> 00:14:24,270
They're exposing some user interface for for either a human
它们为人类或另一台机器或与数据库

338
00:14:24,280 --> 00:14:27,910
or another machine or something to interact with a database. 
交互的东西公开了一些用户界面

339
00:14:29,370 --> 00:14:29,830
Right? 
对的

340
00:14:30,850 --> 00:14:34,600
What's going to be interesting is a lot of the things that will cover this semester. 
有趣的是这学期要讲的很多东西

341
00:14:34,940 --> 00:14:36,180
These are not new ideas. 
这些都不是新的想法

342
00:14:36,190 --> 00:14:37,380
They're not new concepts. 
它们不是新概念

343
00:14:37,950 --> 00:14:39,430
I'm going to see, I said this in andrew class.
我要去看看 我在安德鲁的课上说过

344
00:14:39,440 --> 00:14:42,470
I'll keep saying this over and over again throughout the semester. 
我会在整个学期里一遍又一遍地说这句话

345
00:14:42,820 --> 00:14:45,630
Ibm did a lot of this stuff in the 1970s. 
IBM在20世纪70年代做了很多这样的事情

346
00:14:46,500 --> 00:14:48,340
Just obviously, the harbor was much different.
很明显 港口很不一样

347
00:14:48,730 --> 00:14:49,770
The landscape was much different, 
前景是非常不同的

348
00:14:49,780 --> 00:14:53,390
but a lot of the things we'll talk about will be just modern incarnations
但我们将谈论的许多东西将只是ibm

349
00:14:53,400 --> 00:14:54,550
of what ibm invented. 
发明的现代化身

350
00:14:55,520 --> 00:14:56,110
The years ago, 
几年前

351
00:14:56,760 --> 00:14:58,550
we're going to spend a whole lecture on query compilation, 
我们将花一整堂课的时间来讲解查询编译

352
00:14:58,960 --> 00:14:59,910
how to take a segal query, 
如何将Segal查询转换为查询计划

353
00:14:59,920 --> 00:15:04,070
turn into a query plan and then converted that query plan into machine code. 
然后将该查询计划转换为机器码

354
00:15:04,960 --> 00:15:06,520
Ibm did that in the 1970s. 
IBM在20世纪70年代就这样做了

355
00:15:06,530 --> 00:15:08,550
It was system r they did it in an assembly. 
这是系统R 他们在一个组件中做的

356
00:15:09,300 --> 00:15:13,460
Now we use lbm but again, the techniques are not new.
现在我们使用LBM 但同样 这些技术并不是新的

357
00:15:13,470 --> 00:15:16,910
The other big thing is going to happen and you'll see this the rest
另一件大事将会发生 在你的余生中

358
00:15:16,920 --> 00:15:22,130
of your life is that every 10 years somebody's gonna come along and say, 
你会看到每隔10年

359
00:15:22,140 --> 00:15:23,210
hey, sequel is stupid.
就会有人走过来说 嘿 续集是愚蠢的

360
00:15:23,550 --> 00:15:25,440
Relational model that's slow, right?
关系模型很慢 对吧

361
00:15:25,980 --> 00:15:26,690
We can do it better. 
我们可以做得更好

362
00:15:26,700 --> 00:15:30,890
Here's my new data system that doesn't use, at least the model is equal.
这是我的新数据系统 不使用 至少模型是平等的

363
00:15:31,620 --> 00:15:31,730
Right? 
对的

364
00:15:32,260 --> 00:15:33,535
Everyone's gonna go excited like this is the future sql
每个人都会很兴奋 就像未来的sql

365
00:15:33,535 --> 00:15:34,810

是旧的

366
00:15:34,810 --> 00:15:35,050
 is old, 


367
00:15:35,060 --> 00:15:36,530
sequel is busted, we don't want to use that.
续集是失败的 我们不想用它

368
00:15:37,040 --> 00:15:40,270
And then low and behold people realize the relational model was
然后看吧 人们意识到关系模型是一个好主意

369
00:15:40,280 --> 00:15:40,715
a good idea or sql
或者sql

370
00:15:40,715 --> 00:15:41,150

是一个好主意

371
00:15:41,150 --> 00:15:42,070
 is a good idea. 


372
00:15:43,380 --> 00:15:45,970
Either that thing that the new invention that comes along, 
要么是新发明出现

373
00:15:46,290 --> 00:15:47,270
either that fails, 
要么是失败

374
00:15:48,400 --> 00:15:52,650
or the whatever ideas that this new idea, 
或者这个新的想法

375
00:15:52,660 --> 00:15:56,220
this new concept or new data system has letters get adopted
这个新的概念或者新的数据系统有字母的任何想法被采纳

376
00:15:57,230 --> 00:15:58,900
by the sequel standard and by the racial model. 
按照续集的标准和种族模式

377
00:15:59,550 --> 00:16:00,480
Then that thing goes away. 
然后那东西就消失了

378
00:16:00,490 --> 00:16:01,900
All right? 
好吧

379
00:16:02,460 --> 00:16:04,100
So I think i've seen this in my own life, 
所以我想我在自己的生活中已经看到了这一点

380
00:16:04,470 --> 00:16:05,760
like no sequel is a hot thing. 
就像没有续集是一件热门的事情

381
00:16:06,380 --> 00:16:08,350
People said sequel slow, sequel, stupid,
人们说sql慢 sql愚蠢

382
00:16:08,590 --> 00:16:10,130
relation models too, but you want to do documents,
关系型模型也是

383
00:16:10,140 --> 00:16:11,860
you need jason and everybody built all these jason databases. 
但你想做文档 你需要json和每个人都建立了所有这些json

384
00:16:11,860 --> 00:16:13,580

数据库

385
00:16:14,110 --> 00:16:14,290
Right? 
对的

386
00:16:14,300 --> 00:16:18,120
And then now we're at the point where maybe that's a bad idea for everything. 
然后现在我们到了也许这对一切都是个坏主意的地步

387
00:16:18,960 --> 00:16:20,260
Json is good for some things. 
json对某些事情很在行

388
00:16:20,430 --> 00:16:22,250
The relation model now supports json. 
关系型模型现在支持json

389
00:16:23,880 --> 00:16:27,080
And then all the no sql systems that said sql is a bad idea. 
然后所有没有续集的系统都说sql是个坏主意

390
00:16:27,680 --> 00:16:29,970
Every one of them except for redis supports sql, 
除了redis 他们每个人都支持sql

391
00:16:30,570 --> 00:16:30,650
right? 
对吧

392
00:16:30,660 --> 00:16:32,170
Mongo support to see last year. 
去年mongo支持看

393
00:16:33,630 --> 00:16:33,980
Right? 
对的

394
00:16:33,990 --> 00:16:35,940
So you're going to see this throughout the theme, 
所以你会在整个主题中看到这一点

395
00:16:35,950 --> 00:16:39,530
as we go along is that at least once we get past and once the racial model
至少一旦我们过去了

396
00:16:39,540 --> 00:16:39,910
gets invented, 
一旦种族模式被发明出来

397
00:16:40,530 --> 00:16:42,540
people will say every 10 years it's stupid. 
人们每10年就会说这是愚蠢的

398
00:16:43,040 --> 00:16:48,100
And then it turns out it was mark my board and you'll see this the rest
结果发现是马克在我的冲浪板上

399
00:16:48,110 --> 00:16:48,460
of your life. 
你的余生都会看到这个

400
00:16:48,770 --> 00:16:49,220
I guarantee you, 
我向你保证

401
00:16:51,120 --> 00:16:52,670
let's start at the very beginning, 
让我们从头开始

402
00:16:54,170 --> 00:16:55,050
1960s. 
1960年代

403
00:16:55,910 --> 00:16:57,470
So to the best of my knowledge, 
所以据我所知

404
00:16:57,960 --> 00:16:59,830
at least what is considered conventional wisdom, 
至少被认为是传统智慧

405
00:17:00,320 --> 00:17:02,050
the very first database system, 
第一个数据库系统

406
00:17:03,290 --> 00:17:05,010
our sort of general purpose database system, 
我们的通用数据库系统

407
00:17:05,560 --> 00:17:11,170
was this thing called integrated data store or iids and I say general purpose, 
被称为集成数据存储或iids 我说的通用

408
00:17:11,180 --> 00:17:15,570
what I mean is that it was a database system that was designed to support
我的意思是它是一个数据库系统

409
00:17:16,310 --> 00:17:18,460
arbitrary data sets or databases. 
旨在支持任意数据集或数据库

410
00:17:19,040 --> 00:17:19,270
Right? 
对的

411
00:17:19,400 --> 00:17:19,790
Obviously, 
显然

412
00:17:19,800 --> 00:17:22,870
you can write a little python application yourself and read and write files. 
您可以自己编写一个小型Python应用程序并读写文件

413
00:17:22,880 --> 00:17:25,190
That's just for exactly that one database. 
这只是一个数据库

414
00:17:25,540 --> 00:17:27,610
That's not what I mean by this, like those things sort of existed.
这不是我的意思 就像那些东西存在一样

415
00:17:28,050 --> 00:17:31,270
But this was specifically to say we could then reuse the system
但这特别是说

416
00:17:31,280 --> 00:17:34,700
for another application or another customer. 
我们可以将该系统重新用于另一个应用程序或另一个客户

417
00:17:36,170 --> 00:17:37,480
Ge got this for. 
通用电气得到了这个

418
00:17:38,730 --> 00:17:41,830
It was like some timber company out of seattle that had
这就像西雅图的一些木材公司有一个巨大的库存跟踪问题

419
00:17:41,840 --> 00:17:46,860
a huge inventory tracking problem that they need to deal with. 
他们需要处理

420
00:17:47,170 --> 00:17:49,160
And said they built this thing called ids to handle that. 
并说他们建立了一个叫做IDS的东西来处理这个问题

421
00:17:51,140 --> 00:17:55,490
They end up spinning it out of that custom solution for the timber company
他们最终将其从木材公司的定制解决方案中分离出来

422
00:17:55,800 --> 00:17:58,100
and try to sell it a as a standalone product. 
并试图将其作为独立产品销售

423
00:17:58,350 --> 00:17:58,360
Right? 
对的

424
00:17:58,370 --> 00:17:59,950
Like ge was trying to be a software vendor. 
就像通用电气试图成为一家软件供应商一样

425
00:18:01,280 --> 00:18:05,580
Is ge the hot thing in computers right now? 
GE现在是计算机领域的热门产品吗

426
00:18:05,590 --> 00:18:05,740
No. 
不

427
00:18:06,090 --> 00:18:06,470
Right. 
对的

428
00:18:06,990 --> 00:18:13,050
So what the huge mistake they did is that they had this company policy
所以他们犯了一个巨大的错误

429
00:18:13,060 --> 00:18:15,580
at the time where ge said, 
他们当时的公司政策是

430
00:18:16,330 --> 00:18:18,340
if we're not number one in some industry, 
如果我们在某个行业不是第一

431
00:18:18,680 --> 00:18:19,840
we don't want to be in it at all. 
我们就根本不想进入这个行业

432
00:18:20,090 --> 00:18:22,990
So they were like the number three computer seller that wasn't good
所以他们就像是排名第三的电脑销售商

433
00:18:23,000 --> 00:18:23,510
enough for them. 
对他们来说不够好

434
00:18:23,520 --> 00:18:26,230
And so they sold off their computing division to honeywell. 
所以他们把计算机部门卖给了honeywell

435
00:18:27,430 --> 00:18:27,610
Right? 
对的

436
00:18:27,780 --> 00:18:33,100
Then honeywell owned own owned ids and then they were sort of selling it
然后霍尼韦尔拥有自己的ID

437
00:18:33,650 --> 00:18:34,110
for a while. 
然后他们卖了一段时间

438
00:18:35,340 --> 00:18:41,210
So there could be two key things about ids that are going to be bad ideas
因此 关于ids可能有两个关键的东西 这两个东西将是坏主意

439
00:18:41,220 --> 00:18:44,990
that are going to then get fixed in their relation to model. 
然后将在它们与模型的关系中得到修复

440
00:18:45,630 --> 00:18:47,350
The first is to meet this network data model, 
第一个是满足这个网络数据模型

441
00:18:47,360 --> 00:18:48,710
and i'll explain what that is in a second. 
第二个我会解释它是什么

442
00:18:49,120 --> 00:18:52,030
And then the other one's going to be this notion of the tuple at a time query, 
然后另一个是tuple-at-a-time query的概念

443
00:18:52,700 --> 00:18:54,020
meaning like i'm going to write, 
意思是我要写的

444
00:18:54,530 --> 00:18:56,580
basically for loops in my program, 
基本上是我的程序中的循环

445
00:18:57,020 --> 00:18:59,310
iterate over one tuple at a time and do something. 
一次迭代一个元组 然后做一些事情

446
00:19:00,470 --> 00:19:01,630
But as we know, in sql, though,
但正如我们所知道的

447
00:19:01,640 --> 00:19:03,430
we're an operator or bags or sets, 
结果是 我们是一个运营商或包或设置

448
00:19:04,440 --> 00:19:06,630
we declare what the thing we actually want to do. 
我们宣布我们真正想做的事情

449
00:19:06,980 --> 00:19:09,450
That then could apply to multiple tuples. 
这可能适用于多个tuples

450
00:19:10,390 --> 00:19:11,400
And that's me way more efficient. 
这是我更有效率的方式

451
00:19:13,670 --> 00:19:18,300
So ids didn't really take off as far as I know. 
所以据我所知 身份证并没有真正流行起来

452
00:19:19,160 --> 00:19:21,750
But what actually came out of the project was this thing called codacil. 
但实际上这个项目产生的是一个叫做Codacil的东西

453
00:19:21,760 --> 00:19:24,470
I I should do a survey before the class starts. 
我应该在上课前做个调查

454
00:19:24,480 --> 00:19:25,550
Who's ever heard of coda still? 
谁还听说过尾波

455
00:19:27,090 --> 00:19:29,110
Well, who not from the previous class?
好吧 谁不是上一届的

456
00:19:30,570 --> 00:19:34,250
One of you code is always going to be the hot thing of databases. 
你们中的一个代码总是会成为数据库中的热门话题

457
00:19:34,540 --> 00:19:37,090
This was the thing that everyone's going to build for their database. 
这是每个人都要为他们的数据库建立的东西

458
00:19:37,640 --> 00:19:39,080
And obviously, we don't.
很明显 我们没有

459
00:19:39,730 --> 00:19:41,510
So there was this guy, charles bachman,
所以有一个人

460
00:19:41,920 --> 00:19:45,550
who worked in ids and he saw, 
查尔斯·巴赫曼 他在ids工作 他看到了

461
00:19:45,850 --> 00:19:49,730
she saw the need for having a standard way for cobalt programmers
她看到了cobalt程序员需要一种标准的方式来

462
00:19:49,740 --> 00:19:51,490
to interact with the database system. 
与数据库系统交互

463
00:19:52,750 --> 00:20:00,570
They proposed this data model and this query api called codes film
他们提出了这个数据模型和这个名为codes film的查询api

464
00:20:01,480 --> 00:20:03,870
that incorporated the network data model from and the tube
它结合了ids上一张幻灯片中的网络数据模型

465
00:20:03,880 --> 00:20:08,570
out of time query model from the previous slide from ids and they said
和tube out of time查询模型

466
00:20:08,980 --> 00:20:09,370
this is
他们说这将成为

467
00:20:09,380 --> 00:20:10,770
going to be the standard going forward. 
未来的标准

468
00:20:12,010 --> 00:20:16,210
So then bachmann left ids and he worked at this thing called que lane, 
然后巴赫曼离开了ids 他在一个叫que lane的地方工作

469
00:20:16,760 --> 00:20:19,150
which has been bought and sold over many years. 
这个地方已经被买卖了很多年

470
00:20:19,460 --> 00:20:22,320
And he helped build a new version of a network data model based
他帮助建立了一个基于代码单元的网络数据模型的新版本 称为idms

471
00:20:22,330 --> 00:20:26,100
on code cell called idms and this thing is actually still around today. 
这个东西实际上今天仍然存在

472
00:20:26,440 --> 00:20:28,510
You're obviously, if you're a brand new startup, you wouldn't use this,
很明显 如果你是一家全新的创业公司

473
00:20:28,520 --> 00:20:28,700
right? 
你不会用这个 对吧

474
00:20:28,710 --> 00:20:29,840
This is for like legacy applications. 
这适用于类似的遗留应用程序

475
00:20:31,230 --> 00:20:33,250
So the networking model is going to look like this. 
所以网络模型看起来是这样的

476
00:20:33,260 --> 00:20:38,360
So say I have this example where i'm say i'm nasa. 
我举个例子 我说我是NASA

477
00:20:38,370 --> 00:20:40,200
This is actually a real example. 
这其实是一个真实的例子

478
00:20:40,660 --> 00:20:44,370
I'm nasa and i'm building a rocket for the go to the moon
我是美国国家航空航天局

479
00:20:44,380 --> 00:20:45,330
by the apollo moon mission. 
我正在为阿波罗登月计划建造一枚火箭

480
00:20:46,900 --> 00:20:48,370
A it's a huge engineering project. 
A这是一个庞大的工程项目

481
00:20:48,380 --> 00:20:51,640
I need to keep track of all the parts that are going to my rocket
我需要跟踪我的火箭的所有部件

482
00:20:52,340 --> 00:20:55,210
and what manufacturer or what company can provide them for me. 
以及什么制造商或什么公司可以为我提供这些部件

483
00:20:56,350 --> 00:20:56,500
Right? 
对的

484
00:20:56,510 --> 00:20:59,660
So they would have this database where you have suppliers and the parts. 
所以他们会有这个数据库 你有供应商和零件

485
00:21:00,130 --> 00:21:02,400
Then you keep track of what supplier can provide certain parts
然后你跟踪什么供应商可以提供某些零件

486
00:21:02,410 --> 00:21:03,800
and what price and what size and so forth. 
什么价格 什么尺寸等等

487
00:21:05,510 --> 00:21:06,820
Under the network data model, 
在网络数据模型下

488
00:21:06,830 --> 00:21:09,300
you would have the high level entities like you would have a supplier, 
您将拥有高级实体

489
00:21:09,310 --> 00:21:13,570
the name of the company that could provide the part or provide parts. 
就像您将拥有供应商一样 即可以提供零件或提供零件的公司的名称

490
00:21:13,910 --> 00:21:15,070
You have the part that you need. 
你有你需要的部分

491
00:21:15,420 --> 00:21:17,050
And then you have this other set that says, 
然后你有另一套

492
00:21:17,060 --> 00:21:19,290
here's the for this supplier, 
这是这个供应商的

493
00:21:19,300 --> 00:21:21,450
they will supply this part, this price.
他们将提供这个零件 这个价格

494
00:21:21,460 --> 00:21:24,080
So you could have these high level entities. 
所以你可以拥有这些高级实体

495
00:21:25,640 --> 00:21:28,180
But then you would have to implicitly have these sets. 
但是你必须隐式地拥有这些集合

496
00:21:29,180 --> 00:21:30,630
Here what i'm showing in italics, right?
这是我用斜体显示的 对吗

497
00:21:30,640 --> 00:21:32,550
You would have the supplies and the supplied by, 
你会有供应品和供应者

498
00:21:33,080 --> 00:21:37,660
you would say I have a supplier and there will be a supply
你会说我有一个供应商

499
00:21:37,670 --> 00:21:39,300
that's in the set of supplies. 
在供应品集合中会有一个供应品

500
00:21:40,690 --> 00:21:47,420
Now if I want to find find me all the parts that a supplier supplies, 
现在 如果我想找到供应商提供的所有零件

501
00:21:47,850 --> 00:21:49,490
I would have to do a bunch of nest of four lips. 
我必须做一堆四个嘴唇的巢穴

502
00:21:49,500 --> 00:21:51,050
Go look over every supplier here, 
去看看这里的每一个供应商

503
00:21:51,450 --> 00:21:53,190
look over all their supply sets, 
看看他们所有的供应集

504
00:21:53,700 --> 00:21:56,390
get the supply types, and then reverse go back up there, right?
得到供应类型 然后反过来回到那里 对吗

505
00:21:57,410 --> 00:21:59,200
You basically write a bunch of these nets of four lips, 
你基本上写了一堆四个嘴唇的网

506
00:21:59,210 --> 00:22:00,700
and you're doing this over one tube at a time. 
你一次在一个管子上做这个

507
00:22:03,220 --> 00:22:06,400
Another problem is going to be is that actually, 
另一个问题是 实际上

508
00:22:06,410 --> 00:22:07,920
the way you sort of look like this, 
你看起来像这样

509
00:22:07,930 --> 00:22:10,800
if you actually have an instance of this, 
如果你真的有一个这样的例子

510
00:22:11,490 --> 00:22:11,530
right? 
对吧

511
00:22:11,540 --> 00:22:13,170
You have supplier supplies of parts, 
你有供应商供应的零件

512
00:22:13,690 --> 00:22:16,750
and then you would have these auxiliary tables
然后你会有这些

513
00:22:16,760 --> 00:22:18,510
and basically cross reference tables you would have, 
辅助表和基本的交叉引用表

514
00:22:19,160 --> 00:22:24,540
or you keep pointers to the actual objects. 
或者你保留指向实际对象的指针

515
00:22:25,070 --> 00:22:26,520
And so these red lines i'm drawing here. 
所以我在这里画了这些红线

516
00:22:26,530 --> 00:22:29,540
These are actually pointers like physical pointers to like, 
这些实际上是类似物理指针的指针

517
00:22:29,550 --> 00:22:32,880
here's the location of this record on disk or in memory. 
这是该记录在磁盘或内存中的位置

518
00:22:34,140 --> 00:22:34,540
Right? 
对的

519
00:22:35,230 --> 00:22:35,730
Again. 
又

520
00:22:35,740 --> 00:22:37,770
So now, when you get your looping through,
所以现在 当你通过循环时

521
00:22:39,100 --> 00:22:41,170
try to find all the suppliers apply a certain part. 
试着找到所有的供应商来申请某一部分

522
00:22:41,700 --> 00:22:42,940
You'd have to look at the first one, 
您必须查看第一个

523
00:22:42,950 --> 00:22:47,040
and then you do a look up to find the record in this entity. 
然后查找该实体中的记录

524
00:22:47,050 --> 00:22:48,720
And i'm going to call it a table because it's not. 
我要称它为桌子 因为它不是

525
00:22:49,740 --> 00:22:51,700
And then you would follow the pointer to jump here. 
然后你会跟着指针跳到这里

526
00:22:52,140 --> 00:22:52,740
And then potentially, 
然后潜在地

527
00:22:52,750 --> 00:22:54,620
you could have a pointer to go back in the other direction. 
你可以有一个指针回到另一个方向

528
00:22:55,740 --> 00:22:56,060
Right? 
对的

529
00:22:57,530 --> 00:23:00,430
So the queries are very complex, right?
所以查询非常复杂 对吧

530
00:23:00,440 --> 00:23:01,910
This is all written in cobalt. 
这都是用钴写的

531
00:23:03,350 --> 00:23:06,850
And it was less efficient because again, 
它的效率较低

532
00:23:06,980 --> 00:23:08,690
you're operating over a single tuple at a time. 
因为你一次只在一个tuple上操作

533
00:23:09,690 --> 00:23:10,600
It was easily corruptible. 
它很容易被打断

534
00:23:10,610 --> 00:23:13,680
So if this thing gets if this the harbor is crappy back, 
所以如果这个东西得到了

535
00:23:13,690 --> 00:23:18,010
then this supplies or supplied by these collections of data, 
如果这个港口是蹩脚的 那么这个提供或由这些数据的集合提供

536
00:23:18,020 --> 00:23:18,690
these pointers. 
这些指针

537
00:23:19,020 --> 00:23:20,400
If this thing gets corrupted, 
如果这个东西被破坏了

538
00:23:20,410 --> 00:23:21,560
your whole database is host, 
你的整个数据库都是主机

539
00:23:21,570 --> 00:23:24,660
because now you have no way to to traverse and find things, 
因为现在你没有办法遍历和查找东西

540
00:23:25,670 --> 00:23:28,340
understand the relationships between these objects. 
了解这些对象之间的关系

541
00:23:28,350 --> 00:23:31,660
All right. 
好吧

542
00:23:31,670 --> 00:23:35,850
So the next big system that was in the 1960s was this thing called ims
所以在20世纪60年代的下一个大系统是这个叫做IMS的东西

543
00:23:36,390 --> 00:23:38,400
and this actually was built for the apollo moon mission. 
它实际上是为阿波罗登月任务建造的

544
00:23:38,570 --> 00:23:42,260
Ibm was responsible for the building out of database to keep track
IBM负责构建数据库

545
00:23:42,270 --> 00:23:44,340
of all the parts they were. 
以跟踪它们的所有部分

546
00:23:44,350 --> 00:23:46,480
Nasa was buying to build the rockets. 
美国国家航空航天局购买建造火箭

547
00:23:47,330 --> 00:23:47,680
And again, 
同样

548
00:23:47,690 --> 00:23:51,870
just like for ge and is they built a sort of custom database system
就像ge和is一样 他们为该项目建立了一种自定义数据库系统

549
00:23:51,880 --> 00:23:55,110
for the project and then realized it was useful for other customers, 
然后意识到它对其他客户有用

550
00:23:55,630 --> 00:23:57,090
and they spun it out as a separate product. 
他们将其作为一个单独的产品

551
00:23:57,620 --> 00:23:58,940
This thing still exists today. 
这件事今天仍然存在

552
00:23:59,170 --> 00:24:02,230
And ibm makes a ton of money on these things. 
IBM在这些东西上赚了很多钱

553
00:24:02,240 --> 00:24:03,470
And this data has been till today. 
这个数据一直到今天

554
00:24:04,970 --> 00:24:07,350
If you ever used an atm machine or anything in the bank, 
如果你曾经使用过ATM机或银行里的任何东西

555
00:24:07,360 --> 00:24:10,760
a lot of them are still using ims as they set up in the 70s. 
他们中的很多人仍然在使用70年代建立的IMS

556
00:24:11,200 --> 00:24:11,880
If it's not broken, 
如果它没坏

557
00:24:12,410 --> 00:24:12,960
don't fix it. 
就不要修理它

558
00:24:15,770 --> 00:24:18,190
Ims is going to use what's called a hierarchical data model. 
IMS将使用所谓的分层数据模型

559
00:24:19,880 --> 00:24:23,420
And just like the network data model is going to use a tube out of time queries. 
就像网络数据模型一样 将使用管超时查询

560
00:24:23,970 --> 00:24:27,210
Then another big thing is that it's going to support a programmer to find
另一件重要的事情是它将支持程序员找到

561
00:24:27,800 --> 00:24:28,900
physical data structures, 
物理数据结构

562
00:24:30,010 --> 00:24:32,270
meaning like if I have a collection of data like a table, 
意思是如果我有一个像表一样的数据集合

563
00:24:32,960 --> 00:24:34,550
I don't use your table because they wouldn't call it that, 
我不会使用你的表 因为他们不会这样称呼它

564
00:24:34,560 --> 00:24:35,390
but assume it's a table. 
而是假设它是一个表

565
00:24:36,250 --> 00:24:37,640
I would actually tell the database system. 
我会告诉数据库系统

566
00:24:37,650 --> 00:24:38,840
I want to store it as a hash table, 
我想把它存储为哈希表

567
00:24:38,850 --> 00:24:40,280
or I want to store it as ab plus tree. 
或者我想把它存储为AB加树

568
00:24:41,360 --> 00:24:42,870
Then based on what I told it, 
然后根据我告诉它的

569
00:24:42,880 --> 00:24:45,350
I wanted to store it as you then got a different api that allowed you
我想存储它 然后你得到一个不同的api

570
00:24:45,360 --> 00:24:46,190
traversing the data, 
允许你遍历数

571
00:24:47,000 --> 00:24:48,780
because you can't do range queries and hash tables, 
据因为你不能做范围查询和哈希表

572
00:24:48,790 --> 00:24:50,140
but you can't do it on b plus trees. 
但你不能在b加树上做

573
00:24:52,460 --> 00:24:53,530
Go back to our example here. 
回到我们的例子

574
00:24:54,760 --> 00:24:55,810
We have a supplier now. 
我们现在有供应商了

575
00:24:57,600 --> 00:24:59,790
I'm an idiot because this i'm leaving plug of a clicker in. 
我是个白痴 因为我把遥控器的插头留在里面了

576
00:25:01,280 --> 00:25:01,870
That's pathetic. 
太可悲了

577
00:25:02,760 --> 00:25:02,870
Right? 
对的

578
00:25:02,880 --> 00:25:04,070
So I have a supplier. 
所以我有一个供应商

579
00:25:04,590 --> 00:25:08,680
And now they have parts that looks a little bit better, right?
现在他们有了看起来更好的部分 对吧

580
00:25:08,690 --> 00:25:10,400
Because now I don't have to have all this extra stuff. 
因为现在我不需要这些多余的东西了

581
00:25:12,340 --> 00:25:12,570
Now, 
现在

582
00:25:12,580 --> 00:25:16,390
but I do have an implicit relationship between explicit relation
但我确实在供应商和零件之间的显式关系之间

583
00:25:16,400 --> 00:25:17,890
between the supplier and the part. 
有一个隐式关系

584
00:25:18,550 --> 00:25:21,880
A part can only supply by one particular supplier. 
一个零件只能由一个特定的供应商供应

585
00:25:23,480 --> 00:25:24,720
Right now, if I go to my instance,
现在 如果我去我的实例

586
00:25:26,090 --> 00:25:26,440
right? 
是吧

587
00:25:26,810 --> 00:25:29,450
Say this first vendor, 
比如说第一个供应商

588
00:25:29,980 --> 00:25:31,040
they supply batteries. 
他们供应电池

589
00:25:31,050 --> 00:25:32,680
I would have to have another whole record for that. 
我必须有另一个完整的记录

590
00:25:33,300 --> 00:25:36,410
And then I would have to have another record for the second vendor
然后我必须为第二个供应商提供另一张唱片

591
00:25:36,420 --> 00:25:37,730
who's playing maybe the same batteries, 
他们可能使用相同的电池

592
00:25:37,740 --> 00:25:38,570
but a different price. 
但价格不同

593
00:25:39,990 --> 00:25:47,000
So let's say now if I change the name of the of the part from batteries to
现在 假设我将部件的名称从batteries更改为on a

594
00:25:47,330 --> 00:25:49,200
on a brand name battery, 
brand name battery

595
00:25:49,210 --> 00:25:51,510
whatever I want to change this field here, 
无论我想在这里更改什么

596
00:25:51,850 --> 00:25:55,930
i've got to go through and change every single record instance
我都必须检查并更改

597
00:25:55,940 --> 00:25:59,210
of where the batteries exist. 
电池所在位置的每个记录实例

598
00:26:00,440 --> 00:26:03,030
Because you were basically repeating information because you couldn't have
因为你基本上是在重复信息

599
00:26:03,440 --> 00:26:07,020
one part be supplied by multiple suppliers in this model. 
因为在这个模型中 你不能让一个零件由多个供应商提供

600
00:26:10,140 --> 00:26:11,960
The other problem you're going to have, also, too, is,
你还会遇到的另一个问题是

601
00:26:11,970 --> 00:26:13,010
as I said about the, 
正如我所说的

602
00:26:13,860 --> 00:26:17,200
since the system exposes the the ability to tell how you
由于系统公开了你实际上想要如何存储数据的能力

603
00:26:17,210 --> 00:26:18,360
actually want to store data, 
一个哈希表与B集群或其他什么

604
00:26:18,370 --> 00:26:20,000
a hash table versus b cluster or whatever, 
那么如果我改变主意

605
00:26:20,710 --> 00:26:23,860
then if I changed my mind and I said I sorted the hash table, 
我说我对哈希表进行了排序

606
00:26:24,050 --> 00:26:25,300
but I want to do range queries. 
但我想做范围查询

607
00:26:25,490 --> 00:26:27,860
Let me switch it to ab plus tree. 
让我把它切换到AB加树

608
00:26:28,930 --> 00:26:30,690
You had no way of easily changing that. 
你没有办法轻易改变这一点

609
00:26:30,700 --> 00:26:32,770
You had to actually dump the data out, 
实际上 您必须将数据转储出来

610
00:26:33,230 --> 00:26:36,050
then load it back under the new data structure. 
然后将其加载回新的数据结构中

611
00:26:36,940 --> 00:26:40,300
Then you actually have to go update your application code, 
然后你实际上必须去更新你的应用程序代码

612
00:26:40,740 --> 00:26:43,690
because now it expose the hash the b plus gapi instead of the hash table
因为现在它暴露了b+gapi的哈希

613
00:26:43,700 --> 00:26:46,890
api there's no independence between the physical layer
而不是哈希表api 物理层和逻辑层之间没有独立性

614
00:26:46,900 --> 00:26:49,050
and the logical layer what the data actually was. 
数据实际上是什么

615
00:26:53,280 --> 00:26:54,780
All this is sort of the, yes,
所有这些都是一种 是的

616
00:27:02,480 --> 00:27:09,140
the system didn't support it with ims now in like twenty, 2003.
在2003年的20年里 系统不支持IMS

617
00:27:09,560 --> 00:27:14,230
I I ai think they have asql veneer on top of it. 
我人工智能认为他们在它上面有ASQL单板

618
00:27:15,350 --> 00:27:15,580
Right? 
对的

619
00:27:15,590 --> 00:27:19,260
And ii think it still is a hard come on an e there was attempts to convert
我认为这仍然是一个很难的事情

620
00:27:19,270 --> 00:27:23,870
it to racial model in the 80s rented pin out. 
在80年代 有人试图把它转换成种族模式

621
00:27:24,310 --> 00:27:25,950
But I this is like 1960s. 
但我这就像20世纪60年代

622
00:27:25,960 --> 00:27:26,390
This is the way. 
这就是方法

623
00:27:26,880 --> 00:27:32,030
So this is the motivation for the relational model. 
这就是关系模型的动机

624
00:27:34,540 --> 00:27:35,580
In the late 1960s, 
在20世纪60年代末 有一个叫泰德·科德的家伙

625
00:27:36,040 --> 00:27:39,780
there's this guy ted cod, who just finished his phd in math.
他刚刚完成了数学博士学位

626
00:27:40,430 --> 00:27:42,200
He was working in ibm research, 
他当时在ibm研究院工作

627
00:27:42,210 --> 00:27:46,480
and he saw all of these ims programmers spending a lot of time rewriting
他看到所有这些ims程序员花费大量时间一遍又一遍地

628
00:27:46,490 --> 00:27:48,120
for application code over and over again, 
重写应用程序代码

629
00:27:48,400 --> 00:27:50,090
because of this tight coupling between, 
原因是物理层和逻辑层

630
00:27:50,890 --> 00:27:52,750
again, the physical layer and the logical layer.
之间的这种紧密耦合

631
00:27:54,930 --> 00:27:56,950
And so then he realized that, 
然后他意识到

632
00:27:57,610 --> 00:28:00,810
which is actually quite prescient that this is not scalable. 
这实际上是相当有先见之明的 这是不可扩展的

633
00:28:01,440 --> 00:28:03,930
Humans at some point, it could be way more expensive than computers.
在某种程度上 它可能比计算机更昂贵

634
00:28:04,460 --> 00:28:06,550
At the time computers are super expensive, humans are cheap.
在计算机超级昂贵的时候 人类是廉价的

635
00:28:07,190 --> 00:28:08,170
The opposite now, right?
现在正好相反 对吧

636
00:28:08,180 --> 00:28:09,450
I can get an amazon instance, 
我可以得到一个

637
00:28:09,460 --> 00:28:11,950
a fraction of a penny an hour, 
amazon实例

638
00:28:12,720 --> 00:28:18,520
but a program is going to cost me 200 k how happens? 
每小时只需一分钱 但一个程序将花费我20万美元 这是怎么回事

639
00:28:19,630 --> 00:28:21,360
Just continue lecture, 
继续讲课

640
00:28:21,370 --> 00:28:23,100
not that one. 
不是那个

641
00:28:23,110 --> 00:28:23,680
What? 
什么

642
00:28:23,690 --> 00:28:25,360
Now i'm curious, 
现在我很好奇

643
00:28:28,380 --> 00:28:28,970
I don't know. 
我不知道

644
00:28:30,980 --> 00:28:34,810
Are you laughing at the 200 k for database programmer? 
你在嘲笑数据库程序员的200K吗

645
00:28:34,820 --> 00:28:35,370
That's a bit low? 
那有点低

646
00:28:42,150 --> 00:28:43,920
Anyway, data programs aren't cheap,
无论如何 数据程序并不便宜

647
00:28:46,290 --> 00:28:47,590
but at the time it was slept, 
但在它睡觉的时候

648
00:28:47,970 --> 00:28:50,360
he saw all these people wasting their time over again, 
他看到所有这些人又在浪费时间

649
00:28:50,370 --> 00:28:51,640
rewriting the application. 
重写应用程序

650
00:28:52,740 --> 00:28:55,570
They saw the inefficiency of having this sort of two po at a time
他们看到了这种一次两个Po的编程API的低效率

651
00:28:55,580 --> 00:29:02,270
programming api the relational model has sort of three key parts to it, 
关系模型有三个关键部分

652
00:29:03,390 --> 00:29:03,860
that again, 
再一次

653
00:29:03,870 --> 00:29:07,620
it serves as the background for all the racial modern racial data systems today. 
它成为了今天所有现代种族数据系统的背景

654
00:29:08,740 --> 00:29:09,490
The first of that, 
首先 我们

655
00:29:09,500 --> 00:29:11,590
we're going to store the database in simple data structures
将把数据库存储在简单的数据结构中

656
00:29:11,810 --> 00:29:15,180
instead of this graph in the coder cell network model, 
而不是编码器单元网络模型中的这个图

657
00:29:15,520 --> 00:29:20,280
or this hierarchy under ims we're going to store tables relations. 
或者ims下的这个层次结构 我们将存储表关系

658
00:29:20,290 --> 00:29:22,050
So these single heap things. 
所以这些单堆的东西

659
00:29:22,870 --> 00:29:29,440
And if they have relations or if there are references to other tables, 
如果它们有关系 或者有对其他表的引用

660
00:29:29,450 --> 00:29:32,360
we just store that as again as another attribute in their relations. 
我们只需将其作为另一个属性再次存储在它们的关系中

661
00:29:32,770 --> 00:29:32,920
Right? 
对的

662
00:29:32,930 --> 00:29:34,880
No need to have explicit pointers to anything. 
不需要任何明确的指针

663
00:29:36,320 --> 00:29:39,600
The program is the way we're going to access the database
该程序是我们通过高级语言访问

664
00:29:39,610 --> 00:29:40,680
through a high level language. 
数据库的方式

665
00:29:41,520 --> 00:29:42,820
Instead of writing these nested for loops, 
而不是编写这些嵌套的for循环

666
00:29:42,830 --> 00:29:46,420
they'll be able to say he didn't vent sequel at the time, 
他们将能够说他当时没有发泄Sequel

667
00:29:46,430 --> 00:29:47,490
but I sorry, 
但很抱歉

668
00:29:47,500 --> 00:29:49,290
there was not a programming language like siegel at the time, 
当时没有像Siegel这样的编程语言

669
00:29:49,300 --> 00:29:50,850
but he had this idea like, ok,
但他有这样的想法

670
00:29:51,210 --> 00:29:55,830
there's a way to abstract what the actual physical materialization
好吧

671
00:29:55,840 --> 00:29:57,470
of the physical structure of the database system. 
有一种方法可以抽象数据库系统的物理结构的实际物理物化

672
00:29:57,480 --> 00:29:59,030
And to say this is the answer I want. 
这就是我想要的答案

673
00:29:59,550 --> 00:30:01,140
And then a data system could figure it out for you. 
然后数据系统会帮你算出来

674
00:30:02,390 --> 00:30:02,710
Right? 
对的

675
00:30:02,720 --> 00:30:05,350
And then this also now means that because I have this abstraction
这也意味着

676
00:30:05,360 --> 00:30:06,830
between the physical layer and the logical layer, 
由于我在物理层和逻辑层之间进行了这种抽象

677
00:30:07,320 --> 00:30:11,210
the the strategy just stored the data physically on disk or in memory, 
该策略只是将数据物理地存储在磁盘或内存中

678
00:30:11,640 --> 00:30:13,450
we left entirely up to the implementation. 
我们完全由实现决定

679
00:30:14,410 --> 00:30:16,480
Because based on what the queries wanted to do, 
因为根据查询想要做的事情

680
00:30:16,990 --> 00:30:19,310
it could decide here's the best way to store your data. 
它可以决定存储数据的最佳方式

681
00:30:21,020 --> 00:30:21,170
Right? 
对的

682
00:30:21,340 --> 00:30:24,570
The first paper on the racial model came out in 1969. 
第一篇关于种族模式的论文发表于1969年

683
00:30:25,590 --> 00:30:27,140
This is the very first one. 
这是第一个

684
00:30:28,200 --> 00:30:31,010
This is usually the one everyone cites as the
这通常是每个人都引用的一篇事实上的关系模型论文

685
00:30:31,540 --> 00:30:35,570
as the de facto relational model paper that this came out in the cacm
该论文于1970年发表

686
00:30:35,580 --> 00:30:36,450
in 1970. 
在cacm上

687
00:30:36,810 --> 00:30:37,990
But this was the very first one. 
但这是第一个

688
00:30:39,410 --> 00:30:42,750
We go back to our example before suppliers and supplies and parts. 
我们回到供应商 供应品和零件之前的例子

689
00:30:43,430 --> 00:30:43,690
Right? 
对的

690
00:30:43,700 --> 00:30:44,730
It looks like this. 
它看起来像这样

691
00:30:45,280 --> 00:30:47,200
It's essentially what the network model was, 
它本质上是网络模型

692
00:30:47,210 --> 00:30:50,570
but now I don't have these explicit membership sets. 
但现在我没有这些明确的成员集

693
00:30:52,140 --> 00:30:55,450
Then now if I want to sort of in a table or in tables in a relational database, 
现在 如果我想在一个表或关系数据库中的

694
00:30:56,370 --> 00:30:56,620
right now, 
表中排序 现在

695
00:30:56,630 --> 00:31:01,340
I have these foreign key references that are just attributes in the object. 
我有这些外键引用 它们只是对象中的属性

696
00:31:01,870 --> 00:31:08,000
And the data system can understand that this supplier number corresponds
数据系统可以理解这个供应商编号对应于另一个表

697
00:31:08,010 --> 00:31:11,010
to some supplier number in this other table here. 
中的某个供应商编号

698
00:31:14,840 --> 00:31:15,870
We'll get to c equal to second, 
我们会得到C等于2

699
00:31:15,880 --> 00:31:17,150
but this was a radical idea. 
但这是一个激进的想法

700
00:31:17,540 --> 00:31:18,740
A sequel is a radical idea. 
续集是一个激进的想法

701
00:31:20,410 --> 00:31:24,830
Now we take it for granted because it's so prevalent, 
现在我们认为它是理所当然的

702
00:31:24,840 --> 00:31:32,290
but back then the criticism of the relational model was there's no way
因为它是如此普遍 但当时对关系模型的批评是没有办法数据库

703
00:31:32,300 --> 00:31:34,810
a database of no way a piece of software. 
没有办法软件

704
00:31:34,820 --> 00:31:38,500
It's going to write queries as efficient as what a human can write. 
它将编写与人类所能编写的查询一样高效的查询

705
00:31:40,030 --> 00:31:41,660
This seems sort of strange, 
这似乎有点奇怪

706
00:31:41,670 --> 00:31:44,020
but it's sort of the same argument that people made back in the day, 
但这与当年人们提出的论点相同

707
00:31:44,480 --> 00:31:47,790
that there's no way a compiler could generate program code that is
即编译器不可能生成比人类编写的代码

708
00:31:47,800 --> 00:31:49,520
more efficient than what a human could write. 
更高效的程序代码

709
00:31:49,530 --> 00:31:54,470
Sure that's potentially true for like highly skilled and embedded systems programmers. 
当然 对于高技能的嵌入式系统程序员来说 这可能是真的

710
00:31:54,710 --> 00:31:55,950
But nobody writes assembly today. 
但是今天没有人写汇编

711
00:31:56,480 --> 00:31:56,800
Right? 
对的

712
00:31:57,570 --> 00:32:02,050
Everybody writes in higher level languages and even higher like up in python. 
每个人都用更高级的语言写作 甚至更高级的语言 比如Python

713
00:32:02,490 --> 00:32:02,860
Right? 
对的

714
00:32:05,730 --> 00:32:08,370
But back then, again, this is like the sea compiler came out in 1970.
但在当时 这就像是1970年推出的SEA编译器

715
00:32:08,660 --> 00:32:12,920
This was an insane idea and turned out it was correct. 
这是一个疯狂的想法 事实证明它是正确的

716
00:32:13,850 --> 00:32:17,400
The depends on the implementation of the query optimizer, how good it is.
这取决于查询优化器的实现 以及它有多好

717
00:32:17,730 --> 00:32:20,570
And we'll see some papers that show how things go wrong. 
我们会看到一些论文 说明事情是如何出错的

718
00:32:21,570 --> 00:32:23,490
And that's certainly a hard problem. 
这当然是个难题

719
00:32:23,500 --> 00:32:24,370
But in general, 
但一般来说

720
00:32:24,380 --> 00:32:27,600
like a database system is going to generate a more efficient query plan
就像数据库系统将生成比一般程序员实际编写的更

721
00:32:27,610 --> 00:32:29,000
than an average programmer could actually write. 
有效的查询计划一样

722
00:32:29,590 --> 00:32:29,880
And also, 
而且

723
00:32:29,890 --> 00:32:32,680
now it exposes the data system to people that are maybe art programmers, 
现在它将数据系统暴露给可能是艺术程序员的人

724
00:32:33,320 --> 00:32:36,600
like business analysts or people doing accounting reporting, right?
比如业务分析师或做会计报告的人 对吧

725
00:32:36,610 --> 00:32:38,120
But they are not hardcore programmers. 
但他们不是铁杆程序员

726
00:32:38,560 --> 00:32:41,840
They can write sql, but maybe not can't write any cc plus.
他们可以编写SQL 但可能不能编写任何CC Plus

727
00:32:44,830 --> 00:32:47,790
So ted cod put out the paper in 1970. 
所以特德·科德在1970年发表了这篇论文

728
00:32:48,820 --> 00:32:49,810
He was a mathematician, 
他是个数学家

729
00:32:53,300 --> 00:32:55,990
this paper here, it's actually not the hard to read.
这里的这篇论文 实际上并不难读

730
00:32:57,270 --> 00:33:00,160
But when you read the criticisms of it or people talk about it at the time
但当你读到对它的批评 或者人们谈论它的时候

731
00:33:00,630 --> 00:33:01,950
contemporary conversations about it, 
当代关于它的谈话

732
00:33:02,310 --> 00:33:03,770
people say it was inscrutable. 
人们说它是高深莫测的

733
00:33:04,020 --> 00:33:05,690
It was told was heavy on math, 
据说它的数学很重

734
00:33:06,790 --> 00:33:07,180
not. 
不

735
00:33:07,570 --> 00:33:09,650
But again, maybe 1970s, I don't know, maybe it was.
但是 也许是20世纪70年代 我不知道 也许是

736
00:33:11,160 --> 00:33:14,460
He didn't propose a programming language in that paper. 
他在那篇论文中并没有提出一种编程语言

737
00:33:14,470 --> 00:33:16,530
He later did in 1974, 75,
他后来在1974年 75年

738
00:33:16,540 --> 00:33:19,320
this thing called alpha didn't go anywhere. 
这个叫做阿尔法的东西没有去任何地方

739
00:33:19,640 --> 00:33:20,810
But it was all math at the time. 
但当时都是数学

740
00:33:21,750 --> 00:33:25,350
And he didn't actually build a system to prove that his idea was working
他实际上并没有建立一个系统来证明他的想法是可行的

741
00:33:25,830 --> 00:33:26,240
could work. 


742
00:33:27,310 --> 00:33:30,040
What happened was there was a bunch of people saw his paper, 
事情是这样的 有一群人看到了他的论文

743
00:33:30,460 --> 00:33:30,720
said, hey,
说

744
00:33:30,730 --> 00:33:33,210
I think this is a good idea and actually started building
嘿 我认为这是一个好主意

745
00:33:33,220 --> 00:33:34,930
experimental systems to test that out. 
并开始建立实验系统来测试它

746
00:33:36,380 --> 00:33:39,570
The very first system that i'm aware of that did was this thing called
据我所知

747
00:33:39,580 --> 00:33:41,330
the peter lee relational test vehicle, 
第一个这样做的系统是一个叫做彼得·李关系测试工具的东西

748
00:33:41,720 --> 00:33:43,470
which sounds like a 1970s, like druggie ban.
听起来像20世纪70年代的毒品禁令

749
00:33:44,740 --> 00:33:47,990
But these are like people in the uk that basically read his paper, like,
但这些人就像英国人一样 基本上都读过他的论文

750
00:33:48,040 --> 00:33:48,910
I think it's a good idea. 
就像 我认为这是一个好主意

751
00:33:49,210 --> 00:33:52,250
And they built sort of early prototypes from four sequel. 
他们建立了四个续集的早期原型

752
00:33:52,570 --> 00:33:53,280
It they talk about, 
他们谈到

753
00:33:53,290 --> 00:33:56,340
it could store massive data sets of like 1,002 poles like that was mind
它可以存储大量的数据集 比如1002个极点

754
00:33:56,350 --> 00:33:57,300
blowing for them back of them. 
这对他们来说是令人兴奋的

755
00:33:59,260 --> 00:34:00,410
That one usually people forget about. 
人们通常会忘记这一点

756
00:34:00,420 --> 00:34:01,930
That's far as I know, that's the very first one.
据我所知 这是第一个

757
00:34:02,610 --> 00:34:09,000
But there's two other projects that came1 or 2 years after system are at
但是还有另外两个项目是在ibm的system和berkeley的ingress之后1

758
00:34:09,010 --> 00:34:10,800
ibm and then ingress at berkeley. 
或2年出现的

759
00:34:11,300 --> 00:34:15,880
These are considered the very first to relational data systems that
这些被认为是第一个关系数据系统

760
00:34:15,890 --> 00:34:19,160
like try to or try to build something based on ted cards work
试图建立一些基于Ted卡片的工作

761
00:34:19,170 --> 00:34:20,760
and actually build a real system. 
并真正建立一个真正的系统

762
00:34:21,270 --> 00:34:23,420
I think mimer sequel came out at a sweden, 
我认为《哑剧续集》是在瑞典推出的

763
00:34:23,850 --> 00:34:25,380
maybe a 1 or 2 years later, 
可能是1年或2年后

764
00:34:25,990 --> 00:34:27,530
but this is an act on a project. 
但这是一个项目的行为

765
00:34:27,540 --> 00:34:28,610
This still exists today. 
这在今天仍然存在

766
00:34:29,410 --> 00:34:31,240
Oracle with larry ellison, we know about that.
甲骨文和拉里·埃里森 我们知道这件事

767
00:34:31,930 --> 00:34:33,700
And we'll cover that throughout the semester. 
我们将在整个学期中讨论这个问题

768
00:34:34,440 --> 00:34:35,150
Basically, 
基本上

769
00:34:36,810 --> 00:34:40,620
the it's all happening in silicon valley. 
这一切都发生在硅谷

770
00:34:40,630 --> 00:34:42,510
Larry elsin basically copy what ibm did. 
Larry Elsin基本上复制了IBM的做法

771
00:34:42,880 --> 00:34:44,910
He would literally call them on the phone and ask about like, 
他会给他们打电话

772
00:34:45,400 --> 00:34:45,910
how does this work? 
问他们 这是怎么回事

773
00:34:45,920 --> 00:34:47,910
And they would tell them because they were researchers didn't know, 
他们会告诉他们 因为他们是研究人员 不知道

774
00:34:48,130 --> 00:34:49,300
and he went and copied it. 
他去复制了它

775
00:34:50,950 --> 00:34:55,100
And then ingress eventually got commercialized at the university
然后ingress最终在70年代末在大学里商业化了

776
00:34:55,580 --> 00:34:56,250
in the late 70s, 
因为人们

777
00:34:56,260 --> 00:34:58,690
because people actually started really using it because they understood
实际上开始真正使用它

778
00:34:58,700 --> 00:35:00,750
the the certificates of the racial model. 
因为他们了解种族模型的证书

779
00:35:02,220 --> 00:35:05,440
But again, 1970s, it was not clear that it could have been coda, still,
但同样 在20世纪70年代 不清楚它是否可能是尾波

780
00:35:05,450 --> 00:35:06,770
it could have been a relational model. 
但它可能是一个关系模型

781
00:35:07,870 --> 00:35:10,320
Eventually in the 1980s, relational model, one,
最终在20世纪80年代 关系模型 一

782
00:35:13,330 --> 00:35:14,510
two things happened, three things happened.
发生了两件事 三件事

783
00:35:15,210 --> 00:35:20,570
First is that ibm never commercialized system are they could have been
首先 ibm从未将系统商业化

784
00:35:20,580 --> 00:35:23,490
a dominant player in the and they do this marketplace, 
他们本可以在这个市场上占据主导地位

785
00:35:23,500 --> 00:35:27,660
but they drop the baldness because they were making so much money on ims like, 
但他们放弃了秃头 因为他们在ims上赚了很多钱

786
00:35:27,670 --> 00:35:30,530
why would you kill the golden goose with this other new data system that
当你在ims上赚了这么多钱的时候

787
00:35:30,540 --> 00:35:34,170
may not work when you're making so much money on ims but eventually they
你为什么要用另一个可能不起作用的新数据系统来杀死这只下金蛋的鹅呢

788
00:35:34,180 --> 00:35:35,370
saw the light and they put out their
但最终他们看到了曙光

789
00:35:35,380 --> 00:35:39,510
first relational database system called segal ds in 1981, 
并在1981年推出了他们的第一个关系数据库系统

790
00:35:39,790 --> 00:35:43,840
this had remnants of system r but a lot of it was written from scratch. 
称为segal ds 这是系统r的残余 但很多都是从零开始编写的

791
00:35:44,940 --> 00:35:45,730
Sequel. 
续集

792
00:35:45,740 --> 00:35:46,610
Ds is still around. 
DS还在

793
00:35:46,620 --> 00:35:48,090
They renamed it to db two, 
他们将其重命名为DB 2

794
00:35:48,420 --> 00:35:57,370
just like dv two for vse there's some like mainframe system that they wrote
就像VSE的DV 2一样

795
00:35:57,380 --> 00:35:58,210
sql ds four. 
还有一些类似于他们编写的SQL DS 4的大型机系统

796
00:35:58,650 --> 00:36:00,120
There's five versions of db two. 
DB 2有五个版本

797
00:36:00,130 --> 00:36:01,840
It's hard to track of them. 
很难追踪他们

798
00:36:02,680 --> 00:36:06,670
But then what we know about what we consider db two today, 
但是我们今天所知道的DB 2

799
00:36:07,090 --> 00:36:08,720
that first came out in 1983. 
第一次出现是在1983年

800
00:36:09,280 --> 00:36:10,670
When this came out 83, 
当它在83年问世时

801
00:36:11,040 --> 00:36:13,790
this is sort of the shot across the bow in the database industry to say, 
这是数据库行业的一次尝试

802
00:36:14,160 --> 00:36:15,550
now ibm series by the relational model. 
现在是IBM系列的关系模型

803
00:36:15,560 --> 00:36:17,310
These is a real idea. 
这是一个真实的想法

804
00:36:17,870 --> 00:36:20,090
Ingress and oracle are already still in the marketplace. 
Ingress和Oracle仍然在市场上

805
00:36:20,510 --> 00:36:22,920
But it basically showed that the relation model is the way forward. 
但它基本上表明 关系模式是前进的方向

806
00:36:23,520 --> 00:36:29,140
And sequel became the defective standard when this came out in 83. 
当这本书在83年出版时 续集成为了有缺陷的标准

807
00:36:29,990 --> 00:36:31,600
And oracle was at the right place at the right time, 
甲骨文在正确的时间出现在了正确的地方

808
00:36:31,610 --> 00:36:35,930
because I when ibm ibm was not going to say they were the juggernaut
因为当IBM的时候

809
00:36:35,940 --> 00:36:36,810
in the commuting industry. 
IBM不会说他们是通勤行业的巨头

810
00:36:36,820 --> 00:36:38,370
So they said, hey, this is the way it's going to be.
所以他们说 嘿 事情就是这样的

811
00:36:38,950 --> 00:36:39,950
This is the language we're going to use. 
这就是我们要用的语言

812
00:36:39,960 --> 00:36:42,390
Everyone said that ibm says that's what I do. 
每个人都说IBM说这就是我所做的

813
00:36:42,810 --> 00:36:44,750
When oracle was there, we say, hey, we already support sequel.
当甲骨文在那里的时候 我们说 嘿 我们已经支持Sequel了

814
00:36:44,760 --> 00:36:45,630
We're going to go. 
我们要走了

815
00:36:46,080 --> 00:36:48,120
Ingress had its own programming language called quell. 
Ingress有自己的编程语言Quell

816
00:36:48,690 --> 00:36:52,010
That strong breaker still claims is better than sql. 
那个强大的破坏者仍然声称比SQL更好

817
00:36:52,830 --> 00:36:54,090
They eventually supported sequel, 
他们最终支持了

818
00:36:54,100 --> 00:36:57,180
but it was by the time they added it, it was too late.
《续集》 但当他们加入时 已经太晚了

819
00:36:58,640 --> 00:37:03,760
So sequel reasonably spelled as seqeul because it's supposed to be
所以Sequel合理地拼写为Seqeul

820
00:37:03,770 --> 00:37:04,480
the sequel to quell. 
因为它应该是Quell的续集

821
00:37:05,000 --> 00:37:05,380
Right? 
对的

822
00:37:05,660 --> 00:37:06,750
To play on words, 
玩文字游戏

823
00:37:07,090 --> 00:37:09,080
then they got sued for trademark enrichment, 
然后他们因为商标丰富而被起诉

824
00:37:09,090 --> 00:37:14,500
so then they renamed it to sql and then there was a standard body to figure
所以他们把它改名为SQL

825
00:37:14,510 --> 00:37:17,020
out what should be the programming language we use
然后有一个标准机构来确定我们应该使用什么编程语言

826
00:37:19,080 --> 00:37:20,270
for relational databases. 
对于关系数据库

827
00:37:21,920 --> 00:37:24,020
And supposedly they were going to use quell, 
据推测 他们将使用奎尔

828
00:37:24,730 --> 00:37:25,430
set a sequel, 
设置一个续集

829
00:37:26,170 --> 00:37:30,830
but dome breaker didn't like standards bodies and decided not to submit
但穹顶破坏者不喜欢标准机构

830
00:37:30,840 --> 00:37:31,990
any paperwork for quell. 
并决定不为奎尔提交任何文件

831
00:37:32,900 --> 00:37:35,970
So there's this paragraph here from the larry ellison. 
这是拉里·埃里森的一段话

832
00:37:36,930 --> 00:37:37,850
Unauthorized biography. 
未经授权的传记

833
00:37:37,860 --> 00:37:38,970
I don't want you to recall it, 
我不想让你回忆起它

834
00:37:39,460 --> 00:37:41,750
but it came out in the late 90s where they basically talked about how they
但它出现在90年代末

835
00:37:41,760 --> 00:37:43,600
thought quell was better than sql, 
他们基本上是在谈论他们如何认为Quell比SQL更好

836
00:37:43,770 --> 00:37:45,930
but mike hated standards body. 
但Mike讨厌标准机构

837
00:37:45,940 --> 00:37:46,970
So he didn't submit anything. 
所以他没有提交任何东西

838
00:37:48,040 --> 00:37:48,230
Anyway. 
无论如何

839
00:37:48,940 --> 00:37:50,950
So that's why we end up with a sequel instead of quell. 
所以这就是为什么我们最终选择了续集而不是《平息》

840
00:37:52,570 --> 00:37:56,950
Does this one on hacker news occasionally see like people say, hey,
这个在黑客新闻上偶尔会看到人们说

841
00:37:56,960 --> 00:37:59,460
i've better the new version of sequel or better version of a sequel. 
嘿 我有更好的新版本的续集或更好的版本的续集

842
00:37:59,970 --> 00:38:03,670
And they a lot of the things they end up fixing the problems with in sequel
他们最终在续集中解决了很多问题

843
00:38:03,680 --> 00:38:07,070
like having the front claws after the select clause like quell. 
比如在选择条款之后有前爪 比如quell

844
00:38:07,470 --> 00:38:08,540
Already did that in the 70s. 
在70年代已经这样做了

845
00:38:10,020 --> 00:38:11,090
But we ended up with a sequel. 
但我们最终还是拍了续集

846
00:38:11,890 --> 00:38:12,170
Sorry. 
抱歉

847
00:38:15,670 --> 00:38:15,890
Right? 
对的

848
00:38:15,900 --> 00:38:19,730
So oracle basically wins the crown during the 1980s. 
所以甲骨文基本上在20世纪80年代赢得了桂冠

849
00:38:19,930 --> 00:38:23,480
There's a bunch of other startups that come along that do relation databases. 
还有很多其他的创业公司也在做关系数据库

850
00:38:23,870 --> 00:38:25,450
Psi based on formics interface, 
PSI基于FORMICS接口

851
00:38:25,780 --> 00:38:28,090
terror data was a data warehouse tandem got bought by deck. 
Terror Data是DECK收购的数据仓库串联

852
00:38:29,050 --> 00:38:32,510
Basically, the only one that's still thriving today, I would say,
基本上 我想说的是 今天唯一还在蓬勃发展的是oracle和db two

853
00:38:32,520 --> 00:38:36,600
is oracle and db two and thriving is not the right word I all these
而“蓬勃发展”这个词并不恰当

854
00:38:36,610 --> 00:38:38,320
like psi based still makes a ton of money. 
因为所有这些都是基于psi的 但仍然赚了很多钱

855
00:38:38,630 --> 00:38:40,220
But again, if you're a new start up a new company,
但是 如果你是一家新成立的公司 你不会使用它

856
00:38:40,230 --> 00:38:43,360
you wouldn't use it a lot of these systems are still arrayed maintenance mode, 
很多系统仍然处于维护模式

857
00:38:45,780 --> 00:38:47,300
but oracle is being actively loved, 
但甲骨文是积极的爱

858
00:38:47,310 --> 00:38:56,430
and then same with db two tear data is they're getting crushed by snowflake. 
然后与db two tear数据一样 他们正在被雪花粉碎

859
00:38:57,980 --> 00:38:59,510
So stone breaker, 
所以破石者 他商业化了他的入口

860
00:39:00,160 --> 00:39:01,550
he commercialized his ingress, 
回到伯克利

861
00:39:01,870 --> 00:39:04,140
goes back to berkeley, starts a new day system called postgress.
开始了一个新的一天系统 叫做postgress

862
00:39:04,150 --> 00:39:07,470
If you're the one I postgress is called postgres because it's post ingress. 
如果你是我 Postgress被称为Postgres 因为它是Post Ingress

863
00:39:07,990 --> 00:39:09,400
It's the sense that he built after ingress. 
这是他在进入后建立的感觉

864
00:39:11,280 --> 00:39:13,370
And instead of being a relational data system, 
他称这个系统为对象关系数据库系统

865
00:39:13,860 --> 00:39:15,850
he called this thing as an object relational database system. 
而不是关系数据系统

866
00:39:16,800 --> 00:39:18,960
Because object oriented program was the hot thing in the 1980s. 
因为面向对象编程是20世纪80年代的热门话题

867
00:39:19,650 --> 00:39:22,800
And this is why they postcards were designed for the very
这就是为什么明信片一开始就被设计得

868
00:39:22,810 --> 00:39:24,160
beginning to be very extensible. 
非常可扩展

869
00:39:24,700 --> 00:39:27,180
You can have user defined types, user defined functions, and so forth,
你可以有用户定义的类型

870
00:39:27,580 --> 00:39:32,780
because they wanted to borrow some of the ideas of object oriented databases, 
用户定义的函数等等 因为他们想借用面向对象数据库的一些想法

871
00:39:32,790 --> 00:39:36,200
which would be the next slide and be able to extend postcards very easily. 
这将是下一张幻灯片 并且能够很容易地扩展明信片

872
00:39:38,290 --> 00:39:39,480
Even today, technically,
即使在今天

873
00:39:39,490 --> 00:39:41,480
postcards is an object based on database system. 
从技术上讲 明信片也是一个基于数据库系统的对象

874
00:39:42,470 --> 00:39:43,860
People mostly ignore this part, 
人们大多忽略了这一部分

875
00:39:43,870 --> 00:39:45,010
the object part. 
客体部分

876
00:39:47,590 --> 00:39:48,390
Where are we at so far? 
到目前为止我们在哪里

877
00:39:48,740 --> 00:39:49,780
1970s, kodaso?
20世纪70年代 科达索

878
00:39:50,720 --> 00:39:55,180
Is there cobalt that the cobalt way to program davis is their glacial model
有没有钴

879
00:39:55,190 --> 00:39:55,700
comes out? 
用钴来编程戴维斯是他们的冰川模型出来了

880
00:39:55,990 --> 00:39:57,420
People say hit is the bad idea. 
人们说打人是个坏主意

881
00:39:57,790 --> 00:39:59,060
Coda cell is the right way to do it, 
尾波细胞是正确的方法

882
00:39:59,310 --> 00:40:00,570
especially where some model wins. 
尤其是在一些模型获胜的情况下

883
00:40:01,350 --> 00:40:04,110
And there's all these ways from davis has come out in the 1980s, 
戴维斯的所有这些方法都是在20世纪80年代出现的

884
00:40:04,840 --> 00:40:05,630
early 1980s, 
80年代初

885
00:40:06,410 --> 00:40:07,450
10 years later after that, 
10年后

886
00:40:07,460 --> 00:40:09,450
then we end up with these object, ordinary databases.
我们最终得到了这些对象 普通数据库

887
00:40:10,080 --> 00:40:12,150
And what i'm saying where people come along every 10 years and say, 
我想说的是 每隔10年

888
00:40:12,550 --> 00:40:13,350
I have a better idea. 
人们就会说 我有一个更好的主意

889
00:40:14,320 --> 00:40:15,310
In the 1980s, 
在20世纪80年代 人们认识到

890
00:40:15,920 --> 00:40:19,030
people recognize that if application available is going to use
如果应用程序可用

891
00:40:19,040 --> 00:40:20,630
an object oriented programming language. 
就要使用面向对象的编程语言

892
00:40:21,120 --> 00:40:23,690
Like c plus is the hot thing in the late 1980s, 
就像C+是20世纪80年代末的热门话题一样

893
00:40:25,680 --> 00:40:28,100
that there was this impedance mismatch, 
存在这种阻抗不匹配

894
00:40:28,110 --> 00:40:33,490
where the way the database system represented data as relations did not map
即数据库系统将数据表示为关系的方式没有清晰地映射到

895
00:40:33,500 --> 00:40:37,090
cleanly into how objects or object oriented programming represented data. 
对象或面向对象编程表示数据的方式

896
00:40:38,260 --> 00:40:41,790
So you'd have to write these sql queries that would basically convert rows
因此 您必须编写这些sql查询

897
00:40:41,800 --> 00:40:42,870
into now objects, 
这些查询基本上会将行转换为now对象

898
00:40:43,490 --> 00:40:44,270
sort of nested hierarchies. 
类似于嵌套层次结构

899
00:40:45,220 --> 00:40:47,420
And so a bunch of companies said this is kind of stupid. 
所以很多公司说这有点愚蠢

900
00:40:47,430 --> 00:40:50,630
Would it be distorted the objects directly in the database as objects? 
数据库中的对象直接作为对象会被扭曲吗

901
00:40:52,370 --> 00:40:54,880
There's a couple of systems, versant objects or 02.
有几个系统 Versant Objects或02

902
00:40:54,890 --> 00:40:58,590
I think mark logic you actually just got bought a few weeks ago, 
我认为马克的逻辑实际上是你几周前才被买下的

903
00:40:59,890 --> 00:41:02,280
but they were late 90s. 
但他们是90年代末的

904
00:41:03,890 --> 00:41:07,210
And so a bunch of these systems don't exist anymore again. 
所以一堆这样的系统再也不存在了

905
00:41:07,220 --> 00:41:08,210
Are there a maintenance mode? 
是否有维护模式

906
00:41:08,760 --> 00:41:13,940
The what killed him was that there was no standard query language you
杀死他的是没有标准的查询语言

907
00:41:13,950 --> 00:41:16,240
could use for object oriented databases. 
你可以使用面向对象的数据库

908
00:41:16,500 --> 00:41:19,210
Eventually, they propose oql the object query language,
最终 他们提出了对象查询语言oql

909
00:41:19,220 --> 00:41:20,450
but nobody supported that. 
但没有人支持它

910
00:41:20,460 --> 00:41:21,250
It was too late. 
已经太迟了

911
00:41:22,340 --> 00:41:22,650
Basically, 
基本上

912
00:41:22,660 --> 00:41:24,570
the problem was because you had this tight coupling
这个问题是因为你在数据库系统

913
00:41:24,580 --> 00:41:26,490
between the database system and the programming language. 
和编程语言之间有这种紧密耦合

914
00:41:28,360 --> 00:41:29,520
It made your application less portable. 
它降低了应用程序的可移植性

915
00:41:29,530 --> 00:41:32,880
It wasn't very easy for you to switch to another object oriented database system, 
对你来说 切换到另一个面向对象的数据库系统并不容易

916
00:41:32,890 --> 00:41:37,320
because you were writing to their proprietary api similar to how ims
因为你正在编写他们的专有api

917
00:41:37,330 --> 00:41:40,980
exposed a proprietor api to their internal data structures. 
类似于ims如何将所有者api暴露给他们的内部数据结构

918
00:41:43,150 --> 00:41:48,480
So now sequel is supposed to be a standard course for basic queries. 
所以现在Sequel应该是基本查询的标准课程

919
00:41:48,730 --> 00:41:50,640
You can easily switch them from monday to such another. 
你可以很容易地把它们从星期一换到另一个星期一

920
00:41:52,300 --> 00:41:54,210
Every bidder has the realm of proprietary extensions. 
每个投标人都拥有专有扩展领域

921
00:41:54,750 --> 00:41:55,810
So even though there is a standard, 
所以即使有一个标准

922
00:41:57,910 --> 00:41:58,430
it isn't, 
不是的

923
00:42:00,350 --> 00:42:02,340
there isn't a universal standard that everyone follows. 
没有一个人人都遵守的通用标准

924
00:42:04,200 --> 00:42:06,690
So you can make the same argument about sequel today. 
所以你今天可以对续集提出同样的论点

925
00:42:07,210 --> 00:42:08,650
Or m's hide a lot of this. 
或者我隐瞒了很多

926
00:42:12,140 --> 00:42:12,760
Here's what it looks like. 
这是它的样子

927
00:42:12,890 --> 00:42:13,200
Say. 
说

928
00:42:13,210 --> 00:42:15,240
We have a application code. 
我们有一个应用代码

929
00:42:15,250 --> 00:42:16,680
We want to store student information. 
我们想要存储学生信息

930
00:42:17,240 --> 00:42:20,150
The student has an ida name, an email address,
学生有一个ida名称 一个电子邮件地址

931
00:42:20,600 --> 00:42:22,930
and then a potential list of phone numbers. 
然后是一个可能的电话号码列表

932
00:42:24,340 --> 00:42:27,690
The way you would represent potentially represent this
在纯关系模型中

933
00:42:28,340 --> 00:42:29,730
in a pure relational model, 
即只有标量值的情况下

934
00:42:30,350 --> 00:42:32,080
meaning where there's only scalar values. 
您可能会表示这种方式

935
00:42:32,350 --> 00:42:35,320
You'd have to have a student table, 
你必须有一张学生桌

936
00:42:35,640 --> 00:42:37,030
and then a student phone table. 
然后是一张学生电话桌

937
00:42:38,700 --> 00:42:40,610
So that now, if I want in my programming language,
所以现在 如果我想在我的编程语言中

938
00:42:40,620 --> 00:42:42,210
if I want to instantiate this object, 
如果我想实例化这个对象

939
00:42:42,850 --> 00:42:48,860
I would have to do a look up where I either first query the the student
我必须做一个查找 我要么首先查询学生 然后进行第二次查询

940
00:42:48,870 --> 00:42:50,460
and then do a second query to go get all the phone
以获得所有的电话号码

941
00:42:50,470 --> 00:42:53,610
numbers or do a join and then make sure I throw
或者做一个连接

942
00:42:53,620 --> 00:42:56,730
away the the redundant student information. 
然后确保我扔掉多余的学生信息

943
00:42:56,900 --> 00:42:58,170
I when I give the result back. 
当我给回结果的时候

944
00:43:00,350 --> 00:43:02,860
Again, the object oriented basis guy would say this is stupid,
再次 面向对象的基础家伙会说这是愚蠢的

945
00:43:02,870 --> 00:43:03,620
object oriented. 
面向对象的

946
00:43:03,630 --> 00:43:04,700
People say this is stupid. 
人们说这很愚蠢

947
00:43:05,240 --> 00:43:10,840
Just store the the nested objects together in a single record. 
只需将嵌套对象一起存储在单个记录中

948
00:43:11,360 --> 00:43:15,310
And now it's only one fetch to the davis as one read call to go bring
现在 只需对davis进行一次fetch

949
00:43:15,320 --> 00:43:15,910
this data in. 
就像进行一次read调用以将此数据带入一样

950
00:43:18,940 --> 00:43:20,190
So the problem with this, though,
问题是

951
00:43:20,200 --> 00:43:22,970
is for a simple example, 
对于一个简单的例子 有一个1对1的通信程序

952
00:43:22,980 --> 00:43:24,650
there's like a 1 to 1 correspondence routine, 
一个学生的电话号码

953
00:43:25,150 --> 00:43:28,340
a student phone number, and the student sure this is probably fine.
学生确定这可能是好的

954
00:43:29,040 --> 00:43:29,400
In fact, 
事实上

955
00:43:29,970 --> 00:43:31,440
in modern relations data systems, 
在现代关系数据系统中

956
00:43:31,450 --> 00:43:33,400
you could store the phone number as an array of strings. 
您可以将电话号码存储为字符串数组

957
00:43:34,230 --> 00:43:35,440
Most systems will support that. 
大多数系统都支持这一点

958
00:43:36,440 --> 00:43:39,570
The trouble is now when you go back to that part supplier issue, 
现在的问题是 当您回到零件供应商问题时

959
00:43:39,580 --> 00:43:45,540
if you now start embedding or de normalizing the all the parts
如果您现在开始嵌入或取消标准化供应商提供的所有零件

960
00:43:45,550 --> 00:43:48,380
that a supplier supplies and put them into the supplier record, 
并将其放入供应商记录中

961
00:43:49,000 --> 00:43:49,710
then I have that problem. 
那么我就会遇到这个问题

962
00:43:49,720 --> 00:43:50,790
Or if I need an updated field, 
或者如果我需要更新的字段

963
00:43:50,800 --> 00:43:51,990
I have duplicate information. 
我有重复的信息

964
00:43:52,330 --> 00:43:54,720
My application code needs to make sure all that's in sync. 
我的应用程序代码需要确保所有的同步

965
00:43:55,620 --> 00:43:59,050
I I I don't update some of the records, but not all of them.
我不更新一些记录 但不是全部

966
00:44:01,650 --> 00:44:02,880
Doing complex joins, 
执行复杂连接

967
00:44:03,890 --> 00:44:06,340
make sure you have data integrity, 
确保数据完整性

968
00:44:06,780 --> 00:44:09,290
becomes problematic in in this approach. 
在这种方法中是有问题的

969
00:44:10,180 --> 00:44:12,150
And i'm saying there's some cases where you do want to store jason. 
我要说的是 在某些情况下 你确实想要存储Jason

970
00:44:12,160 --> 00:44:12,710
And again, 
再一次

971
00:44:12,720 --> 00:44:15,600
there are progress other day systems that will have a jason type. 
有一些进步 其他的白天系统将会有一个贾森类型

972
00:44:16,690 --> 00:44:22,840
And the the methods to store jason data in a binary form
以及以二进制形式高效存储贾森数据（而不仅仅是文本）的

973
00:44:22,850 --> 00:44:24,200
efficiently instead of just text. 
方法

974
00:44:26,470 --> 00:44:29,380
Mogadi does this, they have their own base on data type.
Mogadi做到了这一点 他们有自己的数据类型基础

975
00:44:29,890 --> 00:44:30,980
Postcards have something similar. 
明信片也有类似的东西

976
00:44:32,430 --> 00:44:35,420
Again, a lot of the ideas that were done in these specialized systems.
同样 很多想法都是在这些专门的系统中完成的

977
00:44:35,430 --> 00:44:40,090
So these non relational systems have now found their way into relational systems. 
所以这些非关系系统现在已经找到了进入关系系统的方法

978
00:44:43,380 --> 00:44:43,680
All right. 
好吧

979
00:44:43,980 --> 00:44:47,090
Then the 1990s I called the boring days, 
然后

980
00:44:47,810 --> 00:44:52,870
there wasn't any sort of radical change to the harvard landscape
在我称之为“无聊的日子”的20世纪90年代

981
00:44:52,880 --> 00:44:54,470
or the workload landscape. 
哈佛的格局或工作量格局没有任何根本性的变化

982
00:44:55,070 --> 00:44:55,180
Right? 
对的

983
00:44:55,190 --> 00:44:59,270
There wasn't it wasn't like the advent of the cloud or or microcomputers
它不像20世纪80年代出现的云或微型计算机

984
00:44:59,280 --> 00:45:00,110
in the 1980s, 
就像事情正在发生

985
00:45:00,120 --> 00:45:02,680
which is like things are going along, things are getting better.
事情正在变得更好

986
00:45:03,160 --> 00:45:05,230
Harbor is getting better, the data sets are getting bigger,
港湾正在变得更好

987
00:45:05,680 --> 00:45:08,750
but it wasn't dramatic change. 
数据集正在变得更大 但这并不是戏剧性的变化

988
00:45:10,360 --> 00:45:10,700
Right? 
对的

989
00:45:11,390 --> 00:45:13,560
So I think the sort of four major events would be
所以我认为四个主要事件

990
00:45:14,040 --> 00:45:18,780
microsoft bought aa copy or license to the sigh of a source code, 
是微软购买了一个源代码的副本或许可证

991
00:45:19,190 --> 00:45:20,940
forks it, and then they create sql server.
然后创建了sql server

992
00:45:22,050 --> 00:45:23,560
Segal server supports t sequel, 
Segal服务器支持T Sequel

993
00:45:23,990 --> 00:45:26,110
which is their variance sequel that comes from side base, 
这是来自Side Base的变体Sequel

994
00:45:26,120 --> 00:45:27,350
side base invented t sequel. 
Side Base发明了T Sequel

995
00:45:28,180 --> 00:45:29,130
At this point again, 
在这一点上

996
00:45:29,140 --> 00:45:31,530
segal server is state of the art side base is in maintenance mode. 
西格尔服务器是最先进的 基地是在维护模式

997
00:45:32,480 --> 00:45:34,070
I don't know how much of the original sideways code is
我不知道有多少原始的sideways代码

998
00:45:34,080 --> 00:45:35,470
still a sequel celebrity these days. 
仍然是这些天的续集名人

999
00:45:35,480 --> 00:45:37,550
They did major rewrites in 2000. 
他们在2000年进行了重大重写

1000
00:45:38,530 --> 00:45:41,760
They did major rereads in 1998 and in 2006. 
他们在1998年和2006年进行了大量重读

1001
00:45:43,370 --> 00:45:47,650
My sequel sort of get there's a guy in these finland
我的续集有点像芬兰的一个人开始重写或开始编写

1002
00:45:48,040 --> 00:45:51,240
started rewriting or started writing his own data system to replace
自己的数据系统来取代m sequel

1003
00:45:51,250 --> 00:45:52,720
m sequel and called it my sequel. 
并称其为我的续集

1004
00:45:53,300 --> 00:45:54,670
My is the name of his daughter. 
我是他女儿的名字

1005
00:45:56,030 --> 00:45:58,420
He also did marie db that's his other daughter. 
他还做了玛丽DB 那是他的另一个女儿

1006
00:45:58,920 --> 00:46:01,550
Then a a he has a son named max, 
然后他有一个儿子叫马克斯

1007
00:46:01,560 --> 00:46:04,310
and there is max db like he names all his davis after his kids. 
还有马克斯db 就像他用他的孩子的名字给他所有的戴维斯命名一样

1008
00:46:05,420 --> 00:46:07,740
Postgres get recently started as an academic project. 
Postgres最近开始作为一个学术项目

1009
00:46:08,260 --> 00:46:11,310
Strawburger loved quell in the 1980s when they first started writing it. 
在20世纪80年代 当他们第一次开始写这本书的时候 斯特劳伯格很喜欢奎尔

1010
00:46:12,090 --> 00:46:13,280
It was used 12. 
它被用了12次

1011
00:46:14,350 --> 00:46:15,830
But then in 95, 
但在95

1012
00:46:15,840 --> 00:46:18,750
90 62 grad students took the original academic source code, 
9062名研究生采用了原始的学术源代码

1013
00:46:19,370 --> 00:46:21,850
and then convert it to make it actually support sql. 
然后对其进行转换 使其真正支持sql

1014
00:46:22,350 --> 00:46:26,350
And that's why it's called progress ql they might know what
这就是为什么它被称为Progress QL

1015
00:46:26,360 --> 00:46:29,640
the original programming language process was written in the 1980s. 
他们可能知道最初的编程语言Process是在20世纪80年代编写的

1016
00:46:29,650 --> 00:46:32,710
Let me take a guess. 
让我猜一下

1017
00:46:34,010 --> 00:46:34,490
This is cobalt. 
这是钴

1018
00:46:34,500 --> 00:46:34,730
No. 
不

1019
00:46:37,570 --> 00:46:38,260
Abby can close it. 
艾比可以关上它

1020
00:46:40,170 --> 00:46:45,120
Did you take a lisp? 
你口齿不清吗

1021
00:46:48,550 --> 00:46:49,550
It was the 80s, right?
那是80年代 对吧

1022
00:46:49,600 --> 00:46:50,550
Cocaine or whatever like. 
可卡因之类的

1023
00:46:52,060 --> 00:46:53,530
And then they realized that was a bad idea. 
然后他们意识到这是个坏主意

1024
00:46:53,540 --> 00:46:58,020
So then they had a compiler convert the lisp into c and compile that. 
然后他们让一个编译器将Lisp转换成C并编译它

1025
00:46:58,030 --> 00:46:58,980
And then that was a bad idea. 
那是个坏主意

1026
00:46:59,110 --> 00:47:04,330
They rewrote everything in c and then sequel light started early 2000. 
他们用C语言重写了所有的东西 然后在2000年初开始了续集之光

1027
00:47:04,600 --> 00:47:07,190
It's one dude invented this down in north carolina, 
这是北卡罗来纳州的一个家伙发明的

1028
00:47:07,690 --> 00:47:08,230
richard hip. 
他叫理查德·希普

1029
00:47:09,070 --> 00:47:10,460
He still looked the main program on the senate. 
他仍然关注参议院的主要计划

1030
00:47:11,280 --> 00:47:12,500
The one thing that did change, 
我想说的是

1031
00:47:12,510 --> 00:47:14,420
I would say, was not a dramatic change,
有一件事确实发生了变化

1032
00:47:14,430 --> 00:47:16,390
is that people started to realize, 
但并不是戏剧性的变化

1033
00:47:16,720 --> 00:47:20,850
I don't just want to use my data system to transactions and ingest new data. 
那就是人们开始意识到 我不想只是使用我的数据系统来处理和接收新数据

1034
00:47:21,220 --> 00:47:22,890
Someone want to start doing analytics, 
有人想开始做分析

1035
00:47:22,900 --> 00:47:26,170
start extrapolate new information business. 
开始推断新的信息业务

1036
00:47:26,180 --> 00:47:28,770
Intelligent decision support has a bunch of different names. 
智能决策支持有很多不同的名称

1037
00:47:30,240 --> 00:47:32,230
All these systems at the time are all row stores. 
当时所有这些系统都是行存储

1038
00:47:33,230 --> 00:47:33,970
And as we know, 
正如我们所知

1039
00:47:33,980 --> 00:47:37,130
running analytical queries on a row store is highly inefficient. 
在行存储上运行分析查询的效率非常低

1040
00:47:38,070 --> 00:47:42,550
There was this optimization technique called data cubes where you
有一种叫做数据立方体的优化技术

1041
00:47:42,560 --> 00:47:44,470
basically figure like materialized view, 
你基本上就像物化视图一样

1042
00:47:44,750 --> 00:47:46,990
where you pre computed these multi conventional arrays
你预先计算这些不同

1043
00:47:47,980 --> 00:47:51,600
of different group i's and aggregation and so forth. 
组的多个常规阵列和聚合等等

1044
00:47:51,950 --> 00:47:53,910
And you would pre compete and you run your analytics on those. 
你会在比赛前运行你的分析

1045
00:47:54,800 --> 00:47:58,700
Nobody uses data cubes today because column stores so much faster. 
现在没有人使用数据立方体 因为列存储的速度要快得多

1046
00:47:59,130 --> 00:48:01,730
But this is how people got by in the 1990s. 
但这就是上世纪90年代人们的生活方式

1047
00:48:04,260 --> 00:48:05,370
So the big game changer, though,
因此

1048
00:48:05,380 --> 00:48:07,910
was in 2000s when the internet comes along. 
最大的游戏规则改变者是2000年代互联网的出现

1049
00:48:09,120 --> 00:48:10,790
So again, prior to this,
所以 在此之前

1050
00:48:10,800 --> 00:48:12,590
when you think about it who had big databases, 
当你想到谁拥有大数据库时

1051
00:48:13,790 --> 00:48:16,030
the big bangs, walmart's, right?
大爆炸 沃尔玛 对吧

1052
00:48:16,040 --> 00:48:19,800
The only like the fortune 500 companies had big data as problems. 
只有财富500强公司才有大数据问题

1053
00:48:20,880 --> 00:48:22,160
But when the internet comes along, 
但当互联网出现时

1054
00:48:23,730 --> 00:48:26,430
it doesn't take that much for a small number of people to put something
一小部分人把东西放到互联网上

1055
00:48:26,440 --> 00:48:29,900
on the internet and have a lot of people start using the application
让很多人开始使用网站的应用程序

1056
00:48:29,910 --> 00:48:30,500
of the website. 
这并不需要太多时间

1057
00:48:31,010 --> 00:48:33,470
And you start generating a lot of traffic and a lot of data, 
你开始产生大量的流量和数据

1058
00:48:33,480 --> 00:48:34,270
a lot of users. 
大量的用户

1059
00:48:35,430 --> 00:48:35,840
Right? 
对的

1060
00:48:36,860 --> 00:48:40,800
So this was a big change in how people approach databases in the 2000. 
所以这是2000年人们如何处理数据库的一个巨大变化

1061
00:48:42,470 --> 00:48:43,340
But at the time, 
但在当时

1062
00:48:43,350 --> 00:48:46,970
all of the sort of the commercial enterprise databases were very heavyweight, 
所有的商业企业数据库都是重量级的 比如oracle

1063
00:48:47,800 --> 00:48:50,750
oracle, db two, cyprus, they were very expensive.
db two cyprus 它们都非常昂贵

1064
00:48:52,710 --> 00:48:54,950
And then the open source databases that we think about today, 
然后我们今天想到的开源数据库

1065
00:48:55,340 --> 00:48:56,820
postcards and my sql, 
明信片和我的SQL

1066
00:48:57,300 --> 00:48:58,730
they were pretty primitive back in the day. 
它们在过去是非常原始的

1067
00:48:59,900 --> 00:49:04,360
My sequel to support transactions until inter db came along, 
我的续篇支持事务

1068
00:49:05,090 --> 00:49:06,360
2003 2004. 
直到2003年和2004年Inter DB出现

1069
00:49:07,890 --> 00:49:11,550
So what people ended up doing was writing out their own sort
因此

1070
00:49:11,560 --> 00:49:16,500
of custom middleware to route queries to these single node database
人们最终要做的是编写自己的自定义中间件

1071
00:49:16,510 --> 00:49:16,780
indices. 
将查询路由到这些单节点数据库索引

1072
00:49:17,350 --> 00:49:20,040
So they would sort of treat my sql as like a dumb key value store, 
所以他们会把我的SQL当作一个哑键值存储

1073
00:49:20,630 --> 00:49:24,200
and then have something in front of it to route queries to different shards
然后在它前面有一些东西来将查询路由到不同的碎片

1074
00:49:24,210 --> 00:49:27,410
that the idea is still widely used today, 
这个想法至今仍被广泛使用

1075
00:49:27,420 --> 00:49:29,730
but the people were wrong on their own back. 
但人们自己错了

1076
00:49:29,740 --> 00:49:29,970
Then. 
然后

1077
00:49:29,980 --> 00:49:33,290
The other thing that happened was, 
发生的另一件事是

1078
00:49:33,550 --> 00:49:34,100
again, as I say,
正如我所说的

1079
00:49:34,110 --> 00:49:36,260
it doesn't take that much to start collecting a lot of data. 
开始收集大量数据并不需要那么多时间

1080
00:49:36,730 --> 00:49:38,860
More people started wanting to analyze this data. 
更多的人开始想要分析这些数据

1081
00:49:39,780 --> 00:49:43,350
Then we realize or they realize that the sort
然后我们意识到

1082
00:49:43,360 --> 00:49:46,600
of general purpose data systems at a row store that tries to do
或者他们意识到

1083
00:49:47,030 --> 00:49:47,650
transactions and analytics. 
行存储中的通用数据系统试图进行交易和分析

1084
00:49:48,120 --> 00:49:48,900
Was that bad idea? 
这是个坏主意吗

1085
00:49:48,910 --> 00:49:51,960
And people started building these custom analytical data systems, 
人们开始建立这些定制的分析数据系统

1086
00:49:52,450 --> 00:49:52,800
which again, 


1087
00:49:52,810 --> 00:49:57,150
will be the the sort of key idea that we're focusing on this semester. 
这也将是我们这学期关注的关键思想

1088
00:49:58,120 --> 00:50:00,460
A lot of these were distributed and shared nothing of us. 
其中很多都是分发的 我们没有分享任何东西

1089
00:50:00,470 --> 00:50:02,220
All of these were going to be actually all
所有这些实际上都是关系和SQL

1090
00:50:02,230 --> 00:50:07,600
of these were relational and sql most of them are forks of post graphs. 
其中大多数都是POST图的分支

1091
00:50:09,210 --> 00:50:13,670
And they're going to store the database as column stores. 
他们将把数据库存储为列存储

1092
00:50:14,580 --> 00:50:16,660
Again, seems like an obvious idea now.
再一次 现在似乎是一个显而易见的想法

1093
00:50:17,340 --> 00:50:19,870
And because the wind you get from are so significant, 
因为你得到的风是如此重要

1094
00:50:20,420 --> 00:50:21,630
back then this was unheard of, 
这在当时是闻所未闻的

1095
00:50:22,030 --> 00:50:23,770
It's not unheard of it, because the ideas from the 70s,
这不是闻所未闻的

1096
00:50:23,780 --> 00:50:26,000
but like having these explicitly stored, 
因为70年代的想法

1097
00:50:26,010 --> 00:50:28,080
the ideas columns that was novel, 
但就像这些明确存储的想法专栏是新颖的

1098
00:50:28,970 --> 00:50:29,810
that was a game changer. 
这是游戏规则的改变者

1099
00:50:31,540 --> 00:50:35,630
So the sort of the main systems at this time are listed here. 
所以这里列出了目前主要系统的种类

1100
00:50:35,970 --> 00:50:37,620
So natzisa was a fork a postgrasse, 
因此 natzisa是postgrasse的一个分支

1101
00:50:37,630 --> 00:50:42,280
but they put a fpga down to the storage layer to make it run filters faster. 
但他们将fpga放到存储层 使其更快地运行滤波器

1102
00:50:43,170 --> 00:50:44,480
Park sells a fork of postcards, 
帕克出售一大堆明信片

1103
00:50:44,490 --> 00:50:45,640
distributed version postgres. 
分发版Postgres

1104
00:50:46,590 --> 00:50:48,390
This is actually what redshift is redshift. 
这就是所谓的红移

1105
00:50:48,400 --> 00:50:50,230
They bought a license to park cell. 
他们买了停车许可证

1106
00:50:50,870 --> 00:50:53,570
Didn't really make any changes, just slapped it up and called it redshift.
并没有真正做任何改变 只是把它拍起来 并称之为红移

1107
00:50:54,580 --> 00:50:58,400
Was that this is not a secret. 
这不是秘密

1108
00:50:58,410 --> 00:50:59,720
I was telling you, all right, this is public.
我告诉你 好吧 这是公开的

1109
00:51:01,720 --> 00:51:03,090
And so just threw it up. 
所以就吐了出来

1110
00:51:03,570 --> 00:51:04,410
It made so much money. 
它赚了这么多钱

1111
00:51:04,740 --> 00:51:06,130
Now we've got to start making this real. 
现在我们必须开始让这一切成为现实

1112
00:51:07,250 --> 00:51:07,420
Right? 
对的

1113
00:51:07,430 --> 00:51:11,040
And it's been written many times over vertica. 
它在Vertica上被写了很多次

1114
00:51:11,050 --> 00:51:13,240
That's a company that started by my advisers, 
这是一家由我的顾问迈克·斯

1115
00:51:13,250 --> 00:51:15,820
mike stone breaker, and then santa zonatic.
通·布雷克和圣佐纳蒂克创办的公司

1116
00:51:15,830 --> 00:51:17,180
That's a fork, a postgres.
那是一把叉子 一把叉子

1117
00:51:17,720 --> 00:51:20,540
Data leg row was a shorter version of ingress. 
Data Leg Row是Ingress的较短版本

1118
00:51:20,550 --> 00:51:24,130
And the green plum is a fork and postgres mode adb was
青梅是一个叉子

1119
00:51:24,140 --> 00:51:26,130
exactly the other one here that was written from scratch. 
而Postgres模式ADB正是另一个从零开始编写的模式

1120
00:51:27,190 --> 00:51:28,700
And that came out of cwi the same. 
从CWI出来的也是一样

1121
00:51:28,710 --> 00:51:33,490
Have you ever heard of ducky b it's the same research group that made
你听说过ducky b吗 它是制作mode adb.

1122
00:51:33,500 --> 00:51:36,490
mode adb dot db was originally called mode db light. 
db的同一个研究小组 最初被称为mode db light

1123
00:51:36,500 --> 00:51:40,740
It was a fork mode db to run embedded in like our programs. 
这是一个分叉模式的数据库 可以像我们的程序一样嵌入运行

1124
00:51:41,250 --> 00:51:46,850
And then they rewrote it and ended up being doug db i'm not sure I
然后他们重写了它 最后变成了道格db

1125
00:51:46,860 --> 00:51:47,750
may have to bleed this. 
我不确定我可能要流这个血

1126
00:51:47,760 --> 00:51:48,590
I'm not sure this is public. 
我不确定这是公开的

1127
00:51:49,220 --> 00:51:51,570
Microsoft bought data, microsoft bought data, leg grow,
微软买了数据 微软买了数据 leg grow

1128
00:51:51,580 --> 00:51:53,510
ibm bought the teaser park sell. 
ibm买了teaser park sell

1129
00:51:53,520 --> 00:51:54,830
They can never get bought that. 
他们永远不会被收买

1130
00:51:54,840 --> 00:51:56,150
He's got and i'm getting licensed. 
他有 我也有执照

1131
00:51:56,160 --> 00:52:00,630
I think the company's dead vertica got acquired by hp any of you
我认为公司的死亡vertica被惠普收购了

1132
00:52:00,640 --> 00:52:02,990
got never bought and then green palm got bought by
你们中的任何一个都没有被收购 然后green palm被收购了

1133
00:52:04,940 --> 00:52:10,290
no emc hold on. 
没有EMC 请稍候

1134
00:52:11,920 --> 00:52:14,630
At some point, there were miemc it's hard to keep track of this.
在某种程度上 有miemc很难跟踪这一点

1135
00:52:15,670 --> 00:52:16,400
They got bought. 
他们被收买了

1136
00:52:18,070 --> 00:52:21,220
And then they divested it off to an emc in order to take back. 
然后他们将其剥离给EMC 以便收回

1137
00:52:21,510 --> 00:52:23,570
Emc had a database piece. 
EMC有一个数据库部分

1138
00:52:24,310 --> 00:52:25,400
Vmr had a database piece. 
VMR有一个数据库片段

1139
00:52:25,740 --> 00:52:27,900
They took it out, and they formed a new company called pivotal.
他们把它拿出来 成立了一家名为Pivotal的新公司

1140
00:52:29,420 --> 00:52:33,250
It was green palm and then sequel fire or gem fire, 
它是绿色棕榈 然后是续集火或宝石火

1141
00:52:35,290 --> 00:52:37,870
which I think that notes emc bought them, 
我认为注意到EMC购买了它们

1142
00:52:37,880 --> 00:52:39,150
vm ware bought sql file. 
VM Ware购买了SQL文件

1143
00:52:39,900 --> 00:52:41,270
They took them out, made pivotal,
他们把它们拿出来

1144
00:52:41,280 --> 00:52:42,880
and then bmr bought pivotal. 
做了pivotal 然后bmr收购了pivotal

1145
00:52:44,110 --> 00:52:49,920
It's so data leg row got up with microsoft. 
所以数据腿排和微软站在了一起

1146
00:52:50,360 --> 00:52:53,180
It was a hacked up version of charted ingress. 
这是海图入口的一个破解版本

1147
00:52:54,130 --> 00:52:55,950
And I think they paid money for it. 
我想他们为此付了钱

1148
00:52:56,270 --> 00:52:57,400
And then after they bought it, 
然后在他们买了它之后

1149
00:52:57,410 --> 00:52:58,780
so after they wrote the check, 
所以在他们写了支票之后

1150
00:52:59,310 --> 00:53:01,660
then they had their technical people actually look at it and say this is
他们让他们的技术人员看了看

1151
00:53:01,670 --> 00:53:02,100
all crap. 
然后说这都是废话

1152
00:53:02,110 --> 00:53:03,860
We can't use any of this and they threw it all away. 
我们不能用这些东西 他们把它们都扔了

1153
00:53:05,140 --> 00:53:08,170
They made them they end up running the sequel server data warehouse
他们最终从头开始运行Sequel服务器数据仓库

1154
00:53:08,940 --> 00:53:10,760
from scratch the parallel data warehouse instead of using any
并行数据仓库

1155
00:53:10,770 --> 00:53:11,240
of these garbage. 
而不是使用这些垃圾

1156
00:53:13,270 --> 00:53:13,930
There's another one too. 
还有一个

1157
00:53:14,060 --> 00:53:16,450
I'm missing astor data they were bought by. 
我错过了他们购买的阿斯特数据

1158
00:53:17,950 --> 00:53:19,540
They were bought, I think by terror data.
我想他们是被恐怖数据收买的

1159
00:53:26,820 --> 00:53:30,780
The while all this work is happening on these parallel column store data warehouses, 
虽然所有这些工作都是在这些并行列存储数据仓库上进行的

1160
00:53:31,680 --> 00:53:35,580
there was this other big trend of these matte reduced systems. 
但还有另一个大趋势 即这些减少了遮罩的系统

1161
00:53:36,320 --> 00:53:36,570
Again, 
再一次

1162
00:53:36,580 --> 00:53:39,290
so what it's been 10 years now since the object ordinary databases were
自从普通数据库的对象是一个坏主意以来

1163
00:53:39,300 --> 00:53:40,050
a bad idea, 
已经过去了10年

1164
00:53:40,660 --> 00:53:43,850
now we're 10 years later, so this thing comes along from google.
现在我们已经10年了 所以这个东西来自谷歌

1165
00:53:45,890 --> 00:53:48,200
They built a custom execution engine with this map, 
他们用这个地图建立了一个自定义的执行引擎

1166
00:53:48,210 --> 00:53:53,320
reduce programming model that to help them crawl their to build the index
减少了编程模型

1167
00:53:53,330 --> 00:53:54,080
for the web crawl. 
以帮助他们抓取他们的建立索引的网页抓取

1168
00:53:54,880 --> 00:53:57,810
And they end up using for a bunch of other data processing tasks
他们最终将其用于其他数据处理任务或分析

1169
00:53:57,820 --> 00:53:58,440
or analytical tasks. 
任务

1170
00:53:59,430 --> 00:54:00,720
So google put out the paper, 
所以谷歌发布了这篇论文 说

1171
00:54:01,040 --> 00:54:02,350
say, hey, that's what we're using.
嘿 这就是我们正在使用的

1172
00:54:03,490 --> 00:54:04,620
The pi still happens now, 
PI现在仍在发生

1173
00:54:04,630 --> 00:54:08,860
but google was really the super hot thing in the 2000s. 
但谷歌在2000年代确实是超级热门的东西

1174
00:54:09,360 --> 00:54:09,470
Right? 
对的

1175
00:54:10,000 --> 00:54:11,990
Anything they did, any paper they put out,
他们所做的任何事情 他们发表的任何论文

1176
00:54:12,000 --> 00:54:13,750
people did end up go and re implement themselves, 
人们最终都会去重新实现自己

1177
00:54:13,760 --> 00:54:15,510
because they thought google is making a ton of money, 
因为他们认为谷歌赚了一大笔钱

1178
00:54:16,110 --> 00:54:17,230
because they have all these custom systems. 
因为他们拥有所有这些定制系统

1179
00:54:17,240 --> 00:54:18,830
Let's go build our own custom system too. 
让我们也去建立我们自己的自定义系统

1180
00:54:19,500 --> 00:54:19,750
Right? 
对的

1181
00:54:20,460 --> 00:54:22,830
Like h base is a clone a big table, 
就像H Base是一个大表的克隆

1182
00:54:23,220 --> 00:54:29,830
cause cassandra is a clone a big table and dynamo db that's the acfs dude
因为Cassandra是一个大表的克隆

1183
00:54:29,840 --> 00:54:32,550
was the clone of matt reduce. 
而Dynamo DB是ACFS的Dude是Matt Reduce的克隆

1184
00:54:34,030 --> 00:54:36,990
So google put that map reduce paper. 
所以谷歌把地图减少了纸

1185
00:54:37,550 --> 00:54:39,540
Yahoo says, see, that says a good idea.
雅虎说 看 这是个好主意

1186
00:54:39,550 --> 00:54:40,420
We can use it too. 
我们也可以用它

1187
00:54:40,810 --> 00:54:43,050
They wrote their own open source version called duke. 
他们编写了自己的开源版本 名为Duke

1188
00:54:44,650 --> 00:54:47,430
And the basic idea was that you'd write these user defined functions
基本的想法是

1189
00:54:47,440 --> 00:54:52,610
like a map and reduce a shuffle phase cover later on next class. 
你可以像写地图一样写这些用户定义的函数 并在下一节课上减少洗牌阶段

1190
00:54:54,720 --> 00:54:57,100
Instead of using a sequel, you'd write these custom functions.
您可以编写这些自定义函数 而不是使用Sequel

1191
00:54:57,110 --> 00:55:00,620
And you just submit them to the davis to the map reduce or do framework
您只需将它们提交给davis 再提交给map reduce或do框架

1192
00:55:00,950 --> 00:55:01,690
and run them for you. 
然后为您运行它们

1193
00:55:03,070 --> 00:55:07,630
It takes us back to the 1970s where the programmer had to define what
它把我们带回了20世纪70年代

1194
00:55:07,640 --> 00:55:09,830
the data model actually was or the data they were processing. 
那时程序员必须定义数据模型或他们正在处理的数据

1195
00:55:10,680 --> 00:55:12,980
There's no sequel at the time of these systems. 
在这些系统的时候没有续集

1196
00:55:13,270 --> 00:55:15,080
You had to literally write all parts, 
你必须从字面上写所有的部分

1197
00:55:15,350 --> 00:55:17,380
the i'm going to parse this csv file, 
我要解析这个CSV文件

1198
00:55:17,390 --> 00:55:18,740
and I expect them to have these columns. 
我希望他们有这些列

1199
00:55:18,750 --> 00:55:23,510
And you would write that explicit citations in your in the program encoder
你可以在这些函数的程序编码器中写下明确的

1200
00:55:23,960 --> 00:55:24,910
in these functions. 
引文

1201
00:55:26,440 --> 00:55:28,500
So this was the hot thing in the late 2000. 
所以这是2000年末的热门话题

1202
00:55:28,510 --> 00:55:29,940
That was like this is the way to do this. 
这就像是这样做的方式

1203
00:55:29,950 --> 00:55:30,540
You ought to add up. 
你应该加起来

1204
00:55:31,720 --> 00:55:32,860
And then stone breaker, 
然后破石者

1205
00:55:32,870 --> 00:55:36,990
and then this other guy who does invented a lot of the first pillow databases, 
然后另一个发明了很多第一个枕头数据库的人 发表了一篇文章

1206
00:55:37,800 --> 00:55:39,520
put out an article that said this is a bad idea. 
说这是一个坏主意

1207
00:55:39,830 --> 00:55:41,930
Then ii wrote a paper at them and showed it was. 
然后我给他们写了一篇论文 证明它是

1208
00:55:43,590 --> 00:55:46,190
And then people eventually realize it, turns out the old guys are right.
然后人们最终意识到这一点 事实证明老家伙们是对的

1209
00:55:46,200 --> 00:55:47,150
This is a bad idea. 
这是个坏主意

1210
00:55:47,820 --> 00:55:50,420
So then they try to put sequel on top of map, 
所以他们试图把续集放在地图上

1211
00:55:50,430 --> 00:55:52,700
reduce facebook invented hive. 
减少Facebook发明的蜂巢

1212
00:55:52,710 --> 00:55:56,490
And there's a thing called map rdb at a map r which I I think they're dead now. 
在地图R上有一个叫做地图RDB的东西 我想他们现在已经死了

1213
00:55:57,660 --> 00:55:59,700
But then it turned out that was super inefficient and super slow, 
但后来发现这是超级低效和超级缓慢的

1214
00:55:59,710 --> 00:56:05,470
because the way just sort of the way her dude was actually implemented, 
因为她的家伙实际上是如何实现的

1215
00:56:05,480 --> 00:56:09,570
or I don't know exactly how the map arts framework actually worked, 
或者我不知道地图艺术框架实际上是如何工作的

1216
00:56:09,580 --> 00:56:13,190
but the way they were sort of storing these checkpoints
但他们在查询的每一个阶段存储这些检查点的

1217
00:56:13,200 --> 00:56:15,310
at every single stage of the query was super inefficient. 
方式是超级低效的

1218
00:56:16,990 --> 00:56:19,200
And so all this got thrown away. 
所以这一切都被抛弃了

1219
00:56:19,210 --> 00:56:20,120
I i've still exists. 
我我仍然存在

1220
00:56:20,130 --> 00:56:23,830
But like people realize a this is actually a bad idea. 
但就像人们意识到这实际上是一个坏主意

1221
00:56:24,810 --> 00:56:27,240
As a you want a parallel to the warehouse, 
因为你想要一个类似于仓库的东西

1222
00:56:27,250 --> 00:56:28,800
you want the thing that we were shown before. 
你想要我们之前看到的东西

1223
00:56:29,920 --> 00:56:31,920
But it again took 10 years for people to realize this. 
但人们又花了10年时间才意识到这一点

1224
00:56:31,930 --> 00:56:32,720
This was a bad idea. 
这是个坏主意

1225
00:56:34,680 --> 00:56:37,050
Also related to, I won't say bad ideas here too,
同样相关的是 我不会在这里说不好的想法

1226
00:56:37,060 --> 00:56:40,620
but there was this no sequel movement again, 
但又有了这个没有续集的运动

1227
00:56:40,630 --> 00:56:45,020
I think brought upon by google and the big table paper basically said, 
我认为是由谷歌带来的

1228
00:56:45,400 --> 00:56:48,390
hey, the the racial model is bad.
大桌子上的纸基本上说 嘿 种族模式是不好的

1229
00:56:48,560 --> 00:56:52,220
The sequel is too slow for modern web application. 
对于现代Web应用程序来说 Sequel太慢了

1230
00:56:53,170 --> 00:56:54,600
We don't need transactions, we don't need joints.
我们不需要交易 我们不需要关节

1231
00:56:55,130 --> 00:56:56,330
We want to build these systems from scratch, 
我们想从头开始建立这些系统

1232
00:56:57,240 --> 00:56:57,280
right? 
对吗

1233
00:56:57,290 --> 00:56:59,630
Because you have to understand like if you're building a website, 
因为您必须了解

1234
00:56:59,640 --> 00:57:06,250
you want to think up 2047 a in a database systems transactions that
如果您正在构建一个网站

1235
00:57:06,260 --> 00:57:07,170
maybe didn't have
您需要在数据库系统事务中考虑2047个事务

1236
00:57:07,990 --> 00:57:11,470
backups or replicas for high availability. 
这些事务可能没有备份或副本以实现高可用性

1237
00:57:12,080 --> 00:57:13,560
That means if no goes down, 
这意味着如果没有宕机

1238
00:57:13,570 --> 00:57:15,980
if your whole website goes down, that's bad, you lose money.
如果你的整个网站宕机 那很糟糕 你会赔钱

1239
00:57:17,950 --> 00:57:19,850
So the no sequel guys facing said, well,
所以没有续集的人说

1240
00:57:20,690 --> 00:57:25,370
maybe you were to let the system maybe have corrupt data
好吧 也许你要让系统可能有损坏的数据

1241
00:57:25,380 --> 00:57:28,690
or not strictly follow transaction semantics, 
或者不严格遵循事务语义

1242
00:57:28,700 --> 00:57:31,910
transport in exchange for always being up, always being online.
传输以换取始终启动 始终在线

1243
00:57:31,920 --> 00:57:35,110
So there's a bunch of these systems that got built. 
所以有很多这样的系统被建造出来

1244
00:57:35,470 --> 00:57:36,540
Under this model, 
在这种模式下

1245
00:57:36,550 --> 00:57:39,540
some things sometimes is dynamite. 
有些事情有时是爆炸性的

1246
00:57:39,550 --> 00:57:41,500
Db was built by amazon for the shopping cart. 
DB是亚马逊为购物车打造的

1247
00:57:42,950 --> 00:57:45,060
If I put some in my shopping cart, it maybe disappears.
如果我把一些放进购物车 它可能会消失

1248
00:57:45,070 --> 00:57:46,960
This is the end of the world, 
这是世界末日

1249
00:57:48,090 --> 00:57:48,540
probably not. 
可能不会

1250
00:57:49,720 --> 00:57:52,520
If I put something in my bank account and disappears, that's a big problem.
如果我在银行账户里存了钱 然后消失了 那就是个大问题

1251
00:57:53,050 --> 00:57:53,400
Right? 
对的

1252
00:57:54,150 --> 00:57:58,180
So all these systems basically follow different looser semantics over what
因此 所有这些系统基本上都遵循不同的松散语义

1253
00:57:58,190 --> 00:58:01,390
the traditional relational transaction, 
而传统的关系事务

1254
00:58:01,400 --> 00:58:05,930
strongly consistent daily systems would follow to varying degrees of success. 
强一致性日常系统则遵循不同的成功程度

1255
00:58:06,830 --> 00:58:07,860
And as I said before, 
正如我之前所说

1256
00:58:07,870 --> 00:58:10,890
basically everybody supports segal now, except for retis,
现在基本上每个人都支持segal 除了retis

1257
00:58:11,540 --> 00:58:14,730
I think raven db they all have their own version of sql
我认为raven db他们都有自己的sql版本 但它基本上是sql

1258
00:58:14,740 --> 00:58:19,120
but it's basically sql without wanting to say it react as dead. 
不想说它的反应是死的

1259
00:58:19,130 --> 00:58:22,730
So there I don't I don't think we have any and then oracle new sequel I
所以 我不认为我们有任何

1260
00:58:22,740 --> 00:58:28,850
think it's just perfectly to be under the covers at the same time. 
然后甲骨文新的续集 我认为这是完美的 在同一时间被掩盖

1261
00:58:28,860 --> 00:58:32,530
All right, so soon after the no sequel databases got popular,
好吧 在“无续集”数据库流行后不久

1262
00:58:33,060 --> 00:58:34,460
there was another movement called new sequel. 
就出现了另一个运动 叫做“新续集”

1263
00:58:34,470 --> 00:58:38,740
This one I was involved in where the idea was that you wouldn't have
我参与的这个项目的想法是

1264
00:58:38,750 --> 00:58:42,160
the same high scalability and performance of a no sql database system. 
您不会拥有与无SQL数据库系统相同的高可伸缩性和性能

1265
00:58:42,620 --> 00:58:44,010
But without giving up transactions, 
但在不放弃交易的情况下

1266
00:58:45,560 --> 00:58:47,010
obviously, you can't,
显然 你不能

1267
00:58:49,440 --> 00:58:50,750
you can't go faster than the speed of light. 
你不可能超过光速

1268
00:58:50,760 --> 00:58:53,150
So if you have machines in different areas of the world, 
因此 如果你在世界的不同地区都有机器

1269
00:58:53,370 --> 00:58:54,610
you can't make that go faster, 
你不能让它运行得更快

1270
00:58:55,070 --> 00:58:56,550
but you at least make sure that things are correct. 
但你至少要确保事情是正确的

1271
00:58:57,990 --> 00:59:01,550
So all the systems that came out under this no segal movement, 
因此 除了odb map c之外 所有在“无Segal ”

1272
00:59:01,990 --> 00:59:06,930
with maybe the exception of of odb map c will get renamed to a sequel store, 
运动下推出的系统都将重命名为sequel store

1273
00:59:06,940 --> 00:59:09,850
and they wouldn't necessarily call themselves a new sql system now. 
并且它们现在不一定会称自己为新的sql系统

1274
00:59:10,240 --> 00:59:11,520
And then spanner did detail. 
然后扳手做了细节

1275
00:59:11,530 --> 00:59:12,400
Spanner is still here. 
扳手还在这里

1276
00:59:12,410 --> 00:59:13,360
Spanner is legit. 
扳手是合法的

1277
00:59:13,810 --> 00:59:14,600
But for the most part, 
但在大多数情况下

1278
00:59:14,610 --> 00:59:16,360
bunch of things you've never heard of before the trans lattice, 
在trans lattice之前

1279
00:59:16,370 --> 00:59:20,310
i'm sure nobody's heard of gddb they all pretty much failed. 
你从来没有听说过很多东西 我敢肯定没有人听说过gddb 他们几乎都失败了

1280
00:59:21,610 --> 00:59:23,920
Foundation db had a sequel there that was kind of crap. 
DB基金会在那里有一个续集 那是一种垃圾

1281
00:59:24,530 --> 00:59:26,010
Apple bought down, threw that away.
苹果买下了 扔掉了

1282
00:59:26,410 --> 00:59:27,750
And they since open source it, 
他们已经开源了它

1283
00:59:27,760 --> 00:59:31,990
but it's not used as a relational data system with sequel. 
但它没有被用作Sequel的关系数据系统

1284
00:59:32,000 --> 00:59:32,150
Now. 
现在

1285
00:59:33,110 --> 00:59:34,620
What did happen though? 
但发生了什么

1286
00:59:34,630 --> 00:59:36,740
All a bunch of these systems didn't pan out. 
所有这些系统都没有成功

1287
00:59:37,240 --> 00:59:41,800
The new transaction data systems aren't actually getting some traction, 
新的交易数据系统实际上并没有得到一些牵引力

1288
00:59:41,810 --> 00:59:44,920
and these sort of fall under the umbrella of distributed sequel. 
而这些都属于分布式Sequel的范畴

1289
00:59:45,530 --> 00:59:47,040
Instead of calling new sql was sort of vague, 
而不是调用新的SQL是一种模糊的

1290
00:59:47,050 --> 00:59:48,760
you say it's a derivative sql system. 
你说它是一个衍生的SQL系统

1291
00:59:49,610 --> 00:59:51,440
Tide eb is out of china. 
浪潮EB退出中国

1292
00:59:51,450 --> 00:59:54,960
Cochrane eb is probably raised the most money of all these. 
科克伦EB可能是所有这些中筹集资金最多的

1293
00:59:55,510 --> 00:59:58,590
And then you go by as another startup that's based on postgraduate. 
然后你就变成了另一家基于研究生的创业公司

1294
00:59:58,950 --> 01:00:01,170
The com, db two was built by, I think, bloomberg.
我认为 COM DB Two是由Bloomberg建立的

1295
01:00:01,980 --> 01:00:04,890
I've never heard anybody use the com db two outside of bloomberg, 
我从来没有听说过有人在彭博以外的地方使用com db 2

1296
01:00:05,670 --> 01:00:07,100
but it is absurd, so it doesn't exist.
但这是荒谬的 所以它并不存在

1297
01:00:08,760 --> 01:00:11,870
So the main take away here is that these systems, 
所以这里主要的收获是这些系统

1298
01:00:13,170 --> 01:00:15,520
these systems are going against the conventional wisdom that like you want
这些系统违背了传统智慧

1299
01:00:15,530 --> 01:00:16,160
an original model, 
就像你想要一个原始模型一样

1300
01:00:16,170 --> 01:00:17,520
you want to sequel one in transactions. 
你想要在交易中继续一个

1301
01:00:17,860 --> 01:00:19,330
Because all the new sequel systems are hot. 
因为所有新的续集系统都很热门

1302
01:00:19,880 --> 01:00:23,040
By the time that people realized I do want sequel, I do want transactions,
当人们意识到我确实想要续集时 我确实想要交易

1303
01:00:24,270 --> 01:00:26,780
they failed or didn't pan out. 
他们失败了或者没有成功

1304
01:00:27,100 --> 01:00:29,370
Then these systems were the right place at the right time building
然后这些系统在正确的时间出现在正确的地方

1305
01:00:29,380 --> 01:00:34,600
off the things that the earlier systems had done finishing up. 
建立在早期系统已经完成的东西之上

1306
01:00:34,690 --> 01:00:35,960
We have cloud systems. 
我们有云系统

1307
01:00:36,850 --> 01:00:38,410
Again, we'll cover this a lot throughout the semester.
同样 我们将在整个学期中对此进行大量讨论

1308
01:00:38,850 --> 01:00:41,210
Basically, now the harbor that escape has changed.
基本上 现在逃离的港湾已经改变了

1309
01:00:41,690 --> 01:00:43,210
People are no longer running on pram. 
人们不再在婴儿车上奔跑

1310
01:00:43,860 --> 01:00:45,220
You're now running in a cloud, 
您现在正在云中运行

1311
01:00:46,380 --> 01:00:46,670
right? 
是吧

1312
01:00:46,680 --> 01:00:48,870
And that means your resources can be elastic. 
这意味着你的资源是有弹性的

1313
01:00:48,880 --> 01:00:51,150
You don't have to go through this long provisioning cycle of like, 
您不必经历这种漫长的配置周期

1314
01:00:51,420 --> 01:00:52,670
I want to buy these machines and procurement, 
例如 我想购买这些机器并进行采购

1315
01:00:52,680 --> 01:00:54,270
and it takes a long time to actually get them. 
而实际获得它们需要很长时间

1316
01:00:54,770 --> 01:00:55,360
With a credit card. 
用信用卡

1317
01:00:55,370 --> 01:00:57,000
You can spit up a new instance very, very quickly.
您可以非常快速地创建一个新实例

1318
01:00:58,140 --> 01:01:00,980
So every initially there was a bunch of these databases
所以最初有一堆服务产品或产品的数据库

1319
01:01:00,990 --> 01:01:05,840
of service products or offerings where it would just take
它只会像现成的一样

1320
01:01:05,850 --> 01:01:08,830
like off the shelf I sequel rather than avm for you. 
而不是AVM

1321
01:01:08,840 --> 01:01:10,710
It's before containers rather than avm for you, 
对你来说 这是在集装箱之前 而不是在avm之前

1322
01:01:11,060 --> 01:01:12,000
and they charge you for that. 
他们会向你收费

1323
01:01:12,280 --> 01:01:12,840
But it didn't. 
但它没有

1324
01:01:13,270 --> 01:01:14,990
My sequel wasn't really aware that it's running in the cloud. 
我的续集并没有真正意识到它在云中运行

1325
01:01:15,000 --> 01:01:18,690
It's just running on some vm but since then, 
它只是在一些虚拟机上运行 但从那时起

1326
01:01:18,700 --> 01:01:22,660
there's now assessments designed from scratch explicitly for running a a
现在有从零开始设计的评估

1327
01:01:22,670 --> 01:01:23,700
in a cloud system. 
明确用于在云系统中运行

1328
01:01:24,000 --> 01:01:25,960
But we would call these cloud native snowflakes, 
但我们会称这些云为原生雪花

1329
01:01:25,970 --> 01:01:28,480
probably the most fame in one of all these like they designed
可能是所有这些中最出名的一个

1330
01:01:28,490 --> 01:01:29,560
explicitly in the beginning, 
就像他们一开始明确设计的那样

1331
01:01:29,910 --> 01:01:32,370
not to run on pram, only to run in the cloud.
不在婴儿车上运行 只在云中运行

1332
01:01:32,680 --> 01:01:33,110
Then therefore, 
因此

1333
01:01:33,120 --> 01:01:35,700
you can make certain design choices which will cover next week. 
你可以做出某些设计选择 这将涵盖下周

1334
01:01:36,070 --> 01:01:37,540
That can take advantage of that. 
可以利用这一点

1335
01:01:39,760 --> 01:01:41,250
Want to make things also to that. 
想做的事也要到那去

1336
01:01:41,570 --> 01:01:44,190
Came out of the map produced world plus now with the cloud. 
从地图中产生的世界加上现在的云

1337
01:01:44,730 --> 01:01:46,360
Are these shared disk systems? 
这些是共享磁盘系统吗

1338
01:01:47,480 --> 01:01:48,350
Prior to this, 
在此之前

1339
01:01:48,720 --> 01:01:52,580
the the conventional wisdom of how you would build it and tribute
传统的智慧

1340
01:01:52,590 --> 01:01:53,980
a daily system is would be shared nothing. 
你将如何建立它和贡品每日系统是不会分享什么

1341
01:01:54,990 --> 01:01:57,610
Now with the cloud where amazon or whoever is taking care
现在有了云

1342
01:01:57,620 --> 01:01:59,170
of the storage layer for you, 
Amazon或任何为您负责存储层的人

1343
01:02:01,020 --> 01:02:02,640
you don't want to be able to share nothing system. 
你不想什么都不共享系统

1344
01:02:02,650 --> 01:02:06,620
You want to use a shared disk system and let the cloud vendor handle
您希望使用共享磁盘系统

1345
01:02:06,630 --> 01:02:07,300
the storage for you. 
并让云供应商为您处理存储

1346
01:02:08,550 --> 01:02:13,390
So there's a bunch of systems now built on top of this shared disk approach. 
因此 现在有许多系统都是基于这种共享磁盘方法构建的

1347
01:02:13,730 --> 01:02:14,510
This is the fact, 
这就是事实

1348
01:02:14,520 --> 01:02:17,670
this is how everyone's building modern data systems today. 
这就是今天每个人构建现代数据系统的方式

1349
01:02:18,670 --> 01:02:20,090
People talk about I have a data lake, 
人们谈论我有一个数据湖

1350
01:02:20,980 --> 01:02:21,190
right? 
对吗

1351
01:02:21,200 --> 01:02:22,510
Or we'll see this. 
否则我们会看到这个

1352
01:02:23,310 --> 01:02:24,260
When we talk about data bricks, 
当我们谈论数据砖块时

1353
01:02:25,920 --> 01:02:28,450
they're talking about basically serving on s three, right?
他们说的基本上是在S 3上服务 对吗

1354
01:02:28,580 --> 01:02:30,370
Something with a shared disk model. 
具有共享磁盘模型的东西

1355
01:02:32,980 --> 01:02:35,350
Every year I I got to complain about this. 
每年我都要抱怨这个

1356
01:02:37,910 --> 01:02:40,570
We're at the sort of phase now where it's, again, no sql,
我们现在正处于这样一个阶段

1357
01:02:41,280 --> 01:02:42,320
the no sequel women died out. 
再一次 没有sql 没有续集的女人消失了

1358
01:02:42,330 --> 01:02:49,910
People realize sequel is the way to go still coming along. 
人们意识到续集是未来的发展方向

1359
01:02:50,320 --> 01:02:52,760
I wouldn't necessarily maybe not necessarily call these new sequel systems, 
我不一定会把这些新的sequel系统称为sequel系统 但在过去的5

1360
01:02:53,540 --> 01:02:56,820
but they've definitely become more prominent in the last 5 or 6 years
6年里 它们肯定会变得更加突出

1361
01:02:57,270 --> 01:02:58,440
Or these graph database systems. 
或者这些图形数据库系统

1362
01:02:58,770 --> 01:03:03,740
But the idea is that instead of storing your database as relations, 
但其思想是不将数据库存储为关系

1363
01:03:04,910 --> 01:03:06,470
it's intrinsically, it's a graph.
从本质上讲 它是一个图表

1364
01:03:06,480 --> 01:03:09,780
Let me sort it as a graph structure between relations and so forth. 
让我把它分类为关系之间的图形结构等等

1365
01:03:09,790 --> 01:03:12,460
And this can be either rdf or triple store or property graphs. 
这可以是RDF或三元组存储或属性图

1366
01:03:12,470 --> 01:03:13,940
It has a bunch of different names. 
它有一堆不同的名字

1367
01:03:14,780 --> 01:03:17,500
But it's essentially the same thing that they were doing back in the 70s
但本质上

1368
01:03:17,670 --> 01:03:19,830
with the kodaso network model. 
这与他们在70年代用科达索网络模型所做的事情是一样的

1369
01:03:21,420 --> 01:03:24,930
So the big claim is that because you're starting a database
所以最大的声明是

1370
01:03:24,940 --> 01:03:26,490
as negatively as graphs. 
因为你正在启动一个像图表一样消极的数据库

1371
01:03:27,090 --> 01:03:30,520
And because you're now exposing a nato graph api you can be
因为您现在公开了一个NATO图形API

1372
01:03:30,530 --> 01:03:32,040
much better than a relational data system. 
所以您可以比关系数据系统好得多

1373
01:03:33,290 --> 01:03:33,960
We've heard that before. 
我们以前听说过

1374
01:03:34,130 --> 01:03:36,200
That was the argument for the object oriented databases. 
这就是面向对象数据库的论点

1375
01:03:36,930 --> 01:03:37,600
It's the object, 
它是物体

1376
01:03:39,270 --> 01:03:40,840
the jason databases, 
贾森数据库

1377
01:03:40,850 --> 01:03:42,120
all these people make the same argument. 
所有这些人都提出了同样的论点

1378
01:03:43,150 --> 01:03:47,980
And so sure there are some times what you do want to traverse your database
当然 有时您确实需要遍历数据库

1379
01:03:50,730 --> 01:03:52,720
in a sort of native graph way. 
以一种原生图形的方式

1380
01:03:54,330 --> 01:03:57,940
But the segal standard is actually adding support for graph queries this year. 
但Segal标准今年实际上增加了对图形查询的支持

1381
01:03:59,870 --> 01:04:00,760
And it's based on cipher, 
它是基于密码的

1382
01:04:00,770 --> 01:04:06,570
which was invented by by neo for j so they lose that advantage. 
这是由neo为j发明的 所以他们失去了优势

1383
01:04:07,440 --> 01:04:10,300
Then now what about the argument that if i'm starting things
那么 如果我以消极的方式开始

1384
01:04:10,310 --> 01:04:13,470
negatively as a graph is not going to be better than a relational database? 
那么图不会比关系数据库更好 这一论点又如何呢

1385
01:04:13,600 --> 01:04:13,710
No, 
不

1386
01:04:13,720 --> 01:04:17,120
because the paper that came out last week shows that if you built up db you
因为上周发表的一篇论文表明

1387
01:04:17,510 --> 01:04:21,860
incorporate some techniques that will help explicitly for graph
如果您构建了数据库 您就会结合一些技术

1388
01:04:21,870 --> 01:04:22,380
workloads. 
这些技术将明确地帮助图形工作负载

1389
01:04:22,790 --> 01:04:23,470
Like multi wave joins, 
就像多波加入 我们将在本学期晚些时候介绍

1390
01:04:23,480 --> 01:04:28,710
which we will cover a later the semester you cannot perform mu for j
你不能通过10 x dfoj为j执行mu

1391
01:04:28,720 --> 01:04:33,100
by ten x dfoj has raised hundreds of millions of dollars. 
dfoj已经筹集了数亿美元

1392
01:04:33,690 --> 01:04:38,900
Doctor b's like aa small team of people in the netherlands. 
B医生就像是荷兰的一个小团队

1393
01:04:40,190 --> 01:04:43,270
They beat them at 10:00X and it's a real system. 
他们以10:00的速度击败了他们 这是一个真正的系统

1394
01:04:43,280 --> 01:04:44,470
It's not just a toy. 
它不只是一个玩具

1395
01:04:49,150 --> 01:04:50,470
I think graph databases. 
我认为图表数据库

1396
01:04:51,480 --> 01:04:54,910
We've already see this racial model is absorbing ideas from it. 
我们已经看到这种种族模式正在吸收它的思想

1397
01:04:55,970 --> 01:05:00,930
I don't see these systems really replacing the the relation of davis is
在我的有生之年

1398
01:05:01,770 --> 01:05:02,380
in my lifetime. 
我没有看到这些系统真正取代戴维斯的关系

1399
01:05:02,820 --> 01:05:03,820
I should have put a speech on. 
我应该做个演讲的

1400
01:05:03,830 --> 01:05:09,780
Ii made a public bet where in I I made a public bet, 
我做了一个公开的赌注 我做了一个公开的赌注

1401
01:05:09,790 --> 01:05:13,090
they said in 2020 by 2030, 
他们说在2020年到2030年

1402
01:05:13,100 --> 01:05:16,350
the graph database market exceeds the racial database market. 
图形数据库市场超过了种族数据库市场

1403
01:05:16,700 --> 01:05:19,210
I will change my official cmu directory photo to be like so. 
我会把我的官方CMU目录照片改成这样

1404
01:05:19,500 --> 01:05:23,140
I'm sure when he says I love graph databases and I will use that until I
我敢肯定 当他说我喜欢图表数据库时

1405
01:05:23,150 --> 01:05:24,660
die or get fired from seeing you. 
我会一直使用它 直到我死了或者因为见到你而被解雇

1406
01:05:25,120 --> 01:05:26,610
Ii don't see it happening. 
我不认为这会发生

1407
01:05:28,450 --> 01:05:28,650
All right. 
好吧

1408
01:05:28,740 --> 01:05:30,810
So quickly finish up time series databases. 
所以很快就完成了时间序列数据库

1409
01:05:30,820 --> 01:05:34,740
So these are now newer databases that are designed to store, 
因此 现在这些是较新的数据库

1410
01:05:35,050 --> 01:05:39,030
telemetry you're collecting or metrics you're collecting from other services, 
旨在存储您正在收集的遥测数据或您正在从其他服务

1411
01:05:39,040 --> 01:05:40,310
other devices, and so forth.
其他设备等收集的指标

1412
01:05:40,830 --> 01:05:41,780
It's relational. 
它是关系型的

1413
01:05:42,270 --> 01:05:47,110
There's this notion of explicit time ordering and the data you're generating. 
有明确的时间顺序和你正在生成的数据的概念

1414
01:05:47,510 --> 01:05:47,770
Therefore, 
因此

1415
01:05:47,780 --> 01:05:52,420
you can design the system to officially take advantage of the domain
您可以将系统设计为正式利用您正在工作的

1416
01:05:52,430 --> 01:05:53,180
you're working in. 
领域

1417
01:05:53,990 --> 01:05:56,740
You wouldn't want to use these for storing arbitrary data. 
您不会想要使用它们来存储任意数据

1418
01:05:57,210 --> 01:05:59,320
If you have this notion of like ticks or events are showing
如果你有这样的概念

1419
01:05:59,330 --> 01:06:02,040
up with some notion of time, 
比如滴答声或事件与时间的概念一起出现

1420
01:06:02,520 --> 01:06:04,510
anyone do range queries based on those times, 
任何人都可以根据这些时间进行范围查询

1421
01:06:05,120 --> 01:06:07,140
you could design a system to be more efficient to do this. 
你可以设计一个系统来更有效地做到这一点

1422
01:06:07,850 --> 01:06:10,200
So probably the three main ones would be time scale, 
所以三个主要的可能是时间尺度

1423
01:06:10,210 --> 01:06:13,950
which is using extensions on top of post graphs, which is super cool,
这是在后图表之上使用扩展

1424
01:06:14,260 --> 01:06:17,440
because you get regular tables and post graphs plus the time series ones. 
这是超级酷的 因为你得到了常规的表格和后图表加上时间序列

1425
01:06:17,970 --> 01:06:20,440
Influx eb is written from scratch. 
流入EB是从头开始编写的

1426
01:06:21,150 --> 01:06:22,980
I think they're third rewrite, 
我想他们是第三次重写了

1427
01:06:24,480 --> 01:06:25,820
but again, 
但同样

1428
01:06:25,830 --> 01:06:27,100
they're targeting time series of this. 
他们的目标是时间序列

1429
01:06:29,710 --> 01:06:31,350
Click house is out of russia. 
点击房子不在俄罗斯

1430
01:06:32,690 --> 01:06:37,540
This is probably when I first learned about click as when you read
这可能是当我第一次了解点击时

1431
01:06:37,550 --> 01:06:38,980
the website and all the things that they supported. 
当你阅读网站和他们支持的所有东西时

1432
01:06:39,150 --> 01:06:40,740
It's a lot of techniques we discussed in the class. 
我们在课堂上讨论了很多技巧

1433
01:06:41,000 --> 01:06:41,620
It seemed unreal. 
这似乎不真实

1434
01:06:41,630 --> 01:06:43,090
This is super state of the art. 
这是最先进的

1435
01:06:44,370 --> 01:06:45,680
The performer summers look amazing. 
表演者萨默斯看起来棒极了

1436
01:06:45,940 --> 01:06:46,870
My impression, though,
不过 我的印象是 启动和运行并不容易

1437
01:06:46,880 --> 01:06:53,750
is that it is it's not easy to get up and running a there's still a lot
还有很多手工工作要做

1438
01:06:53,760 --> 01:06:54,710
of manual work you have to do, 
但我认为这将

1439
01:06:54,720 --> 01:06:56,590
but ii think this one's going to be aa big player. 
是一个大玩家

1440
01:06:56,920 --> 01:07:00,930
And then prometheus is another big effort in this space. 
普罗米修斯是这一领域的另一项重大成就

1441
01:07:03,370 --> 01:07:03,930
Last one, 
最后一个

1442
01:07:05,150 --> 01:07:05,780
block chain devices. 
区块链设备

1443
01:07:12,810 --> 01:07:13,190
Yes, bit coin.
是的 比特币

1444
01:07:13,640 --> 01:07:15,830
If you bought bit coin in 2010. 
如果你在2010年买了比特币

1445
01:07:15,840 --> 01:07:16,050
Great. 
棒极了

1446
01:07:16,060 --> 01:07:16,270
Thanks. 
谢谢

1447
01:07:16,650 --> 01:07:17,030
Congrats. 
祝贺

1448
01:07:18,730 --> 01:07:22,770
But like people had made claims that like block chain databases are
但就像人们曾经宣称的那样 区块链数据库是

1449
01:07:24,100 --> 01:07:25,850
under web three or what everyone call it. 
在网络三下 或者大家所说的

1450
01:07:25,860 --> 01:07:29,560
This is a radical different way of how you want to build modern applications. 
这是构建现代应用程序的一种完全不同的方式

1451
01:07:29,570 --> 01:07:33,120
The old way of having these provisioning servers over relational databases
在关系数据库和Sequel上提供这些服务器的旧方法

1452
01:07:33,130 --> 01:07:36,350
and sequel and whatever all that stupid you want to build on top
以及你想在区块链数据库上建立的所有愚蠢的东西

1453
01:07:36,360 --> 01:07:38,680
of a block chain database to solve all the world's problems. 
来解决世界上所有的问题

1454
01:07:40,020 --> 01:07:41,060
At the end of the day, what is a block chain?
说到底 什么是区块链

1455
01:07:42,220 --> 01:07:43,210
It's just a log. 
这只是一根木头

1456
01:07:43,620 --> 01:07:44,310
They would call a ledger. 
他们会叫账本

1457
01:07:44,320 --> 01:07:48,110
It's like, I write ahead log or the pack says log, the state log.
这就像 我提前写日志 或者包说日志 状态日志

1458
01:07:48,640 --> 01:07:51,030
Here's all the events or things that are happening to this day of the deeds. 
这里是所有的事件或事情正在发生的这一天的行为

1459
01:07:52,270 --> 01:07:54,660
Then they had these incremental check sums where the check sum
然后他们有这些增量校验

1460
01:07:54,790 --> 01:07:59,110
of a new entry in the log depends on the previous entry of the logs
和其中日志中新条目的校验和依赖于日志中以前的条目

1461
01:07:59,120 --> 01:07:59,390
that way. 


1462
01:07:59,400 --> 01:08:00,910
If you fudge anything below that. 
如果你捏造任何低于这个标准的东西

1463
01:08:01,410 --> 01:08:03,470
At a previous entry, the check sum doesn't match,
在上一个条目中 校验和不匹配

1464
01:08:03,480 --> 01:08:05,230
and you don't have the full data. 
并且您没有完整的数据

1465
01:08:05,980 --> 01:08:07,970
The technique was invented on merkel treats. 
这项技术是在默克尔的零食上发明的

1466
01:08:08,820 --> 01:08:09,160
Then now, 
然后现在

1467
01:08:09,170 --> 01:08:11,800
since you're assuming you're running in a decentralized distributed environment, 
因为你假设你在一个分散的分布式环境中运行

1468
01:08:12,240 --> 01:08:15,110
we don't trust the people that are reading right into the database. 
我们不信任那些直接读入数据库的人

1469
01:08:15,730 --> 01:08:19,540
You have to use some visiting fault tolerant or bft protocol to come
你必须使用一些访问容错或BFT协议来达成共识

1470
01:08:19,550 --> 01:08:20,260
to consensus to say, 
下一个放入日志的条目是什么

1471
01:08:20,270 --> 01:08:26,630
what's the next entry which put in a log I it's it's a lot of cool ideas
这是很多很酷的想法

1472
01:08:27,000 --> 01:08:28,920
and put together an interesting way, 
并以一种有趣的方式组合在一起

1473
01:08:29,380 --> 01:08:31,270
but is this game changer now? 
但现在这是游戏规则的改变者吗

1474
01:08:32,660 --> 01:08:32,740
Right? 
对的

1475
01:08:32,750 --> 01:08:38,560
I've yet to see a use case that everybody has proposed where a block chain
我还没有看到一个大家都提出的使用案例

1476
01:08:38,570 --> 01:08:40,810
would solve a problem that you could not solve
区块链可以解决像postgres这样的传统sql数据库

1477
01:08:40,820 --> 01:08:42,560
with a traditional sql database like postgres, 
无法解决的问题

1478
01:08:44,090 --> 01:08:49,540
or you have some external external issues you have to resolve through like law, 
或者你有一些外部的外部问题 你必须通过法律来解决

1479
01:08:50,370 --> 01:08:50,570
right? 
对吗

1480
01:08:50,580 --> 01:08:51,610
Or legal matters. 
或法律事务

1481
01:08:52,770 --> 01:08:53,260
Right? 
对的

1482
01:08:54,460 --> 01:08:58,390
So I think there's all garbage. 
所以我觉得都是垃圾

1483
01:09:00,290 --> 01:09:04,040
These systems here are explicitly doing block chain with a
这里的这些系统在我们的去中心化模型中明确地

1484
01:09:04,760 --> 01:09:06,270
in our decentralized model. 
用a来做区块链

1485
01:09:07,700 --> 01:09:10,960
This is the logo for podb amazon has the worst logos because it's like, 
这是podb的标志 亚马逊有最糟糕的标志

1486
01:09:11,230 --> 01:09:13,000
unless what is it right? 
因为它就像 除非它是对的

1487
01:09:13,010 --> 01:09:14,190
Like it. 
喜欢它

1488
01:09:14,560 --> 01:09:16,860
Qlqldb is our quantum ledger database. 
QLQLDB是我们的量子账本数据库

1489
01:09:17,160 --> 01:09:19,930
It's not a block chain database where it's like decentralized, 
它不是一个区块链数据库 它像去中心化的

1490
01:09:20,130 --> 01:09:21,500
like amazon, the trust of authority,
像亚马逊 权威的信任

1491
01:09:22,030 --> 01:09:23,340
like you authenticate amazon, 
像你认证亚马逊

1492
01:09:23,760 --> 01:09:26,890
you don't have to do bfti think they just do two base commit, 
你不需要做bfti 他们只需要做两个基本的提交

1493
01:09:28,450 --> 01:09:32,280
but you still get that verifiable ledger with the check sums. 
但你仍然可以得到可验证的总账和支票总额

1494
01:09:32,290 --> 01:09:33,810
As far as they know, 
据他们所知

1495
01:09:33,820 --> 01:09:39,040
this is not going anywhere they make way more money on selling, 
这是不会去任何地方 他们在销售上赚更多的钱

1496
01:09:39,990 --> 01:09:43,100
reselling my sequel and postcards as rds or under aurora. 
转售我的续集和明信片作为rds或根据极光

1497
01:09:44,720 --> 01:09:47,970
Again, I at this point when I first saw these devices,
再次 我在这一点上 当我第一次看到这些设备

1498
01:09:47,980 --> 01:09:50,640
but maybe there's something I convinced this is all crap. 
但也许有一些东西 我相信这一切都是废话

1499
01:09:52,630 --> 01:09:56,060
I was able to say there's no inherent data model to a a block chain database. 
我可以说区块链数据库没有固有的数据模型

1500
01:09:56,070 --> 01:09:57,580
It's just entries in the log just bytes. 
它只是日志中的条目 只是字节

1501
01:09:58,110 --> 01:10:00,750
There's some engine above it that has to interpret what those bytes are. 
它上面有一些引擎 必须解释这些字节是什么

1502
01:10:00,760 --> 01:10:01,950
So it could be a key value store, 
所以它可以是一个键值存储

1503
01:10:02,450 --> 01:10:03,170
relationship database. 
关系数据库

1504
01:10:03,710 --> 01:10:04,300
It doesn't matter. 
这不重要

1505
01:10:08,300 --> 01:10:10,420
There's a bunch of other stuff that should be 2020. 
还有一堆其他的东西应该是2020年

1506
01:10:10,430 --> 01:10:11,260
So there's a typo. 
所以有一个错别字

1507
01:10:11,270 --> 01:10:12,460
There's a bunch of other systems, 
还有很多其他的系统

1508
01:10:12,870 --> 01:10:15,560
categories of things we could talk about embedded databases
我们可以讨论嵌入式数据库

1509
01:10:15,570 --> 01:10:20,420
like sequel light and rock cb and duck
比如sequel light和rock cb和duck tb

1510
01:10:20,430 --> 01:10:24,560
tb those multi modal or multi model databases where like orangu
这些多模态或多模型数据库 比如orangu tv

1511
01:10:24,570 --> 01:10:27,480
tv where you try to support graphs and relations and documents
你可以尝试在一个数据库中支持图形

1512
01:10:27,490 --> 01:10:28,360
all in a single one. 
关系和文档

1513
01:10:29,150 --> 01:10:31,820
In the paper you guys read, we talked about harbor acceleration.
在你们读过的论文中 我们谈到了港口加速

1514
01:10:32,420 --> 01:10:36,000
Basically people like the the search for like eldorado, 
基本上 人们喜欢寻找埃尔多拉多

1515
01:10:36,490 --> 01:10:38,080
the golden city in south america. 
南美洲的黄金之城

1516
01:10:38,710 --> 01:10:41,640
There's been a search for some kind of hardware for databases for the last 40, 
在过去的四五十年里

1517
01:10:41,650 --> 01:10:42,200
50 years. 
人们一直在寻找某种数据库硬件

1518
01:10:42,780 --> 01:10:43,700
It never pans out. 
从来没有成功过

1519
01:10:44,440 --> 01:10:46,440
People keep trying, but it never works,
人们一直在尝试 但从来没有成功过

1520
01:10:46,950 --> 01:10:47,770
but not that it doesn't work. 
但并不是说它不起作用

1521
01:10:47,780 --> 01:10:52,420
It's just you it never gets the adoption in the market. 
它只是你 它永远不会在市场上得到采用

1522
01:10:53,250 --> 01:10:54,630
Commodity harbor was always going to win. 
商品港总是会赢的

1523
01:10:55,410 --> 01:10:59,250
I don't think fpg as or gp us are aa big game changer in the space. 
我不认为FPG AS或GP US是该领域的重大游戏规则改变者

1524
01:10:59,830 --> 01:11:01,830
Risk five, potentially some interesting stuff.
风险五 可能是一些有趣的东西

1525
01:11:02,140 --> 01:11:03,880
But where you're going to see hardware accelerates or databases
但是 只有google

1526
01:11:03,890 --> 01:11:07,090
is only going to be from the cloud vendors like google, 
amazon和microsoft等云供应商才能提供硬件加速或数据库

1527
01:11:07,410 --> 01:11:10,190
amazon, and microsoft, because it at their scale,
因为在他们的规模上

1528
01:11:10,200 --> 01:11:13,950
they can justify paying $50 million in development to build up new custom hardware, 
他们可以支付5000万美元的开发费用来构建新的定制硬件

1529
01:11:13,960 --> 01:11:17,200
because they're going to make so much money and be more efficient for. 
因为他们可以赚很多钱 而且效率更高

1530
01:11:17,680 --> 01:11:18,520
There are millions of customers. 
有数百万的客户

1531
01:11:19,560 --> 01:11:20,120
It's very hard to be. 
这很难做到

1532
01:11:20,130 --> 01:11:22,000
I think it'd be very hard for independent software vendor, 
我认为独立软件供应商

1533
01:11:22,010 --> 01:11:24,690
independent hardware vendor to break into that market, 
独立硬件供应商很难打入这个市场

1534
01:11:24,700 --> 01:11:27,970
because either because not only had the design to chip or whatever
因为他们不仅设计了芯片或其他硬件加速器

1535
01:11:27,980 --> 01:11:28,810
the hardware accelerator is, 
他们还无法说服

1536
01:11:28,820 --> 01:11:31,700
they didn't got to go convince some other software company to put it
其他软件公司将其放入自己的数据库中

1537
01:11:31,710 --> 01:11:32,220
in their database. 


1538
01:11:32,230 --> 01:11:33,840
And it never happens. 
但从来没有发生过

1539
01:11:35,000 --> 01:11:36,540
We didn't really talk about array matrix, 
我们并没有真正讨论数组矩阵

1540
01:11:36,550 --> 01:11:39,500
and the vector data sets the new buzzword now. 
而向量数据现在成为了新的流行词

1541
01:11:39,510 --> 01:11:40,260
Because of machine learning, 
由于机器学习

1542
01:11:40,350 --> 01:11:44,400
there's much of these new nearest neighbor search on vector vectors in new database. 
在新的数据库中有许多关于向量的新的最近邻搜索

1543
01:11:45,930 --> 01:11:47,020
These have been around for a while, 
这些已经存在了一段时间

1544
01:11:47,370 --> 01:11:48,730
but the vector ones are new. 
但矢量的是新的

1545
01:11:49,070 --> 01:11:50,860
I would say this is the only, 
我想说的是

1546
01:11:51,230 --> 01:11:52,410
as far as I know for now, 
据我所知

1547
01:11:52,840 --> 01:11:55,250
this is the only type of data you wouldn't actually want to use
这是唯一一种你不想使用关系数据库系统的数据类型

1548
01:11:55,260 --> 01:11:57,890
a relational database system for where you want to use
因为你想使用

1549
01:11:57,900 --> 01:11:59,730
a specialized system explicitly designed for vectors. 
专门为向量设计的系统

1550
01:12:00,900 --> 01:12:04,070
Because when you think about it, what if it's a multinational array,
因为当你考虑它时 如果它是一个多国数组

1551
01:12:04,440 --> 01:12:05,480
you've got to go traverse it, 
你必须遍历它

1552
01:12:05,490 --> 01:12:08,600
maybe row wise and column wise and in different dimensions, 
可能是按行和按列以及在不同的维度上

1553
01:12:09,030 --> 01:12:12,490
and storing that in a table with index columns is a bad idea. 
并且将其存储在具有索引列的表中是一个坏主意

1554
01:12:14,240 --> 01:12:19,120
So I think we'll see whether the market is big enough to justify needing
因此 我认为我们将看到市场是否足够大

1555
01:12:19,130 --> 01:12:20,240
a specialized system. 
以证明需要一个专门的系统

1556
01:12:20,690 --> 01:12:22,490
At this point, the answer is no, as I say, in the paper,
在这一点上 答案是否定的 正如我在论文中所说的

1557
01:12:22,500 --> 01:12:26,430
because is there does amazon or microsoft or google offer a vector database
因为亚马逊 微软或谷歌是否提供矢量

1558
01:12:26,440 --> 01:12:27,030
as a service? 
数据库服务

1559
01:12:27,370 --> 01:12:27,730
No. 
不

1560
01:12:28,540 --> 01:12:29,060
They could build one. 
他们可以建造一个

1561
01:12:29,070 --> 01:12:30,740
They have unlimited money, 
他们有无限的钱

1562
01:12:30,750 --> 01:12:33,710
but they don't see there being aa large market yet. 
但他们还没有看到一个大市场

1563
01:12:35,520 --> 01:12:38,640
So I think it's still too early, but I think this could be the next thing.
所以我认为现在还为时尚早 但我认为这可能是下一件事

1564
01:12:40,180 --> 01:12:40,260
Right? 
对的

1565
01:12:40,270 --> 01:12:42,100
And a there's a ton of these logos. 
有很多这样的标志

1566
01:12:43,140 --> 01:12:43,850
It's hard to keep track. 
很难跟踪

1567
01:12:47,200 --> 01:12:47,360
I clicked. 
我点击了

1568
01:12:47,370 --> 01:12:49,330
All right. 
好吧

1569
01:12:52,300 --> 01:12:53,870
What's going to happen in the future? 
未来会发生什么

1570
01:12:53,880 --> 01:12:57,340
So I think right now we're in the golden era databases, 
所以我认为现在我们正处于数据库的黄金时代

1571
01:12:57,660 --> 01:13:00,500
meaning like there's so many different choices, open source,
这意味着有这么多不同的选择

1572
01:13:00,510 --> 01:13:02,200
commercial cloud systems on pram. 
开源 pram上的商业云系统

1573
01:13:04,320 --> 01:13:07,360
Sequel is considered the way to go forward right now. 
续集被认为是现在前进的方向

1574
01:13:07,670 --> 01:13:08,910
Again, that'll change in 10 years,
再说一次 这将在10年内改变

1575
01:13:09,400 --> 01:13:10,590
but we'll be back again. 
但我们会再次回来

1576
01:13:11,150 --> 01:13:13,150
An example would be all the new sql systems for 10 years ago, 
一个例子是10年前的所有新SQL系统

1577
01:13:13,160 --> 01:13:13,790
except for retis. 
除了RETIS

1578
01:13:13,800 --> 01:13:15,720
I've either died, 
要么我已经死了

1579
01:13:16,440 --> 01:13:19,820
or they support sql and something that looks like the rational model. 
要么他们支持SQL和一些看起来像Rational模型的东西

1580
01:13:23,370 --> 01:13:28,470
It's like1+1 equals 2 that basic arithmetic from thousands of years ago. 
就像几千年前的基本算术1+1等于2

1581
01:13:29,840 --> 01:13:31,520
It stands the test of time because it's the right way to do this. 
它经受住了时间的考验 因为这是正确的做法

1582
01:13:32,040 --> 01:13:33,610
That's what I sort of see the relational model. 
这就是我在关系模型中看到的

1583
01:13:34,580 --> 01:13:36,460
Now sequel the best query language you could have
现在

1584
01:13:36,470 --> 01:13:37,660
for a relational database system. 
Sequel是关系数据库系统的最佳查询语言

1585
01:13:37,670 --> 01:13:38,100
No. 
不

1586
01:13:38,810 --> 01:13:40,760
There's obviously problems with it. 
它显然有问题

1587
01:13:41,710 --> 01:13:48,570
But at this. there's so much buy and there's so much existing tooling
但在这个 有这么多的购买和有这么多的现有工具

1588
01:13:49,970 --> 01:13:54,600
and utilities that assume the sql database system. 
和采用SQL数据库系统的实用程序

1589
01:13:54,610 --> 01:13:57,210
It would be very hard for anybody to change that. 
任何人都很难改变这一点

1590
01:13:58,900 --> 01:13:59,100
Right? 
对的

1591
01:13:59,110 --> 01:14:00,820
I there's so much fracturing in sequel itself, 
Sequel本身有太多的分裂

1592
01:14:00,830 --> 01:14:03,140
how you come along say I have a new query language, 
你怎么说我有一种新的查询语言

1593
01:14:03,980 --> 01:14:05,420
then everyone's going to start using it. 
然后每个人都会开始使用它

1594
01:14:06,170 --> 01:14:07,290
Yeah, you could build your one system that does it,
是的 你可以建立一个这样的系统

1595
01:14:07,300 --> 01:14:08,550
but then nobody else is going to use it. 
但没有其他人会使用它

1596
01:14:10,220 --> 01:14:13,760
So I don't know where sql is going to go with the future other than barring
所以我不知道SQL在未来会走向何方

1597
01:14:13,770 --> 01:14:18,060
ideas from other non sql systems. 
除了禁止其他非SQL系统的想法

1598
01:14:18,800 --> 01:14:21,550
But I see the relational model being standing the test of time. 
但我看到关系模式经受住了时间的考验

1599
01:14:21,560 --> 01:14:22,070
In my opinion. 
在我看来

1600
01:14:22,440 --> 01:14:24,330
There's a reason why ted kahn won the touring world war. 
泰德·卡恩赢得巡回世界大战是有原因的

1601
01:14:25,190 --> 01:14:26,830
Charles bachman won the turing wood for kodasal. 
查尔斯·巴赫曼为柯达萨尔赢得了图灵木奖

1602
01:14:27,490 --> 01:14:27,520
First, 
第一

1603
01:14:29,060 --> 01:14:30,010
the both days, it doesn't matter.
这两天 并不重要

1604
01:14:30,460 --> 01:14:31,830
All right. 
好吧

1605
01:14:31,840 --> 01:14:32,470
So next class, 
下节课

1606
01:14:33,040 --> 01:14:35,160
I got to go deal with some courts in seattle. 
我要去西雅图的一些法院

1607
01:14:35,680 --> 01:14:37,390
Next week will be not in person. 
下周将不会亲自

1608
01:14:37,400 --> 01:14:40,030
I'll post the monday lecture and wednesday lecture on youtube. 
我将在YouTube上发布周一和周三的讲座

1609
01:14:40,400 --> 01:14:43,090
But we'll kick off starting talking about modern medical daily systems. 
但我们将开球开始讨论现代医学日常系统

1610
01:14:43,730 --> 01:14:45,960
And we'll read about the papers about snowflake. 
我们会读关于雪花的报纸

1611
01:14:45,970 --> 01:14:47,200
It's from the snowflake people. 
它来自雪花人

1612
01:14:48,050 --> 01:14:49,160
There's some details about snowflake, 
有一些关于雪花的细节

1613
01:14:49,170 --> 01:14:51,400
but I really want to understand the big idea of like running
但我真的很想了解在云中的共享

1614
01:14:51,410 --> 01:14:52,840
on a shared disk architecture in the cloud. 
磁盘架构上运行的大想法

1615
01:14:53,760 --> 01:14:55,230
Make sure you submit your first reading of you
确保你提交了你的第一次阅读

1616
01:14:56,790 --> 01:15:00,400
before the class on2 o'clock wednesday, 
在星期三下午2点上课之前

1617
01:15:00,410 --> 01:15:00,760
right? 
对吗

1618
01:15:01,130 --> 01:15:01,840
I what did I say? 
我我说什么了

1619
01:15:02,180 --> 01:15:03,570
No, there's no reading reviews.
不 没有阅读评论

1620
01:15:06,050 --> 01:15:08,740
No, there is a did I say tuesday?
不 我说的是星期二吗

1621
01:15:09,310 --> 01:15:11,290
No, I i'm just confused.
不 我只是有点困惑

1622
01:15:11,540 --> 01:15:13,490
Make sure you spend your first reading for you. 
确保你的第一次阅读是为了你自己

1623
01:15:13,880 --> 01:15:14,440
Monday. 
周一

1624
01:15:18,320 --> 01:15:18,840
Awesome, guys.
太棒了伙计们

1625
01:15:19,190 --> 01:15:19,380
Thank you. 
谢谢

1626
01:15:19,390 --> 01:15:19,820
See you. 
一会儿见

1627
01:15:20,300 --> 01:15:23,050
Ha, that's my favorite all that.
哈 那是我最喜欢的

1628
01:15:25,690 --> 01:15:26,120
What is it? 
那是什么

1629
01:15:27,010 --> 01:15:28,560
It's the st cricket, 
这是st cricket

1630
01:15:28,570 --> 01:15:35,780
idesi make a mess unless I can do it like ago ice cube with the g to the e
idesi弄得一团糟 除非我能像ago ice cube那样做

1631
01:15:35,790 --> 01:15:37,540
to the t here comes duke. 
从g到e再到t杜克来了

1632
01:15:37,550 --> 01:15:38,460
I play the game. 
我玩游戏

1633
01:15:38,470 --> 01:15:39,300
Where's no roof? 
哪里没有屋顶

1634
01:15:39,310 --> 01:15:40,500
And poem is on the custody. 
诗在监护权上

1635
01:15:40,510 --> 01:15:41,940
I'm a focus on drink fruit. 
我专注于喝水果

1636
01:15:42,280 --> 01:15:44,830
Put the bus a cap on the eyes, bro, push.
把巴士的帽子放在眼睛上 兄弟 推

1637
01:15:44,840 --> 01:15:47,150
We gonna go with a blow to the eyes. 
我们要在眼睛上打一拳

1638
01:15:48,600 --> 01:15:51,270
Indeed, that's me rolling with 5th one,
事实上 这是我与第五个

1639
01:15:51,280 --> 01:15:55,390
south park and south central g and thank us when I party. 
南方公园和南部中心g一起滚动 并在我聚会时感谢我们

1640
01:15:55,760 --> 01:15:58,390
By the 12 pack case on the 46 pack, 
通过46包上的12包箱子

1641
01:15:58,400 --> 01:16:00,310
48 gets the real price. 
48得到了真实的价格

1642
01:16:00,610 --> 01:16:03,480
I drink fruit which are drinking about 12 hours, 
我喝了大约12个小时的水果

1643
01:16:03,490 --> 01:16:05,480
they say bill makes you fat, 
他们说比尔会让你变胖

1644
01:16:05,490 --> 01:16:07,040
but saying eyes is straight, 
但他们说眼睛是直的

1645
01:16:07,050 --> 01:16:08,600
so it really don't matter. 
所以这真的没关系